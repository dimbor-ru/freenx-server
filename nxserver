#!/bin/bash

# Free implementation of nxserver components
#
# To use nxserver add the user "nx"
# and use nxserver as default shell.
#
# Also make sure that hostkey based authentification works.
#
# Copyright (c) 2004 by Fabian Franz <FreeNX@fabian-franz.de>.
#           (c) 2008-19 by Dmitry Borisov <i@dimbor.ru>
#
# License: GNU GPL, version 2
#
# SVN: $Id: nxserver 612 2008-08-25 03:28:15Z fabianx $
#

shopt -s extglob

# Read the config file
# dimbor: it's temporary
. /usr/bin/nxloadconfig --userconf

. $SHARED_CONFS/nxfuncs

############### PACKAGE log.bm #######################
#
# Library of log functions (outsource)
#

# Loglevels:
# 1: Errors
# 2: Warnings
# 3: Important information
# 4: Server - Client communication
# 5: Information
# 6: Debugging information
# 7: stderror-channel of some applications

log() {
#args: <loglevel> <logstr>
	[ "$NX_LOG_LEVEL" -ge "$1" ] && shift && {
		[ -n "$1" ] &&
			echo -n "[$(date "+%d.%m %T.%3N")] " >> "$NX_LOGFILE"
		echo $@ >> "$NX_LOGFILE"
	}
}

# Log in a way that is secure for passwords / cookies / ...
echo_secure() {
	[ -n "$1" ] &&
		echo -n "[$(date "+%d.%m %T.%3N")] " >> "$NX_LOGFILE"
	local  res=${@//&password=*&/&password=****&}
	res=${res//--cookie=\"+([^\"])\"/--cookie=\"****\"}
	res=${res//--password=\"+([^\"])\"/--password=\"****\"}
	echo "$res"
}

log_secure() {
#args: <loglevel> <logstr>
	if [ "$NX_LOG_SECURE" = "0" ]; then log $@
	elif [ "$NX_LOG_LEVEL" -ge "$1" ]; then
		shift && echo_secure $@ >> "$NX_LOGFILE"
	fi
}

log_tee() {
	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] || exec cat -
}

log_error() {
	[ "$NX_LOG_LEVEL" -ge "7" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
	[ "$NX_LOG_LEVEL" -ge "7" -a -w "$NX_LOGFILE" ] || exec cat -
}

echo_x() { log "4" "$@"; echo "$@"; }

############### PACKAGE passdb.bm #######################
#
# Library of passdb functions (outsource)
#

# Policy: Variable and function names _must_ start with passdb_ / PASSDB_

# Needed global vars: $NX_ETC_DIR, $PATH_BIN

# Needed nonstd functions: md5sum

passdb_get_crypt_pass() { echo "$@" | $COMMAND_MD5SUM | cut -d" " -f1; }

passdb_get_pass() {
	PASSDB_CHUSER="$1"
	PASSDB_PASS=$(egrep "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null | cut -d":" -f2)
	if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" ]; then
		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null && echo $PASSDB_PASS
		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null || echo "NOT_VALID"
	else
		echo "NOT_VALID"
	fi
}

passdb_chpass() {
	PASSDB_CHUSER="$1"; PASSDB_ENC_PASS="$2"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	sed -i -e "s/$PASSDB_CHUSER:.*/$PASSDB_CHUSER:$PASSDB_ENC_PASS/g" $NX_ETC_DIR/passwords
}

passdb_user_exists() {
	PASSDB_CHUSER="$1"
	egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null
}


passdb_remove_user() {
	PASSDB_CHUSER="$1"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	sed -i -e "/$PASSDB_CHUSER:/d" $NX_ETC_DIR/passwords
}

passdb_add_user() {
	PASSDB_CHUSER="$1"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	echo "$PASSDB_CHUSER:*" >> $NX_ETC_DIR/passwords
	# deactivated to avoid problems with comm-server
	su - $PASSDB_CHUSER -c "$PATH_BIN/nxnode --setkey"
}

passdb_list_user() {
	cat $NX_ETC_DIR/passwords | cut -d":" -f1
}

#
# End of passdb Library
#

############### PACKAGE session.bm #######################
#
# Library of session management functions
#

# Needed global vars: $NX_SESS_DIR

# =================== sqlite3 stuff =====================

sess_bd="$NX_SESS_DIR/sessions.sq3"
sqcols_sess="sessionName, display, status, startTime, foreignAddress,\
 sessionRootlessMode, type, sessionId, creationTime, userName,\
 serverPid, screeninfo, geometry, host, shadowcookie, endTime"
sqcols_sess_c=16

migrate_old_conf_dirs() {
	local txt fn fields vals field val;
   for fn in $NX_SESS_DIR/{closed,failed}/*; do
		txt=$(< $fn); txt=${txt//=/ }; fields=""; vals="";
		while read field val; do
			fields+="${fields:+,}$field"; vals+="${vals:+,}'$val'";
		done <<< "$txt"
		q_dbe "INSERT INTO sess($fields) VALUES($vals);"
	done >/dev/null 2>&1
	log 1 "Info: Sessions db migrated to sqlite3 format."
	rm -rf $NX_SESS_DIR/{closed,failed,running} >/dev/null 2>&1
}

init_sess_db() {
	local sess_cols="sessionId TEXT PRIMARY KEY, sessionName TEXT,\
 display TEXT, status TEXT, startTime INT, foreignAddress TEXT,\
 sessionRootlessMode INT, type TEXT, creationTime INT, userName TEXT,\
 serverPid TEXT, screeninfo TEXT, geometry TEXT, host TEXT,\
 shadowcookie TEXT, endTime INT"
	local qstr="CREATE TABLE IF NOT EXISTS sessions.sess($sess_cols);"
	qstr+="CREATE INDEX IF NOT EXISTS sessions.idx_statusUserName ON\
 sess(status,userName);"
   q_dbe "$qstr"
}

exit_proc() {
	log 6 "$FUNCNAME: close_dbe"
	close_dbe;
	log 6 "$FUNCNAME: close_dbe end."
	exit $1;
}

#-------------------------------------------------------------------

session_list() {
#params: sessId  ["format_times"]
#if you need to humane output put something in $2
	local qc fls res r2="";
	[ -n "$2" ] && { fls="sessionName, display, status,\
 datetime(startTime,'unixepoch','localtime') AS startTime,\
 foreignAddress, sessionRootlessMode, type, sessionId,\
 datetime(creationTime,'unixepoch','localtime') AS creationTime, userName,\
 serverPid, screeninfo, geometry, host, shadowcookie,\
 datetime(endTime,'unixepoch','localtime') AS endTime";
	} || { # original order of fields
		fls=$sqcols_sess;
	}
   q_dbe ".mode line sess"
	res=$(qa_dbe $sqcols_sess_c "SELECT $fls FROM sess WHERE sessionId='$1' LIMIT 1;")
	[ -n "$2" ] && { 	echo "$res"; return; }
	local line k v;
	while read line; do
		k=$(trim "$(cutfn "$line" "=" 0)"); v=$(trim "$(cutfn "$line" "=" 1)") #"
		r2+="$k=$v"$'\n'
	done <<< "$res"
	echo -n "$r2"
}

session_find_cmdstrs() {
#params: [sessid] [user] [display] [status="Running|Suspended"]
#ret: sessions command strings delimited by \n
	local st wstr qc res;
	st="Running|Suspended"; [ -n "$4" ] && st="$4"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	[ -n "$1" ] && wstr+=" AND $(str_eq_cond "sessionId" "$1")"
	[ -n "$2" -a "$2" != "all" -a "$2" != ".*" ] && \
		wstr+=" AND $(str_eq_cond "userName" "$2")"
	[ -n "$3" ] && wstr+=" AND $(str_eq_cond "display" "$3")"
   q_dbe ".mode tabs sess"
	qc=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;"); #"
	[ "$qc" -gt "0" 2>/dev/null ] || return
	qc=$((qc*sqcols_sess_c))
   q_dbe ".mode line sess"
	res=$(qa_dbe $qc "SELECT $sqcols_sess FROM sess $wstr ORDER BY startTime DESC;")
	qtxt2cmdstrs "$res"
}

# Find all running session-filenames
session_find_all() { session_find_cmdstrs; }

# Find all running sessions of a id
session_find_id() { session_find_cmdstrs "$1"; }

# Finds out if a session belongs to a user
session_find_user() { session_find_cmdstrs "" "$1"; }

# Find all running sessions of a display
session_find_display() { session_find_cmdstrs "" "" "$1"; }

# Finds out if a session belongs to a user
session_find_id_user() {
#params: sessid [user]
	local wstr c;
	wstr="WHERE sessionId='$1' AND status IN ('Running', 'Suspended')"
	[ -n "$2" -a "$2" != "all" -a "$2" != ".*" ] && \
		wstr+=" AND $(str_eq_cond "userName" "$2")"
   q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	[ "$c" -gt "0" 2>/dev/null ] || return 1
	return 0
}

# session_get <uniqueid>
session_get()  { session_find_cmdstrs "$1"; }

# Get the first session, which can be resumed
session_get_user_suspended() {
#params: user status
#ret: sessionId line[s] or empty
	local wstr r a;
	wstr="WHERE status='$2'AND username='$1'"
   q_dbe ".mode tabs sess"
	r=$(qa_dbe "SELECT count(sessionId), sessionId FROM sess $wstr ORDER BY startTime DESC LIMIT 1;") #"
	a=($r); ((${#a[@]}==2)) && echo "${a[1]}"
}

# Count all sessions of a user
# and save it in SESSION_COUNT and SESSION_COUNT_USER

session_get_user_suspended() {
#params: user status
#ret: sessionId line[s] or empty
	local wstr r a;
	wstr="WHERE status='$2'AND username='$1'"
   q_dbe ".mode tabs sess"
	r=$(qa_dbe "SELECT count(sessionId), sessionId FROM sess $wstr ORDER BY startTime DESC LIMIT 1;") #"
	a=($r); ((${#a[@]}==2)) && echo "${a[1]}"
}

session_count_user() {
#params: userName [status]
	local st wstr r u="" sc="" uc
	SESSION_COUNT=0; SESSION_COUNT_USER=0
	st="Running|Suspended"; [ -n "$2" ] && st="$2"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	q_dbe ".mode tabs sess"
	if [ "$1" = ".*" -o "$1" = "all" ]; then
		SESSION_COUNT=$(qa_dbe "SELECT count(*) FROM sess $wstr;") #"
		SESSION_COUNT_USER=$SESSION_COUNT
		return 0
	fi
	uc=$(qa_dbe "SELECT count(DISTINCT userName) FROM sess $wstr LIMIT 1;") #"
	((uc==0)) && return;
	r=$(qa_dbe $uc "SELECT userName,count(*) FROM sess $wstr GROUP BY userName;") #"
	while read u sc; do
		[ -z "$sc" ] && continue
		let SESSION_COUNT=SESSION_COUNT+$sc
		[ "$u" = "$1" ] && SESSION_COUNT_USER=$sc
	done <<< "$r"
	return 0
}

_session_list_user_suspended() {
	local cmdstrs pattern geom depth render udepth urender mode;
	local options available uniqueid geo2 displays;
	echo "NX> 127 Sessions list of user '$1' for reconnect:"
	echo
	if [ -z "$4" ]
	then
		echo "Display Type             Session ID                       Options  Depth Screensize     Available Session Name"
		echo "------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------"
	else
		echo "Display Type             Session ID                       Options  Depth Screen         Status      Session Name"
		echo "------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------"
	fi
	cmdstrs=$(session_find_cmdstrs "" "$1" "" "$2")
	while read CMDLINE; do
		[ -z "$CMDLINE" ] && continue
		if [ "$4" = "shadow" -a "$(getparam userName)" != "$USER" ]; then
			[ -z "$(getparam shadowcookie)" ] && continue
			if [ -x "$COMMAND_NXSHADOWACL" ]; then
				$COMMAND_NXSHADOWACL "$(getparam userName)" "$USER" || continue
			fi
		fi

		pattern='^([0-9]*x[0-9]*)x([0-9]*)\+?([^+]*)'
		[[ $(getparam screeninfo) =~ $pattern ]]
		geom=${BASH_REMATCH[1]}; depth=${BASH_REMATCH[2]}; render=${BASH_REMATCH[3]}
		[[ $3 =~ $pattern ]]
		udepth=${BASH_REMATCH[2]}; urender=${BASH_REMATCH[3]}
		mode="D"; [ "$(getparam sessionRootlessMode)" = "1" ] && mode="-"
		options="-"; stringinstring "fullscreen" "$3" && options="F"
		[ "$(getparam geometry)" = "fullscreen" ] || options="-"
		[ "$urender" = "render" ] && options="${options}R${mode}--PSA"
		[ "$urender" = "render" ] || options="${options}-${mode}--PSA"
		[ "$udepth" = "$depth" -a "$urender" = "$render" ] && available=$(getparam status)
		# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
		if [ -z "$4" -a "$available" != "N/A" ]; then
			available="Yes"
		fi
		# We automatically offer VNC shadowed sessions for "remote" support
		if [ "$4" = "vnc" -a "$ENABLE_MIRROR_VIA_VNC" = "1" ] \
					&& stringinstring "unix-" "$(getparam type)"; then
			available=$(getparam status)
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "vnc-shadowed" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName) (Mirrored)"
		elif [ "$4" = "shadow" ]; then
			available=$(getparam status)
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "$(getparam type)" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName) ($(getparam userName)) (Shadowed)"
		else
			# only unix-* sessions can be resumed, but other session types can still be terminated
			stringinstring "unix-" "$4" || available="N/A"
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "$(getparam type)" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName)"
		fi
	done <<< "$cmdstrs"

	if [ "$4" = "vnc" -o "$4" = "shadow" -a "$ENABLE_DESKTOP_SHARING" = "1" ]; then
		export DESKTOP_SHARING_IDS=""
		geo2=$(rematchfn '^([[:digit:]]+x[[:digit:]]+)' $3) #'
		displays=$(LC_ALL=C netstat -ln --protocol=unix)
		displays=$(rematchfn 'X11-unix/X([0-9]+)' "$displays" "all")  #'
		for i in $displays; do
			uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
			uniqueid=${uniqueid%% *}; uniqueid=${uniqueid^^}
			DESKTOP_SHARING_IDS="$DESKTOP_SHARING_IDS $uniqueid=$i"
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$i" "Local" "$uniqueid" "--------" "$udepth" "$geo2" "Running" "X$i (Local)"
		done
	fi
	echo ""
	echo ""

	session_count_user "$1"
	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" -o \
			"$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]; then
		echo "NX> 147 Server capacity: reached for user: $1"
	else
		echo "NX> 148 Server capacity: not reached for user: $1"
	fi
}

session_list_user_suspended() {
	local SESSION_LIST_CACHE_DATA=$(_session_list_user_suspended "$@")
	echo "$SESSION_LIST_CACHE_DATA" | log_tee
}

session_list_user() {
#params: userName [status="Running|Suspended"]
	local st wstr c
	echo -n "NX> 127 Sessions list"
	if [ -n "$1" -a "$1" != "all" ]; then echo " of user '$1'"
	else echo ":"
	fi
	echo
	echo "Server	 Display Username		Remote IP	   Session ID"
	echo "------ ------- --------------- --------------- --------------------------------"
	st="Running|Suspended"; [ -n "$2" ] && st="$2"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	[ -n "$1" -a "$1" != "all" ] && wstr+=" AND $(str_eq_cond "userName" "$1")"
	q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	((c==0)) && return;
	qa_dbe $c "SELECT host,display,userName,foreignAddress,sessionId\
 FROM sess $wstr ORDER BY startTime DESC;" # ! check order !
}

session_history() {
#params: userName sessionId
	local wstr="" c;
	echo "NX> 127 Session list:"
	echo
	echo "Display Username		Remote IP	   Session ID					   Date				Status"
	echo "------- --------------- --------------- -------------------------------- ------------------- -----------"
	[ -n "$1" -a "$1" != "all" ] && wstr="$(str_eq_cond "userName" "$1")"
	[ -n "$wstr" -a -n "$2" ] && wstr+=" AND "
	[ -n "$2" ] && wstr+=" sessionId='$2'"
	[ -n "$wstr" ] && wstr="WHERE $wstr"
	q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	((c==0)) && return;
	qa_dbe $c "SELECT display,userName,foreignAddress,sessionId,\
 datetime(startTime,'unixepoch','localtime'),status\
 FROM sess $wstr ORDER BY startTime;" # ! check order !
}

# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
session_cleanup() {
	local checkTime st wstr;
	[ "$SESSION_HISTORY" -gt "-1" ] || return
	let checkTime=$(date +%s)-$SESSION_HISTORY
	st="Finished|Failed";
	wstr="WHERE $(str_eq_cond "status" "$st") AND startTime < $checkTime"
	q_dbe "DELETE FROM sess $wstr;"
}

session_list_all() { session_list_user "all"; }

session_add() {
#params: <session_id> <options>
	local t k v keys="" vals="";
	shift #sessid present separately for compat only
	t="$@"; t=${t//&/$'\n'}; t=${t//=/ }
	while read k v; do
		keys+="${keys:+,}$k"; vals+="${vals:+,}'$v'"
	done <<< "$t"
	q_dbe "INSERT INTO sess($keys) VALUES($vals);"
}

session_change() {
# <session_id> <parameter> <new_value> [<parameter> <new_value>]...
	local setls="" ssid="$1"; shift
	while [ -n "$1" -a  -n "$2" ]; do
		setls+="${setls:+,}$1='$2'"; shift; shift
	done
	q_dbe "UPDATE sess SET $setls WHERE sessionId='$ssid';"
}

# session_set_status <session_id> <new status>
session_set_status() { session_change "$1" "status" "$2"; }

# session_running <session_id> (? now dublicated session_find_id_user ?)
# return: true if running, false if not
session_running() { session_find_id_user "$1"; }

session_close() {
#param: <session_id>
	if [ "$SESSION_HISTORY" = "0" ] ; then
		q_dbe "DELETE FROM sess WHERE sessionId='$1';"
	else
		session_change "$1" "status" "Finished" "endTime" "$(date +%s)"
	fi
}

session_fail() {
#param: <session_id>
	if [ "$SESSION_HISTORY" = "0" ] ; then
		q_dbe "DELETE FROM sess WHERE sessionId='$1';"
	else
		session_change "$1" "status" "Failed" "endTime" "$(date +%s)"
	fi
}

session_suspend() {
#param: <session_id>
	session_change "$1" "status" "Suspended" "foreignAddress" "-"
}

#
# end of library
#


#
# Main nxserver <-> nxclient communication module
#

# do not run in server mode loop
SERVER_MODE="0"

# For users nxfree and nx run in SERVER MODE
[ "$USER" = "nxfree" -o "$USER" = "nx" ] && SERVER_MODE="1"

# We can override usermode via environment var
[ "$NX_USERMODE" = "1" ] && ENABLE_USERMODE_AUTHENTICATION="1"

# When usermode is 1, we only run in server loop
# if nxserver was run without any arguments or just with -c nxserver.
if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
	# do not run in server mode loop regardless of username
	SERVER_MODE="0"
	[ -z "$*" -o "$*" = "-c $PATH_BIN/nxserver" ] && SERVER_MODE="1"

	# Reread the config files (so that $USER.node.conf get sourced)
	. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf

	# We might need to reactivate this now
	ENABLE_USERMODE_AUTHENTICATION="1"
	# export the necessary variables
	export NX_SESS_DIR="$USER_FAKE_HOME/.nx/db/"
	export NX_LOGFILE="$USER_FAKE_HOME/.nx/temp/nxserver.log"
	mkdir -p $(dirname $NX_LOGFILE)
	open_dbe
	isdbs=""; [ -f $sess_bd ] && isdbs="1"
	attach_db $sess_bd
	init_sess_db
	[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
		-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs

	# we are logged in already
	LOGIN_SUCCESS="1"
	LOGIN_METHOD="USERMODE"

	# we do not use SLAVE mode for usermode
	ENABLE_SLAVE_MODE="0"
	# we do not use loadbalancing mode for usermode
	LOAD_BALANCE_SERVERS=""
fi

if [ "$SERVER_MODE" = "1" ]; then

#
# needed for slave mode
#

nxnode_login_stop_slave() {
	if [ -n "$NXNODE_LOGIN_SLAVE" ]; then
		log 3 "Info: Closing connection to slave with pid $NXNODE_LOGIN_SLAVE."
		# send quit command
		echo "--quit" >&$NX_COMMFD

		# kill process
		kill "$NXNODE_LOGIN_SLAVE"
		sleep 2
		kill -0 "$NXNODE_LOGIN_SLAVE" && kill -9 "$NXNODE_LOGIN_SLAVE"
		unset NXNODE_LOGIN_SLAVE
	fi
}

nxnode_login() {
	PASS="$1"; shift
	if [ "$NXNODE_LOGIN_SLAVE_ENABLED" != "1" ]; then
		NXNODE_TOSEND="$NXNODE_TOSEND" echo $PASS | \
			$PATH_BIN/nxnode-login "$@"
	else
		if [ -z "$NXNODE_LOGIN_SLAVE" -a -z "$NX_TRUSTED_USER" ]; then
			# Send password
			echo "$PASS" >&$NX_COMMFD

			# Connect to NXNODE
			( $PATH_BIN/nxnode-login "$1" "$2" "$3" "$4" "$5" \
				"--slave" <&$NX_SERVERFD >&$NX_SERVERFD 2>&$NX_SERVERFD \
				|| echo "FREENX> 716 Slave mode failed to start." \
					>&$NX_SERVERFD )  &
			NXNODE_LOGIN_SLAVE="$!"
			disown $!

			trap nxnode_login_stop_slave EXIT

			NXNODE_SLAVE_STARTED=""

			# FIXME: Make timeout configurable
			while read -t 10 line <&$NX_COMMFD
			do
				log 6 "$line"
				case "$line" in
					"NX> 716 Slave mode started successfully.")
						NXNODE_SLAVE_STARTED="1"
						break
					;;
					"FREENX> 716 Slave mode failed to start.")
						break
					;;
				esac
			done

			if [ -z "$NXNODE_SLAVE_STARTED" ]; then
				# stop it, if it still exists
				nxnode_login_stop_slave
				unset NXNODE_LOGIN_SLAVE
				# return an error
				return 1
			fi
		fi

		#send CMD to nxnode
		echo "$6" >&$NX_COMMFD
		[ -n "$NXNODE_TOSEND" ] && echo "$NXNODE_TOSEND" >&$NX_COMMFD

		NXNODE_RETURN="1"

		if [ -z "$NXNODE_READER" ]; then
			while read line <&$NX_COMMFD
			do
				log 6 "nxnode_reader: $line"
				echo "$line"
				case "$line" in
					"NX> 716"*)
						NXNODE_RETURN="0"
					;;
					"NX> 1001"*)
						break
					;;
				esac
			done
		fi
		test "$NXNODE_RETURN" = "0"
	fi
}

nxnode_login_register_reader() {
# Register a reader
	NXNODE_READER="1"
}

# Start!
open_dbe
isdbs=""; [ -f $sess_bd ] && isdbs="1"
attach_db $sess_bd
init_sess_db
[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
	-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs

log 3 "-- NX SERVER START: $@ - ORIG_COMMAND=$SSH_ORIGINAL_COMMAND"

if [ "$ENABLE_SERVER_FORWARD" = "1" -a -n "$SERVER_FORWARD_HOST" ]; then
	log 3 "Info: Forwarding connection to $SERVER_FORWARD_HOST with secret key $SERVER_FORWARD_KEY."
	$COMMAND_SSH -i "$SERVER_FORWARD_KEY" "-p$SERVER_FORWARD_PORT" \
		"nx@$SERVER_FORWARD_HOST" "host=$SERVER_NAME"
	exit_proc 0
fi

# Get the hostname out of SSH_ORIGINAL_COMMAND
PREFERRED_HOST=$(rematchfn "host=([^&]*)" "$SSH_ORIGINAL_COMMAND") #"

# forward the connection to commercial NoMachine server?
if [ "$ENABLE_NOMACHINE_FORWARD_PORT" = "1" -a "$NOMACHINE_FORWARD_PORT" = \
		"$(cutfn "$SSH_CLIENT $SSH2_CLIENT" " " 2)" -a \
		-n "$NOMACHINE_SERVER" ]; then
	log 3 "Info: Detected SSH destination port $NOMACHINE_FORWARD_PORT. Forwarding connection to commercial NoMachine server."
	exec $NOMACHINE_SERVER
	log 1 "Error: Forwarding to NoMachine Server $NOMACHINE_SERVER failed. Using FreeNX server instead."
fi

#
# nxnode slave mode preparations
#

NXNODE_LOGIN_SLAVE_ENABLED="0"; NXNODE_LOGIN_SLAVE=""

# slave mode does not work with load balancing
if [ -n "$LOAD_BALANCE_SERVERS" -a "$ENABLE_SLAVE_MODE" = "1" ]; then
	log 2 "Warning: Disabled slave mode. It does not work together with load balancing."
	ENABLE_SLAVE_MODE="0"
fi

if [ "$ENABLE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" != "1" -a \
		-z "$NX_TRUSTED_USER" ]; then
	export SSH_ORIGINAL_COMMAND; export NXSERVER_HELPER_ACTIVE="1"
	exec $PATH_BIN/nxserver-helper "$0"
	log 1 "Error: Execution of $PATH_BIN/nxserver-helper failed. Disabling slave mode of nxnode."
	export NXSERVER_HELPER_ACTIVE="0"
fi

if [ "$ENABLE_SLAVE_MODE" = "1" -a "$NXSERVER_HELPER_ACTIVE" = "1" ]; then
	log 3 "Info: Using fds #$NX_SERVERFD and #$NX_COMMFD for communication with nxnode."
	NXNODE_LOGIN_SLAVE_ENABLED="1"
fi

if [ -n "$NX_TRUSTED_USER" -a -n "$NX_COMMFD" ]; then
	NXNODE_LOGIN_SLAVE_ENABLED="1"
	USER=$NX_TRUSTED_USER
	# check that communication works
	nxnode_login "" -- su "$USER" "" "$PATH_BIN/nxnode" --check 2>&1 >/dev/null
	if [ $? -ne 0 ]; then
		log 1 "Error: Could not establish communication with trusted user ($USER) nxnode."
		echo_x "NX> 404 ERROR: wrong password or login"
		echo_x "NX> 999 Bye"
		exit_proc 1
	fi
	LOGIN_SUCCESS="1"; LOGIN_METHOD="SU"
	log 3 "Info: Using fd #$NX_COMMFD for communication with trusted user ($USER) established nxnode."
	# Reread the config files (so that $USER.node.conf get sourced)
	. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf
elif [ "$NX_USERMODE" = "1" ]; then
	log 3 "Info: Usermode authentication: Logged in as $USER."
else
	echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"

# Login stage
while true; do
	echo_x -n "NX> 105 "
	read CMD
	# FIXME?
	[ "$CMD" = "" ] && CMD="quit"
	echo_x "$CMD"
	case "$CMD" in
		quit|QUIT)
			echo_x "Quit"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		exit|EXIT)
			echo_x "Exit"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		bye|BYE)
			echo_x "Bye"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		hello*|HELLO*)
			PROTO=$(rematchfn 'Version ([[:digit:][:punct:]]+)' "$CMD") #'
			echo_x "NX> 134 Accepted protocol: $PROTO"
			if [ "$PROTO" = "1.3.0" -o "$PROTO" = "1.3.2" ]
			then
				[ "$ENABLE_AUTORECONNECT_BEFORE_140" = "1" ] && \
					ENABLE_AUTORECONNECT="1"
			fi
		;;
		"set auth_mode*"|"SET AUTH_MODE*")
			if [ "$CMD" = "set auth_mode password" -o \
					"$CMD" = "SET AUTH_MODE PASSWORD" ]; then
				echo_x "Set auth_mode: password"
			else
				echo_x "NX> 500 ERROR: unknown auth mode ''"
			fi
		;;
		login|LOGIN)
			LOGIN_SUCCESS="0"
			echo_x -n "NX> 101 User: "
			read USER2
			echo_x $USER2
			echo_x -n "NX> 102 Password: "
			old_ifs="$IFS"
			export IFS=$'\n'
			read -r -s PASS
			export IFS="$old_ifs"
			echo_x ""
			log 6 -n "Info: Auth method: "
			# USER already logged in?
			if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
				LOGIN_SUCCESS="1"
				# we have read the user config already above,
				# so we don't get any new information here
				break
			fi
			USER=$USER2

			# Guest authentication
			if [ "$USER" = "NX guest user" ]; then
				if [ "$ENABLE_GUEST_LOGIN" != "1" -o \
								! -x "$COMMAND_GUEST_LOGIN" ]; then
					if [ "$ENABLE_GUEST_LOGIN" != "1" ]; then
						echo_x "NX> 404 ERROR: guest authentication not enabled"
					else
						echo_x "NX> 404 ERROR: $COMMAND_GUEST_LOGIN not correct"
					fi
					echo_x "NX> 999 Bye"
					if [ "$ENABLE_LOG_FAILED_LOGINS" = "1" ]; then
						logger -t nxserver -i -p auth.info \
							"($(whoami)) Failed login for user=$USER from IP=$(echo $SSH_CLIENT \
							| awk '{print $1}')"
					fi
					exit_proc 1
				fi
				log 6 -n "guest "
				nxnode_login "" -- guest "" "" "$COMMAND_GUEST_LOGIN" \
					--check 2>&1 >/dev/null
				if [ $? -eq 0 ]; then LOGIN_SUCCESS="1"; LOGIN_METHOD="GUEST"; fi
			fi

			# PASSDB based auth
			if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" -a \
				"$LOGIN_SUCCESS" = "0" ]; then
				log 6 -n "passdb "
				if [ $(passdb_get_crypt_pass "$PASS") = \
					$(passdb_get_pass "$USER") ]; then
					LOGIN_SUCCESS="1"; LOGIN_METHOD="PASSDB"
				fi
			fi

			# SSH based auth
			if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]; then
				log 6 -n "ssh "
				export COMMAND_SSH
				nxnode_login "$PASS" -- ssh "$USER" "$SSHD_PORT" \
					"$PATH_BIN/nxnode" --check 2>&1 >/dev/null
				if [ $? -eq 0 ]; then LOGIN_SUCCESS="1"; LOGIN_METHOD="SSH"; fi
			fi

			# SU based auth
			if [ "$ENABLE_SU_AUTHENTICATION" = "1" -a \
					"$LOGIN_SUCCESS" = "0" ]; then
				log 6 -n "su "
				# experimental don't start nxnode --check
				LOGIN_SUCCESS="1"; LOGIN_METHOD="SU";
				#nxnode_login "$PASS" -- su "$USER" "" \
				#	"$PATH_BIN/nxnode" --check 2>&1 >/dev/null
				#if [ $? -eq 0 ]; then LOGIN_SUCCESS="1"; LOGIN_METHOD="SU"; fi
			fi

			# Check if user in passdb
			if [ "$ENABLE_USER_DB" = "1" ]; then
				log 6 "userdb check"
				passdb_user_exists "$USER" || LOGIN_SUCCESS="0"
			fi
			log 6 ""

			if [ "$LOGIN_SUCCESS" = "1" ]; then
				# Reread the config files (so that $USER.node.conf get sourced)
				# dimbor: it's temporary
				. /usr/bin/nxloadconfig --userconf
				break
			else
				echo_x "NX> 404 ERROR: wrong password or login"
				echo_x "NX> 999 Bye"
				if [ "$ENABLE_LOG_FAILED_LOGINS" = "1" ]; then
					logger -t nxserver -i -p auth.info \
						"($(whoami)) Failed login for user=$USER from IP=$(echo $SSH_CLIENT \
							| awk '{print $1}')"
				fi
				exit_proc 1
			fi
		;;
	esac
done
fi
echo_x "NX> 103 Welcome to: $SERVER_NAME user: $USER"

# Add the slave mode shutdown trap (just in case)
[ -n "$NXNODE_LOGIN_SLAVE" ] && trap nxnode_login_stop_slave EXIT

# remove old session infos from history
session_cleanup

#
# call it with: server_get_params $CMD # no ""!
#
server_get_params() {
	shift; SERVER_PARAMS=" $@"; SERVER_PARAMS=${SERVER_PARAMS// --/\&};
	SERVER_PARAMS=${SERVER_PARAMS//\"/};
	if [ "$SERVER_PARAMS" = "" ]; then
		echo_x -n "NX> 106 Parameters: "
		read SERVER_PARAMS2
		SERVER_PARAMS=${SERVER_PARAMS2//%2B/+}
		echo_x
	fi
	SERVER_PARAMS=${SERVER_PARAMS//%20/ };
}

nxnode_start() {
	:
	#CMD="$1"
	#shift
	#echo "$@" | $PATH_BIN/nxnode "$CMD"
}

#NX> 1002 Commit
#NX> 1006 Session status: running

server_nxnode_start() {
	CMD="$1"; USER="$2";
	shift; shift;

	# Find NODE_HOSTNAME
	NODE_HOSTNAME=""
	CMDLINE="$@"
	uniqueid=$(getparam uniqueid)
	[ -z "$uniqueid" ] && uniqueid=$(getparam sessionid)
	[ -z "$uniqueid" ] && uniqueid=$(getparam session_id)
	CMDLINE=$(session_get "$uniqueid")
	NODE_HOSTNAME="$(getparam host)"
	[ -z "$NODE_HOSTNAME" ] && NODE_HOSTNAME="127.0.0.1"
	export NODE_HOSTNAME
	# Use nxnode-login?
	if [ "$LOGIN_METHOD" = "GUEST" ]; then
		NXNODE_TOSEND="$@" nxnode_login "" -- \
			guest "" "" "$COMMAND_GUEST_LOGIN" "$CMD" 2>&1 | log_tee
	elif [ "$LOGIN_METHOD" = "SSH" ]; then
	    export COMMAND_SSH
	    NXNODE_TOSEND="$@" nxnode_login "$PASS" -- \
			ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
	elif [ "$LOGIN_METHOD" = "SU" ]; then
	    NXNODE_TOSEND="$@" nxnode_login "$PASS" -- \
			su "$USER" "" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
	elif [ "$LOGIN_METHOD" = "USERMODE" ]; then
	    # we need to unset SSH_* variables so that nxnode
	    # chooses the right accept= value.
	    unset SSH_CLIENT SSH_CLIENT2
	    echo "$@" | $PATH_BIN/nxnode "$CMD" 2>&1 | log_tee
	else
	    echo "$@" | $COMMAND_SSH -l "$USER" "$NODE_HOSTNAME" -p $SSHD_PORT \
			-x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' \
			-o 'RSAAuthentication yes' -o 'RhostsAuthentication no' \
			-o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' \
			-o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
	fi
}

server_add_usession() {
	[ "$ENABLE_USESSION" = "1" ] || return
	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -a $USER 2>&1 | \
		log_error
}

server_remove_usession() {
	[ "$ENABLE_USESSION" = "1" ] || return
	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -d $USER 2>&1 | \
		log_error
}

server_nxnode_echo() {
	log 6 "server_nxnode_echo: $@"
	[ "$SERVER_CHANNEL" = "1" ] && echo "$@"
	[ "$SERVER_CHANNEL" = "2" ] && echo "$@" >&2
}

server_nxnode_exit_func() {
	log 1 "Info: Emergency-Shutting down due to kill signal ..."
	session_fail $uniqueid
	server_remove_usession
	# remove lock file
	[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock
	# Kill possible slave node
	nxnode_login_stop_slave
}

server_nxnode_start_wait() {
	if [ "$1" = "--startsession" ]; then
		server_add_usession
		# We need to stop sending things when a SIGPIPE arrives
		trap "SERVER_CHANNEL=0" SIGPIPE
		trap server_nxnode_exit_func EXIT
		SERVER_CHANNEL=1; KILL_WAIT_PID=1
		server_nxnode_start "$@" | while read CMD;
		do
			case "$CMD" in
				"NX> 706"*)
					if [ -x "$COMMAND_NXSHADOWACL" ]; then
						# check if we should save the cookie
						$COMMAND_NXSHADOWACL "$USER"
						if [ $? -eq 0 ]; then
							SHADOW_COOKIE=$(cutfn "$CMD" ":" 1)
							SHADOW_COOKIE=${SHADOW_COOKIE// /}
							session_change "$uniqueid" "shadowcookie" "$SHADOW_COOKIE"
						fi
					fi
				;;
				"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
					case "$CMD" in
						*running*)
							[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
							KILL_WAIT_PID=0
							log 6 session_set_status $uniqueid "Running"
							session_set_status $uniqueid "Running"
							[ "$SERVER_CHANNEL" = "1" ] && SERVER_CHANNEL=2
						;;
						*closed*)
							log 6 session_close $uniqueid
							session_close $uniqueid
						;;
						*suspended*)
							[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
							KILL_WAIT_PID=0
							log 6 session_suspend $uniqueid
							session_suspend $uniqueid
						;;
						*suspending*)
							log 6 session_set_status $uniqueid "Suspending"
							session_set_status $uniqueid "Suspending"
							# we need to stop sending to client as it will have already
							# closed his side of the channel and this will lead to not
							# closed sessions.
							SERVER_CHANNEL=0
						;;
						*terminating*)
							log 6 session_set_status $uniqueid "Terminating"
							session_set_status $uniqueid "Terminating"
							# we need to stop sending to client as it will have already
							# closed his side of the channel and this will lead to not
							# closed sessions.
							SERVER_CHANNEL=0
						;;
					esac
				;;
				"NX> 1004"*)
					[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
					KILL_WAIT_PID=0
					session_fail $uniqueid
					server_nxnode_echo "NX> 596 Session startup failed."
					log 4 "NX> 596 Session startup failed."
				;;
			esac

			case $CMD in
				"NX> "*)
					server_nxnode_echo $CMD
				;;
			esac
		done

		trap - EXIT
		trap - SIGPIPE
		# Close it in case the session is still running
		session_running $uniqueid && session_close $uniqueid
		server_remove_usession

		# remove lock file
		[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock

		nxnode_login_stop_slave
	# $1 = restore
	else
		KILL_WAIT_PID=1
		SERVER_CHANNEL=1
		server_nxnode_start "$@" | while read CMD
		do
			case "$CMD" in
				"NX> 706"*)
					if [ -x "$COMMAND_NXSHADOWACL" ]; then
						# check if we should save the cookie
						$COMMAND_NXSHADOWACL "$USER"
						if [ $? -eq 0 ]; then
							SHADOW_COOKIE=$(cutfn "$CMD" ":" 1)
							SHADOW_COOKIE=${SHADOW_COOKIE// /}
							session_change "$uniqueid" "shadowcookie" "$SHADOW_COOKIE"
						fi
					fi
				;;
				"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
					case "$CMD" in
						*running*)
							[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
							KILL_WAIT_PID=0
							SERVER_CHANNEL=2
						;;
					esac
				;;
				"NX> 1004"*)
					[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
					KILL_WAIT_PID=0
					# This fail is correct here as somehow the
					# monitor process might have died and we don't
					# want the session to be resumed again.
					session_fail $uniqueid
					server_nxnode_echo "NX> 596 Session startup failed."
					log 4 "NX> 596 Session startup failed."
					break;
				;;
			esac
			case $CMD in
				"NX> "*)
					server_nxnode_echo $CMD
				;;
			esac
		done
		nxnode_login_stop_slave
		# $1 = start
	fi
}

server_check_session_count() {
	session_count_user "$USER"
	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" ]; then
		echo_x "NX> 599 Reached the maximum number of concurrent sessions on this server."
		echo_x "NX> 500 ERROR: Last operation failed."
		return 1
	fi
	if [ "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]; then
		echo_x "NX> 599 Server capacity: reached for user: $USER"
		echo_x "NX> 500 ERROR: Last operation failed."
		return 1
	fi
	return 0
}

server_loadbalance_random() {
	# Pick one based on "random" algorithm
	SERVER_LB_HOSTS=( $LOAD_BALANCE_SERVERS )
	SERVER_LB_NR_OF_HOSTS=${#SERVER_LB_HOSTS[@]}
	let SERVER_LB_NR=(RANDOM % SERVER_LB_NR_OF_HOSTS)
	SERVER_LB_HOST=${SERVER_LB_HOSTS[$SERVER_LB_NR]}
	echo $SERVER_LB_HOST
}

# run in subshell!
server_loadbalance_round_robin() {
	SERVER_LB_HOSTS=( $LOAD_BALANCE_SERVERS )
	SERVER_LB_NR_OF_HOSTS=${#SERVER_LB_HOSTS[@]}
	# Atomic incrementation:
	# Enter critical section
	# - Create .lock file
	SERVER_LB_LOCKFILE=$(mktemp "$NX_SESS_DIR/round-robin.lock.XXXXXXXXX")
	trap "rm -f $SERVER_LB_LOCKFILE" EXIT
	i=0
	while [ $i -lt 200 ]; do
		# ln is an atomic operation
		ln $SERVER_LB_LOCKFILE "$NX_SESS_DIR/round-robin.lock" && break
		LANG=C sleep 0.01
		let i=i+1
	done

	if [ $i -ge 200 ]; then
		log 1 "Load-Balancing: Round-Robin failed to gain lock file in 200 tries. Falling back to random."
		server_loadbalance_random
		return
	fi
	trap "rm -f \"$SERVER_LB_LOCKFILE\" \"$NX_SESS_DIR/round-robin.lock\"" EXIT

	# Lock held
	SERVER_LB_NR=$(cat $NX_SESS_DIR/round-robin 2>/dev/null)
	let SERVER_LB_NR=(SERVER_LB_NR+1)%SERVER_LB_NR_OF_HOSTS
	echo $SERVER_LB_NR >$NX_SESS_DIR/round-robin

	# Exit critical section
	rm -f "$SERVER_LB_LOCKFILE" "$NX_SESS_DIR/round-robin.lock"
	trap - EXIT

	SERVER_LB_HOST=${SERVER_LB_HOSTS[$SERVER_LB_NR]}
	echo $SERVER_LB_HOST
}

server_loadbalance_load() {
	SERVER_LB_MAX=0; SERVER_LB_HOST=""
	export PATH_BIN
	for i in $LOAD_BALANCE_SERVERS; do
		SERVER_LB_LOAD=$($COMMAND_NXCHECKLOAD $i)
		[ -z "$SERVER_LB_LOAD" ] && continue
		if [ $SERVER_LB_LOAD -gt $SERVER_LB_MAX ]; then
			SERVER_LB_MAX=$SERVER_LB_LOAD
			SERVER_LB_HOST=$i
		fi
	done
	echo $SERVER_LB_HOST
}

server_loadbalance() {
	SERVER_HOST="127.0.0.1"
	if [ -n "$LOAD_BALANCE_SERVERS" ]; then
		SERVER_HOST=""
		if [ -n "$PREFERRED_HOST" -a "$ENABLE_LOAD_BALANCE_PREFERENCE" = "1" ]; then
			stringinstring " $PREFERRED_HOST " " $LOAD_BALANCE_SERVERS " && \
				SERVER_HOST="$PREFERRED_HOST"
		fi
		# Fallback if still empty
		if [ -z "$SERVER_HOST" ]; then
			case "$LOAD_BALANCE_ALGORITHM" in
				random)
					SERVER_HOST=$(server_loadbalance_random)
				;;
				round-robin)
					SERVER_HOST=$(server_loadbalance_round_robin)
				;;
				load)
					SERVER_HOST=$(server_loadbalance_load)
				;;
			esac
		fi
		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"
		[ -n "$SERVER_HOST" ] && log 5 "Info: Load-Balancing (if possible) to $SERVER_HOST ..."
	fi
	echo "$SERVER_HOST"
}

server_startrestore_session() {
	ACTION="$1"
	server_get_params $CMD
	PARAMS=$SERVER_PARAMS
	PARAMS="$PARAMS&clientproto=$PROTO"
	PARAMS="$PARAMS&login_method=$LOGIN_METHOD"
	CMDLINE=$PARAMS
	echo_x

	# special shadowed type
	[ "$ACTION" != "start" -a "$(getparam type)" = "vnc" ] && ACTION="shadow"

	if [ "$ACTION" = "shadow" ]; then
		ACTION="start"
		uniqueid=$(getparam restore)
		[ -z "$uniqueid" ] && uniqueid=$(getparam id) # 1.4.0-5 compatibility
		CMDLINE=$(session_get "$uniqueid" 2>/dev/null)

		shadowdisplay=$(getparam display)
		shadowhost=$(getparam host)
		shadowcookie=$(getparam shadowcookie)
		shadowuser=$(getparam userName)
		[ "$shadowcookie" = "none" ] && shadowcookie=""
		if [ -z "$shadowdisplay"  ]; then
			# check for DESKTOP_SHARING_IDS
			shadowdisplay=$(rematchfn "$uniqueid=([^ ]*)" "$DESKTOP_SHARING_IDS") #"
			shadowhost="127.0.0.1"
		fi
		if [ -z "$shadowdisplay" ]; then
			echo_x "NX> 596 Could not find shadowed session $uniqueid. Session failed."
			echo_x "NX> 596 Sharing: $DESKTOP_SHARING_IDS"
			return 1
		fi
		[ "$shadowhost" = "127.0.0.1" ] && shadowhost=""

		# not the same user? So we have a shadow cookie, we add to xauth
		if [ -n "$shadowcookie" -a \
				"$ENABLE_SESSION_SHADOWING_AUTHORIZATION" = "1" ]; then
			# Ask for permission first:
			echo_x "NX> 726 Asking user for authorization to attach to session"
			export XAUTHORITY=".Xauthority-$RANDOM-$$"
			$COMMAND_XAUTH add "$shadowhost:$shadowdisplay" MIT-MAGIC-COOKIE-1 \
				"$shadowcookie" >/dev/null 2>&1
			PERMISSION=$(
				$PATH_BIN/nxdialog -display $shadowhost:$shadowdisplay \
					-dialog yesno -caption "Authorization Request" \
					-message "Do you want to allow $USER to shadow your session?" 2>/dev/null &
				SHADOW_DIALOG_PID=$!
				I=0
				while kill -0 $SHADOW_DIALOG_PID 2>/dev/null; do
					let I=I+1
					[ $I -gt "$AGENT_STARTUP_TIMEOUT" ] && \
						kill $SHADOW_DIALOG_PID 2>/dev/null
					sleep 1
				done
				echo "no"
			)
			$COMMAND_XAUTH remove "$shadowhost:$shadowdisplay"
			rm -f "$XAUTHORITY"

			if [ "$PERMISSION" = "no" ]; then
				# User answered NO
				echo_x "NX> 596 Error: Authorization refused by user: $shadowuser."
				return 1
			fi
		fi

		PARAMS="$PARAMS&shadowdisplay=$shadowdisplay&shadowhost=$shadowhost&shadowcookie=$shadowcookie&shadowuser=$shadowuser"
		CMDLINE=$PARAMS
	fi
	if [ "$ACTION" = "start" ]; then

		# Hack for external RDP/RFB agents
		if [ "$ENABLE_EXTERNAL_NXDESKTOP" = "1" -a \
				"$(getparam type)" = "windows" ]; then
			type="windows-helper"
			PARAMS="$PARAMS&type=$type&freenx_export_agents=1"
			CMDLINE=$PARAMS
		fi

		if [ "$ENABLE_EXTERNAL_NXVIEWER" = "1" -a \
				"$(getparam type)" = "vnc" ]; then
			type="vnc-helper"
			application="$PATH_BIN/nxviewer_helper"
			PARAMS="$PARAMS&type=$type&application=$application&freenx_export_agents=1"
			CMDLINE=$PARAMS
		fi
	fi
	# If we can't get the userip and SSHD_CHECK_IP is set to 1
	# we bail out.
	if [ -z "$SSH_CLIENT" -a -z "$SSH2_CLIENT" ]; then
		if [ "$SSHD_CHECK_IP" = "1" ]; then
			echo_x "NX> 596 Session startup failed. (Missing SSH_CLIENT environment variable)"
			return 1
		else
			log 2 "Warning: Failed to determine the client IP."
			log 2 "Warning: The SSH_CLIENT or SSH2_CLIENT variable was not provided by SSHD."
			log 2 "Warning: Please set SSHD_CHECK_IP=1 if you want to refuse the connection."
		fi
	fi
	export ENCRYPTION=$(getparam encryption)
	if [ "$ENABLE_FORCE_ENCRYPTION" = "1" -a "$ENCRYPTION" != "1" ]; then
			echo_x "NX> 596 Unencrypted sessions are not allowed."
			return 1
	fi

	if [ -x "$COMMAND_NXACL" ]; then
			log 3 "Info: Using $COMMAND_NXACL to change session parameters or deny session."
			NEW_PARAMS=$($COMMAND_NXACL "$CMDLINE")
			if [ $? -ne 0 ]; then
				echo_x "NX> 596 The session failed due to a nxacl policy setting: $NEW_PARAMS"
				return 1
			fi

			# check if the acl input did make sense
			if [ -n "$NEW_PARAMS" ]; then
				PARAMS=$NEW_PARAMS
				CMDLINE=$PARAMS
			fi
	fi

	# check if there is a suspended session, which we could resume
	if [ "$ENABLE_AUTORECONNECT" = "1" -a "$ACTION" = "start" ]; then
		restore=$(session_get_user_suspended "$USER" "Suspended")
		if [ -n "$restore" ]; then
			PARAMS="$PARAMS&restore=$restore"
			CMDLINE=$PARAMS
			ACTION="resume"
		fi
	fi

	# as only $SSH_CLIENT or $SSH2_CLIENT will be set, this should work
	USERIP=$(rematchfn "($ip4_pattern)" "$SSH_CLIENT $SSH2_CLIENT") #"
	[ -z "$USERIP" ] && USERIP="*"
	if [ "$ACTION" = "start" -o "$ACTION" = "shadow" ]; then
		server_check_session_count || return 1

		# Possibly do loadbalancing
		SERVER_HOST=$(server_loadbalance)

		# start nxnode
		SESS_DISPLAY=$DISPLAY_BASE
		let SESS_DISPLAY_LIMIT=$DISPLAY_BASE+$DISPLAY_LIMIT
		# stupid but working algo ...

		while true; do
			while [ -e /tmp/.X$SESS_DISPLAY-lock -o \
					-e "/tmp/.nX$SESS_DISPLAY-lock"  -o \
					-e "/tmp/.X11-unix/X$SESS_DISPLAY" ]; do
				let SESS_DISPLAY=$SESS_DISPLAY+1
			done

			# Check if there is already an agent running on that display on that host
			let AGENT_DISPLAY=$SESS_DISPLAY+6000
			if $COMMAND_NETCAT -z "$SERVER_HOST" $AGENT_DISPLAY 2>/dev/null; then
				log 2 "Warning: Stray nxagent without .nX$SESS_DISPLAY-lock found on host:port $SERVER_HOST:$AGENT_DISPLAY."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			let PROXY_DISPLAY=$SESS_DISPLAY+4000
			if $COMMAND_NETCAT -z "$SERVER_HOST" $PROXY_DISPLAY 2>/dev/null; then
				log 2 "Warning: nxagent proxy without .nX$SESS_DISPLAY-lock found on host:port $SERVER_HOST:$AGENT_DISPLAY."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			# Now check for the other enabled services
			let SAMBA_DISPLAY=$SESS_DISPLAY+3000
			if [ "$(getparam 'samba')" = 1 ] && ( $COMMAND_NETCAT -z \
					"$SERVER_HOST" $SAMBA_DISPLAY 2>/dev/null ); then
				log 2 "Warning: Skipping $SERVER_HOST:$AGENT_DISPLAY as samba port is not free."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			let MEDIA_DISPLAY=$SESS_DISPLAY+7000
			if [ "$(getparam 'media')" = 1 ] && ( $COMMAND_NETCAT -z \
					"$SERVER_HOST" $MEDIA_DISPLAY 2>/dev/null ); then
				log 2 "Warning: Skipping $SERVER_HOST:$AGENT_DISPLAY as media port is not free."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			let CUPS_DISPLAY=$SESS_DISPLAY+9000
			if [ "$(getparam 'cups')" = 1 ] && ( $COMMAND_NETCAT -z \
					"$SERVER_HOST" $CUPS_DISPLAY 2>/dev/null ); then
				log 2 "Warning: Skipping $SERVER_HOST:$AGENT_DISPLAY as cups port is not free."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			SESS_LOCKFILE=$(mktemp "/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX")
			# ln is an atomic operation
			ln "$SESS_LOCKFILE" "/tmp/.nX$SESS_DISPLAY-lock" 2>/dev/null && break
		done

		rm -f "$SESS_LOCKFILE"
		if [ "$SESS_DISPLAY" -gt "$SESS_DISPLAY_LIMIT" ]; then
			echo_x "NX> 596 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock."
			rm -f "/tmp/.nX$SESS_DISPLAY-lock"
			return
		fi
		uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
		uniqueid=${uniqueid%% *}; uniqueid=${uniqueid^^}
		FULL_PARAMS="$PARAMS&user=$USER&userip=$USERIP&uniqueid=$uniqueid&display=$SESS_DISPLAY&host=$SERVER_HOST"
		log_secure "6" "$FULL_PARAMS"

		# now update the session listing
		sessionRootlessMode=0
		[ "$(getparam rootless)" = "1" ] && sessionRootlessMode=1
		CMDLINE="a=b&$FULL_PARAMS"
		session_add $uniqueid "sessionName=$(getparam session)&\
display=$(getparam display)&status=Running&startTime=$(date +%s)&\
foreignAddress=$(getparam userip)&sessionRootlessMode=$sessionRootlessMode&\
type=$(getparam type)&sessionId=$uniqueid&creationTime=$(date +%s)&\
userName=$USER&serverPid=$SERVER_PID&screeninfo=$(getparam screeninfo)&\
geometry=$(getparam geometry)&host=$SERVER_HOST&shadowcookie=none"
	else
		uniqueid=$(getparam restore)
		[ -z "$uniqueid" ] && uniqueid=$(getparam id) # 1.4.0-5 compatibility
		session_change "$uniqueid" "foreignAddress" "$USERIP"

		CMDLINE=$(session_get "$uniqueid")
		FULL_PARAMS="$PARAMS&user=$USER&userip=$(getparam foreignAddress)&uniqueid=$uniqueid&display=$(getparam display)&status=$(getparam status)"
		SESS_DISPLAY=$(getparam display)
		SERVER_HOST=$(getparam host)
		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"

		if [ "$ENABLE_ADVANCED_SESSION_CONTROL" = "1" ]; then
			CMDLINE="$FULL_PARAMS"
			case "$(getparam session)" in
				"add "*)
					server_nxnode_start --applicationsession "$USER" \
						"$FULL_PARAMS"
					echo_x "Quit"
					echo_x "NX> 999 Quit"
					exit_proc 1
				;;
			esac
		fi
	fi

	# now start the node
	sleep $AGENT_STARTUP_TIMEOUT &
	SERVER_WAIT_PID=$!
	( server_nxnode_start_wait --"$ACTION"session $USER "$FULL_PARAMS" ) &
	SERVER_PID=$!
	disown $SERVER_PID
	wait $SERVER_WAIT_PID 2>/dev/null
	if [ $? -eq 0 ]; then
		# Something went wrong ...
		[ "$ACTION" = "start" ] && session_fail $uniqueid
		echo_x "NX> 1004 Error: Session did not start."
		echo_x "NX> 596 Session $ACTION failed."
		echo_x "NX> 999 Bye"
		# FIXME: Send node signal to terminate
		exit_proc 1
	fi
	# We have now an active reader
	nxnode_login_register_reader
}

# Session stage
while true; do
	echo_x -n "NX> 105 "
	unset CMD
	read CMD 2>/dev/null
	# FIXME?
	[ "$CMD" = "" ] && CMD="quit"
	# Logging
	case "$CMD" in
		startsession*|restoresession*|addmount*|addprinter*)
			echo_secure "$CMD"
			log_secure "4" "$CMD"
		;;
		*)
			echo "$CMD"
			log "4" "$CMD"
		;;
	esac
	case "$CMD" in
		quit|QUIT)
			echo_x "Quit"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		exit|EXIT)
			echo_x "Exit"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		bye|BYE)
			echo_x "Bye" 1>&2
			echo_x "NX> 999 Bye" 1>&2
			if [ "$ENCRYPTION" = "1" ]; then
				let PROXY_DISPLAY=$SESS_DISPLAY+4000
				$COMMAND_NETCAT $SERVER_HOST $PROXY_DISPLAY 2>/dev/null
				RC=$?
				# kill our parent sshd process
				kill $PPID
				exit_proc $RC
			else
				echo_x "NX> 1001 Bye."
			fi
		;;
		startsession*)
			server_startrestore_session "start"
		;;
		list*)
			server_get_params $CMD
			PARAMS=$SERVER_PARAMS
			CMDLINE=$PARAMS


			status=$(getparam status)

			if [ "$status" = "Suspended" -a -n "$(getparam screeninfo)" ]; then
				session_list_user_suspended "$USER" "Suspended" \
					"$(getparam screeninfo)" "$(getparam type)"
			elif [ "$status" = "Suspended,Running" -o "$status" = "Suspended" ]; then
				# disabled due to problems with 1.4.0-5 client
				#session_list_user_suspended "$USER" 'Suspended$|^status=Running$' "$(getparam geometry)" "$(getparam type)" | log_tee
				session_list_user_suspended "$USER" 'Suspended' \
					"$(getparam geometry)" "$(getparam type)"
			elif [ "$status" = "suspended,running" -o "$status" = "suspended" ]; then
				# since 1.5.0
				status=${status/,/|}; status=${status/suspended/Suspended};
				status=${status/running/Running};
				[ "$ENABLE_SHOW_RUNNING_SESSIONS" = "0" ] && status="Suspended"
				session_list_user_suspended "$USER" "$status" \
					"$(getparam geometry)" "$(getparam type)"
			elif [ "$(getparam type)" = "shadow" ]; then
				session_list_user_suspended ".*" "Suspended|Running" "" "shadow"
			else
				session_list_user "$USER" | log_tee
			fi
		;;
		suspend*)
			server_get_params $CMD
			PARAMS=$SERVER_PARAMS
			CMDLINE=$PARAMS
			if session_find_id_user "$(getparam sessionid)" "$USER"; then
				server_nxnode_start --suspend "$USER" "$PARAMS"
			fi
		;;
		terminate*)
			server_get_params $CMD
			PARAMS=$SERVER_PARAMS
			CMDLINE=$PARAMS
			if session_find_id_user "$(getparam sessionid)" "$USER"; then
				server_nxnode_start --terminate "$USER" "$PARAMS"
			fi
		;;
		restoresession*)
			server_startrestore_session "resume"
		;;
		attachsession*)
			server_startrestore_session "shadow"
		;;
		passwd)
			echo_x "NX> 113 Changing password of user '$USER'"
			echo_x -n "NX> 102 Current password:"
			read -r -s PASS
			ENC_PASS=$(passdb_get_crypt_pass "$PASS")
			REAL_PASS=$(passdb_get_pass "$USER")
			echo_x
			if [ "$ENC_PASS" = "$REAL_PASS" ]; then
				echo_x -n "NX> 102 Password:"
				read -r -s NEW_PASS1
				if [ ${#NEW_PASS1} -lt 5 ]; then
					echo_x "NX> 500 ERROR: incorrect password format, password must be long at least five characters"
					continue
				fi
				echo_x
				echo_x -n "NX> 102 Confirm password:"
				read -r -s NEW_PASS1
				echo_x
				if [ "$NEW_PASS1" = "$NEW_PASS2" ]; then
					ENC_PASS=$(passdb_get_crypt_pass "$NEW_PASS1")
					passdb_chpass "$USER" "$ENC_PASS"
					echo_x "NX> 114 Password of user '$USER' changed"
				else
					echo_x "NX> 537 ERROR: passwords do not match"
				fi
			else
				echo_x "NX> 500 ERROR: current password doesn't match"
			fi
		;;
		addmount*)
			server_get_params $CMD
			PARAMS="$SERVER_PARAMS"
			( server_nxnode_start --smbmount "$USER" "$PARAMS" >/dev/null 2>&1 ) &
		;;
		addprinter*)
			server_get_params $CMD
			PARAMS="$SERVER_PARAMS"
			( server_nxnode_start --addprinter "$USER" "$PARAMS" >/dev/null 2>&1 ) &
		;;
		*)
			# disabled for 1.4.0-5 snapshot client
			#echo_x "NX> 503 Error: undefined command: '$CMD'"
		;;
	esac
done

fi # SERVER_MODE == "1"

#
# End of Main nxserver <--> nxclient communication module
#

################### PACKAGE cmd.bm ############################

#
# library functions for nxserver-commandline cmds
#

# Policy: All functions and variables need to start with CMD_ / cmd_
# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN,
#			$NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
# Needed package: passdb
cmd_usage() {
	echo "NXSERVER - Version $NX_VERSION $NX_LICENSE" 1>&2
	echo "Usage: nxserver <option>" 1>&2

	if [ "$1" = "root" ]; then
		echo "--adduser <user>: Add a new user" 1>&2
		echo "--passwd <user>: Change password of <user>" 1>&2
		echo "--deluser <user>: Remove a user from nx" 1>&2
		echo "--listuser: List enabled users" 1>&2
		echo "" 1>&2
		echo "--start: Start the nx server" 1>&2
		echo "--stop: Stop the nx server" 1>&2
		echo "--status: Show status of nx server" 1>&2
		echo "--restart: Restart the nx server. (start,stop)" 1>&2
		echo "" 1>&2
		echo "--list [ user | sessionid ]: List running sessions of user or sessionid " 1>&2
		echo "--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history" 1>&2
		echo "--terminate <user | :display | sessionid>: Terminate the session pointed to by" 1>&2
		echo "       sessionid or display, or all sessions of the specified user." 1>&2
		echo "       Use * for all sessions." 1>&2
		echo "--force-terminate: Like terminate, but removes also session info." 1>&2
		echo "--suspend <user | :display | sessionid>: Suspend the session pointed to by" 1>&2
		echo "       sessionid or display, or all sessions of the specified user." 1>&2
		echo "       Use * for all sessions." 1>&2
		echo "--cleanup: Terminates all running sessions. Useful after power-outage."
		echo "" 1>&2
		echo "--broadcast <message>: Send a message to all users" 1>&2
		echo "--send <user | :display | sessionid> <message>: Send a message to the specified user or sessionid" 1>&2
	else
		echo "--passwd: Change password" 1>&2
	fi
	exit_proc 1
}


cmd_abort() {
	echo -e "NX> 500" "$@" 1>&2
	echo "NX> 999 Bye" 1>&2
	exit_proc 1
}

cmd_abort_success() {
	echo "NX> 500" "$@" 1>&2
	echo "NX> 999 Bye" 1>&2
	exit_proc 0
}

cmd_user_passwd() {
	echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
	echo "Sorry: Password changing for user is _not_ implemented, yet."
	echo "Please login to NX-Server to change password"
	echo "or ask your local system administrator."
	#echo "NX> 113 Changing password of user '$USER'"
	#echo "Old password:"
	#read -s OLDPASS
	#echo "New password:"
	#read -s NEWPASS1
	#echo "Repeat:"
	#read -s NEWPASS2
}

cmd_passwd() {
	CMD_CHUSER=$2
	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || \
		cmd_abort "Error: User $CMD_CHUSER not found in database."
	echo -n "New password: "
	read -r -s CMD_NEWPASS
	echo
	CMD_ENC_PASS=$(passdb_get_crypt_pass "$CMD_NEWPASS")
	passdb_chpass "$CMD_CHUSER" "$CMD_ENC_PASS"
	echo "Password changed."
}

cmd_checkpassdb() {
	if [ "$ENABLE_PASSDB_AUTHENTICATION" != "1" ]; then
		cmd_abort "Error: The passdb function is not activated in node.conf.\n\nMost probably your FreeNX setup will work out of the box without this\nfunctionality and you've been misleaded by an old tutorial or old\ndocumentation to do this step.\n\nIf however you really need this functionality, just set\nENABLE_PASSDB_AUTHENTICATION=\"1\" in node.conf.\n"
	fi
	return 0
}

cmd_adduser() {
	CMD_CHUSER=$2
	[ ${#CMD_CHUSER} -ge 32 ] && \
		cmd_abort "Error: User $CMD_CHUSER must be shorter than 32 characters."
	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords && \
		cmd_abort "Error: User $CMD_CHUSER already in database."
	getent passwd "$CMD_CHUSER" >/dev/null || \
		cmd_abort "Error: User $CMD_CHUSER not existing on local system. Can't add."
	passdb_add_user "$CMD_CHUSER"
}

cmd_deluser() {
	CMD_CHUSER=$2
	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || \
		cmd_abort "Error: User $CMD_CHUSER not found in database."
	passdb_remove_user "$CMD_CHUSER"
}

cmd_listuser() {
	echo "NX> 146 NX users list"
	echo
	echo "Username"
	echo "---------------"
	echo
	passdb_list_user
	echo
}

cmd_start() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && \
		cmd_abort_success "ERROR: Service already running"
	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled \
		$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
	echo "NX> 122 Service started"
}

cmd_stop() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || \
	cmd_abort_success "Service was already stopped"
	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS \
		$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
	echo "NX> 123 Service stopped"
}

cmd_status() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && \
		echo "NX> 110 NX Server is running"
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || \
		echo "NX> 110 NX Server is stopped"
}

cmd_restart() { cmd_stop; cmd_start; }

cmd_parse_2_params()
{
	local CMD_APARAMS;
	if [ ${#1} -eq 32 ]; then
		CMD_APARAMS="sessionid=sessionId{$1}"
	elif [ "$1" != "" ]; then
		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
		CMD_APARAMS="user=$1"
	fi
	echo "$CMD_APARAMS"
}

cmd_parse_3_params()
{
	local CMD_PARAMS;
	if [ ${#1} -eq 32 ]; then
		CMD_PARAMS=$(session_find_id $1)
		[ -n "$CMD_PARAMS" ] || cmd_abort "Error: Session $1 could not be found."
	elif [ "${1:0:1}" = ":" ]; then
		CMD_PARAMS=$(session_find_display "${1:1}")
		[ -n "$CMD_PARAMS" ] || cmd_abort "Error: No running sessions found for display $1."
	elif [ "$1" = "*" ]; then
		CMD_PARAMS=$(session_find_all)
		[ -n "$CMD_PARAMS" ] || cmd_abort "Error: No running sessions found."
	elif [ "$1" != "" ]; then
		CMD_PARAMS=$(session_find_user "$1")
		[ -n "$CMD_PARAMS" ] || cmd_abort "Error: No running sessions found for user $1."
	else
		cmd_abort "Error: Not enough parameters."
	fi
	echo "$CMD_PARAMS"
}

cmd_list_suspended() {
	local CMD_PARAMS=$(cmd_parse_2_params "$2")
	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit_proc 1
	case $CMD_PARAMS in
		user=*)
			session_list_user_suspended $2 "Suspended"
		;;
	esac
}
cmd_list() {
	local CMD_PARAMS=$(cmd_parse_2_params "$2")
	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit_proc 1
	case $CMD_PARAMS in
		user=*)
			session_list_user $2
		;;
		sessionid=*)
			session_list $2
		;;
		*)
			session_list_all
		;;
	esac
}

cmd_history_clear() {
	q_dbe "DELETE FROM sess WHERE status IN ('Finished','Failed');"
}

cmd_history() {
	local CMD_PARAMS user="" sessid=""
	if [ "$2" = "clear" ]; then cmd_history_clear; return; fi
	CMD_PARAMS=$(cmd_parse_2_params "$2")
	case $CMD_PARAMS in
		user=*)
			user="$2"
		;;
		sessionid=*)
			sessid="$2"
		;;
	esac
	session_history "$user" "$sessid"
}

cmd_execute() {
	local cmd_host="$1" cmd_user="$2" cmd_cmd="$3"
	if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
		sh -c "$cmd_cmd"
	elif [ "$cmd_host" = "127.0.0.1" -o "$cmd_host" = "localhost" ]; then
		/bin/su - "$cmd_user" -c "$cmd_cmd"
	else
		ssh "$cmd_host" su - "$cmd_user" -c "'$cmd_cmd'"
	fi
}

cmd_terminate_or_send() {
	local CMD="$1" CMD_PARAMS cmd_sessionid cmd_display cmd_user cmd_type \
		cmd_status cmd_host;
	if [ "$CMD" = "--broadcast" ]; then
		CMD_PARAMS=$(session_find_all)
		[ -z "$CMD_PARAMS" ] && cmd_abort "Error: No running session could be found."
	else
		CMD_PARAMS=$(cmd_parse_3_params "$2")
		[ -z "$CMD_PARAMS" ] && exit_proc 1
		shift
	fi
	shift

	while read CMDLINE; do
		[ -z "$CMDLINE" ] && continue
			cmd_sessionid=$(getparam sessionId)
			cmd_display=$(getparam display)
			cmd_user=$(getparam userName)
			cmd_type=$(getparam type)
			cmd_status=$(getparam status)
			cmd_host=$(getparam host)

			# is it a "good" session?
			case "$CMD" in
			--suspend)
				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
				then
					echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --suspend"
				fi
			;;
			--terminate)
				echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --terminate"
			;;
			--force-terminate)
				echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --terminate"
				session_close $cmd_sessionid
			;;
			--send|--broadcast)
				# is it a "good" session?
				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
				then
					cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxdialog --dialog ok --caption \"NX Administrator Message\" --message \"$@\" -display \":$cmd_display\" &"
				fi
			esac
	done <<< "$CMD_PARAMS"
}

if [ "$NX_LOG_LEVEL" -ge "1" -a ! -f "$NX_LOGFILE" ]; then
	touch "$NX_LOGFILE" >/dev/null 2>&1
fi
open_dbe
isdbs=""; [ -f $sess_bd ] && isdbs="1"
attach_db $sess_bd
init_sess_db
[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
	-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs
if [ "$UID" -eq "0" ]; then
	chown nx "$NX_LOGFILE" >/dev/null 2>&1; chmod 660 "$NX_LOGFILE"
	chown nx "$sess_bd" >/dev/null 2>&1; chmod 660 "$sess_bd"
fi

#
# normal user available functions
if [ $UID -ne 0 -a "$ENABLE_USERMODE_AUTHENTICATION" != "1" ]; then
	[ "$1" = "--agent" ] && exec $PATH_BIN/nxnode "$@"
	[ "$1" != "--passwd" ] && cmd_usage
	cmd_user_passwd
	exit_proc 0
fi

#
# root mode available functions
[ $# -lt 1 ] && cmd_usage "root"
[ "$1" = "--help" ] && cmd_usage "root"

if [ "$1" = "--version" ]; then
  echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
  exit_proc 0
fi

CMD=$1
echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
case $CMD in
	#
	# User functions ...
	--passwd)
		cmd_checkpassdb
		cmd_passwd "$@"
	;;
	--adduser|--useradd)
		cmd_checkpassdb
		cmd_adduser "$@"
	;;
	--deluser|--userdel)
		cmd_checkpassdb
		cmd_deluser "$@"
	;;
	--listuser|--userlist)
		cmd_checkpassdb
		cmd_listuser
	;;
	--start)
		cmd_start
	;;
	--stop)
		cmd_stop
	;;
	--status)
		cmd_status
	;;
	--restart)
		cmd_restart
	;;
	--list)
		cmd_list "$@"
	;;
	--list-suspended)
		cmd_list_suspended "$@"
	;;
	--history)
		cmd_history "$@"
	;;
	--terminate|--suspend|--force-terminate)
		cmd_terminate_or_send "$@"
	;;
	--cleanup)
		cmd_terminate_or_send "--force-terminate" "*"
	;;
	--send|--broadcast)
		cmd_terminate_or_send "$@"
	;;
	*)
		cmd_abort "Error: Function $CMD not implemented yet."
esac
echo "NX> 999 Bye"
