#!/bin/bash

# Free implementation of nxserver components
#
# To use nxserver add the user "nx"
# and use nxserver as default shell.
#
# Also make sure that hostkey based authentification works.
#
# Copyright (c) 2004 by Fabian Franz <FreeNX@fabian-franz.de>.
#           (c) 2008-19 by Dmitry Borisov <i@dimbor.ru>
#
# License: GNU GPL, version 2
#
# SVN: $Id: nxserver 612 2008-08-25 03:28:15Z fabianx $
#

shopt -s extglob

# Read the config file
# dimbor: it's temporary
. /usr/bin/nxloadconfig --userconf

. $SHARED_CONFS/nxfuncs

############### PACKAGE log.bm #######################
#
# Library of log functions (outsource)
#

# Loglevels:
# 1: Errors
# 2: Warnings
# 3: Important information
# 4: Server - Client communication
# 5: Information
# 6: Debugging information
# 7: stderror-channel of some applications

log() {
#args: <loglevel> <logstr>
	[ "$NX_LOG_LEVEL" -ge "$1" ] && shift && {
		[ -n "$1" ] &&
			echo -n "[$(date "+%d.%m %T.%3N")] " >> "$NX_LOGFILE"
		echo $@ >> "$NX_LOGFILE"
	}
}

# Log in a way that is secure for passwords / cookies / ...
echo_secure() {
	[ -n "$1" ] &&
		echo -n "[$(date "+%d.%m %T.%3N")] " >> "$NX_LOGFILE"
	local  res=${@//&password=*&/&password=****&}
	res=${res//--cookie=\"+([^\"])\"/--cookie=\"****\"}
	res=${res//--password=\"+([^\"])\"/--password=\"****\"}
	echo "$res"
}

log_secure() {
#args: <loglevel> <logstr>
	if [ "$NX_LOG_SECURE" = "0" ]; then log $@
	elif [ "$NX_LOG_LEVEL" -ge "$1" ]; then
		shift && echo_secure $@ >> "$NX_LOGFILE"
	fi
}

log_tee() {
	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
	[ "$NX_LOG_LEVEL" -ge "4" -a -w "$NX_LOGFILE" ] || exec cat -
}

log_error() {
	[ "$NX_LOG_LEVEL" -ge "7" -a -w "$NX_LOGFILE" ] && exec tee -a "$NX_LOGFILE"
	[ "$NX_LOG_LEVEL" -ge "7" -a -w "$NX_LOGFILE" ] || exec cat -
}

echo_x() { log "4" "$@"; echo "$@"; }

############### PACKAGE passdb.bm #######################
#
# Library of passdb functions (outsource)
#

# Policy: Variable and function names _must_ start with passdb_ / PASSDB_

# Needed global vars: $NX_ETC_DIR, $PATH_BIN

# Needed nonstd functions: md5sum

passdb_get_crypt_pass() { echo "$@" | $COMMAND_MD5SUM | cut -d" " -f1; }

passdb_get_pass() {
	PASSDB_CHUSER="$1"
	PASSDB_PASS=$(egrep "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null | cut -d":" -f2)
	if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" ]; then
		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null && echo $PASSDB_PASS
		egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null || echo "NOT_VALID"
	else
		echo "NOT_VALID"
	fi
}

passdb_chpass() {
	PASSDB_CHUSER="$1"; PASSDB_ENC_PASS="$2"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	sed -i -e "s/$PASSDB_CHUSER:.*/$PASSDB_CHUSER:$PASSDB_ENC_PASS/g" $NX_ETC_DIR/passwords
}

passdb_user_exists() {
	PASSDB_CHUSER="$1"
	egrep -q "^$PASSDB_CHUSER:" $NX_ETC_DIR/passwords 2>/dev/null
}


passdb_remove_user() {
	PASSDB_CHUSER="$1"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	sed -i -e "/$PASSDB_CHUSER:/d" $NX_ETC_DIR/passwords
}

passdb_add_user() {
	PASSDB_CHUSER="$1"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	echo "$PASSDB_CHUSER:*" >> $NX_ETC_DIR/passwords
	# deactivated to avoid problems with comm-server
	su - $PASSDB_CHUSER -c "$PATH_BIN/nxnode --setkey"
}

passdb_list_user() {
	cat $NX_ETC_DIR/passwords | cut -d":" -f1
}

#
# End of passdb Library
#

############### PACKAGE session.bm #######################
#
# Library of session management functions
#

# Needed global vars: $NX_SESS_DIR

# =================== sqlite3 stuff =====================

sess_bd="$NX_SESS_DIR/sessions.sq3"
sqcols_sess="sessionName, display, status, startTime, foreignAddress,\
 sessionRootlessMode, type, sessionId, creationTime, userName,\
 serverPid, screeninfo, geometry, host, shadowcookie, endTime"
sqcols_sess_c=16

migrate_old_conf_dirs() {
	local txt fn fields vals field val;
   for fn in $NX_SESS_DIR/{closed,failed}/*; do
		txt=$(< $fn); txt=${txt//=/ }; fields=""; vals="";
		while read field val; do
			fields+="${fields:+,}$field"; vals+="${vals:+,}'$val'";
		done <<< "$txt"
		q_dbe "INSERT INTO sess($fields) VALUES($vals);"
	done >/dev/null 2>&1
	log 1 "Info: Sessions db migrated to sqlite3 format."
	rm -rf $NX_SESS_DIR/{closed,failed,running} >/dev/null 2>&1
}

init_sess_db() {
	local sess_cols="sessionId TEXT PRIMARY KEY, sessionName TEXT,\
 display TEXT, status TEXT, startTime INT, foreignAddress TEXT,\
 sessionRootlessMode INT, type TEXT, creationTime INT, userName TEXT,\
 serverPid TEXT, screeninfo TEXT, geometry TEXT, host TEXT,\
 shadowcookie TEXT, endTime INT"
	local qstr="CREATE TABLE IF NOT EXISTS sessions.sess($sess_cols);"
	qstr+="CREATE INDEX IF NOT EXISTS sessions.idx_statusUserName ON\
 sess(status,userName);"
   q_dbe "$qstr"
}

exit_proc() {
	close_dbe; exit $1;
}

#-------------------------------------------------------------------

session_list() {
#params: sessId  ["format_times"]
#if you need to humane output put something in $2
	local qc fls res r2="";
	[ -n "$2" ] && { fls="sessionName, display, status,\
 datetime(startTime,'unixepoch','localtime') AS startTime,\
 foreignAddress, sessionRootlessMode, type, sessionId,\
 datetime(creationTime,'unixepoch','localtime') AS creationTime, userName,\
 serverPid, screeninfo, geometry, host, shadowcookie,\
 datetime(endTime,'unixepoch','localtime') AS endTime";
	} || { # original order of fields
		fls=$sqcols_sess;
	}
   q_dbe ".mode line sess"
	res=$(qa_dbe $sqcols_sess_c "SELECT $fls FROM sess WHERE sessionId='$1' LIMIT 1;")
	[ -n "$2" ] && { 	echo "$res"; return; }
	local line k v;
	while read line; do
		k=$(trim "$(cutfn "$line" "=" 0)"); v=$(trim "$(cutfn "$line" "=" 1)") #"
		r2+="$k=$v"$'\n'
	done <<< "$res"
	echo -n "$r2"
}

session_find_cmdstrs() {
#params: [sessid] [user] [display] [status="Running|Suspended"]
#ret: sessions command strings delimited by \n
	local st wstr qc res;
	st="Running|Suspended"; [ -n "$4" ] && st="$4"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	[ -n "$1" ] && wstr+=" AND $(str_eq_cond "sessionId" "$1")"
	[ -n "$2" -a "$2" != "all" -a "$2" != ".*" ] && \
		wstr+=" AND $(str_eq_cond "userName" "$2")"
	[ -n "$3" ] && wstr+=" AND $(str_eq_cond "display" "$3")"
   q_dbe ".mode tabs sess"
	qc=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;"); #"
	[ "$qc" -gt "0" 2>/dev/null ] || return
	qc=$((qc*sqcols_sess_c))
   q_dbe ".mode line sess"
	res=$(qa_dbe $qc "SELECT $sqcols_sess FROM sess $wstr ORDER BY startTime DESC;")
	qtxt2cmdstrs "$res"
}

# Find all running session-filenames
session_find_all() { session_find_cmdstrs; }

# Find all running sessions of a id
session_find_id() { session_find_cmdstrs "$1"; }

# Finds out if a session belongs to a user
session_find_user() { session_find_cmdstrs "" "$1"; }

# Find all running sessions of a display
session_find_display() { session_find_cmdstrs "" "" "$1"; }

# Finds out if a session belongs to a user
session_find_id_user() {
#params: sessid [user]
	local wstr c;
	wstr="WHERE sessionId='$1' AND status IN ('Running', 'Suspended')"
	[ -n "$2" -a "$2" != "all" -a "$2" != ".*" ] && \
		wstr+=" AND $(str_eq_cond "userName" "$2")"
   q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	[ "$c" -gt "0" 2>/dev/null ] || return 1
	return 0
}

# session_get <uniqueid>
session_get()  { session_find_cmdstrs "$1"; }

# Get the first session, which can be resumed
session_get_user_suspended() {
#params: user status
#ret: sessionId line[s] or empty
	local wstr r a;
	wstr="WHERE status='$2'AND username='$1'"
   q_dbe ".mode tabs sess"
	r=$(qa_dbe "SELECT count(sessionId), sessionId FROM sess $wstr ORDER BY startTime DESC LIMIT 1;") #"
	a=($r); ((${#a[@]}==2)) && echo "${a[1]}"
}

# Count all sessions of a user
# and save it in SESSION_COUNT and SESSION_COUNT_USER

session_get_user_suspended() {
#params: user status
#ret: sessionId line[s] or empty
	local wstr r a;
	wstr="WHERE status='$2'AND username='$1'"
   q_dbe ".mode tabs sess"
	r=$(qa_dbe "SELECT count(sessionId), sessionId FROM sess $wstr ORDER BY startTime DESC LIMIT 1;") #"
	a=($r); ((${#a[@]}==2)) && echo "${a[1]}"
}

session_count_user() {
#params: userName [status]
	local st wstr r u="" sc="" uc
	SESSION_COUNT=0; SESSION_COUNT_USER=0
	st="Running|Suspended"; [ -n "$2" ] && st="$2"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	q_dbe ".mode tabs sess"
	if [ "$1" = ".*" -o "$1" = "all" ]; then
		SESSION_COUNT=$(qa_dbe "SELECT count(*) FROM sess $wstr;") #"
		SESSION_COUNT_USER=$SESSION_COUNT
		return 0
	fi
	uc=$(qa_dbe "SELECT count(DISTINCT userName) FROM sess $wstr LIMIT 1;") #"
	((uc==0)) && return;
	r=$(qa_dbe $uc "SELECT userName,count(*) FROM sess $wstr GROUP BY userName;") #"
	while read u sc; do
		[ -z "$sc" ] && continue
		let SESSION_COUNT=SESSION_COUNT+$sc
		[ "$u" = "$1" ] && SESSION_COUNT_USER=$sc
	done <<< "$r"
	return 0
}

_session_list_user_suspended() {
	local cmdstrs pattern geom depth render udepth urender mode;
	local options available uniqueid geo2 displays;
	echo "NX> 127 Sessions list of user '$1' for reconnect:"
	echo
	if [ -z "$4" ]
	then
		echo "Display Type             Session ID                       Options  Depth Screensize     Available Session Name"
		echo "------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------"
	else
		echo "Display Type             Session ID                       Options  Depth Screen         Status      Session Name"
		echo "------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------"
	fi
	cmdstrs=$(session_find_cmdstrs "" "$1" "" "$2")
	while read CMDLINE; do
		[ -z "$CMDLINE" ] && continue
		if [ "$4" = "shadow" -a "$(getparam userName)" != "$USER" ]; then
			[ -z "$(getparam shadowcookie)" ] && continue
			if [ -x "$COMMAND_NXSHADOWACL" ]; then
				$COMMAND_NXSHADOWACL "$(getparam userName)" "$USER" || continue
			fi
		fi

		pattern='^([0-9]*x[0-9]*)x([0-9]*)\+?([^+]*)'
		[[ $(getparam screeninfo) =~ $pattern ]]
		geom=${BASH_REMATCH[1]}; depth=${BASH_REMATCH[2]}; render=${BASH_REMATCH[3]}
		[[ $3 =~ $pattern ]]
		udepth=${BASH_REMATCH[2]}; urender=${BASH_REMATCH[3]}
		mode="D"; [ "$(getparam sessionRootlessMode)" = "1" ] && mode="-"
		options="-"; stringinstring "fullscreen" "$3" && options="F"
		[ "$(getparam geometry)" = "fullscreen" ] || options="-"
		[ "$urender" = "render" ] && options="${options}R${mode}--PSA"
		[ "$urender" = "render" ] || options="${options}-${mode}--PSA"
		[ "$udepth" = "$depth" -a "$urender" = "$render" ] && available=$(getparam status)
		# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
		if [ -z "$4" -a "$available" != "N/A" ]; then
			available="Yes"
		fi
		# We automatically offer VNC shadowed sessions for "remote" support
		if [ "$4" = "vnc" -a "$ENABLE_MIRROR_VIA_VNC" = "1" ] \
					&& stringinstring "unix-" "$(getparam type)"; then
			available=$(getparam status)
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "vnc-shadowed" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName) (Mirrored)"
		elif [ "$4" = "shadow" ]; then
			available=$(getparam status)
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "$(getparam type)" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName) ($(getparam userName)) (Shadowed)"
		else
			# only unix-* sessions can be resumed, but other session types can still be terminated
			stringinstring "unix-" "$4" || available="N/A"
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "$(getparam type)" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName)"
		fi
	done <<< "$cmdstrs"

	if [ "$4" = "vnc" -o "$4" = "shadow" -a "$ENABLE_DESKTOP_SHARING" = "1" ]; then
		export DESKTOP_SHARING_IDS=""
		geo2=$(rematchfn '^([[:digit:]]+x[[:digit:]]+)' $3) #'
		displays=$(LC_ALL=C netstat -ln --protocol=unix)
		displays=$(rematchfn 'X11-unix/X([0-9]+)' "$displays" "all")  #'
		for i in $displays; do
			uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
			uniqueid=${uniqueid%% *}; uniqueid=${uniqueid^^}
			DESKTOP_SHARING_IDS="$DESKTOP_SHARING_IDS $uniqueid=$i"
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$i" "Local" "$uniqueid" "--------" "$udepth" "$geo2" "Running" "X$i (Local)"
		done
	fi
	echo ""
	echo ""

	session_count_user "$1"
	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" -o \
			"$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]; then
		echo "NX> 147 Server capacity: reached for user: $1"
	else
		echo "NX> 148 Server capacity: not reached for user: $1"
	fi
}

session_list_user_suspended() {
	local SESSION_LIST_CACHE_DATA=$(_session_list_user_suspended "$@")
	echo "$SESSION_LIST_CACHE_DATA" | log_tee
}

session_list_user() {
#params: userName [status="Running|Suspended"]
	local st wstr c
	echo -n "NX> 127 Sessions list"
	if [ -n "$1" -a "$1" != "all" ]; then echo " of user '$1'"
	else echo ":"
	fi
	echo
	echo "Server	 Display Username		Remote IP	   Session ID"
	echo "------ ------- --------------- --------------- --------------------------------"
	st="Running|Suspended"; [ -n "$2" ] && st="$2"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	[ -n "$1" -a "$1" != "all" ] && wstr+=" AND $(str_eq_cond "userName" "$1")"
	q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	((c==0)) && return;
	qa_dbe $c "SELECT host,display,userName,foreignAddress,sessionId\
 FROM sess $wstr ORDER BY startTime DESC;" # ! check order !
}

session_history() {
#params: userName sessionId
	local wstr="" c;
	echo "NX> 127 Session list:"
	echo
	echo "Display Username		Remote IP	   Session ID					   Date				Status"
	echo "------- --------------- --------------- -------------------------------- ------------------- -----------"
	[ -n "$1" -a "$1" != "all" ] && wstr="$(str_eq_cond "userName" "$1")"
	[ -n "$wstr" -a -n "$2" ] && wstr+=" AND "
	[ -n "$2" ] && wstr+=" sessionId='$2'"
	[ -n "$wstr" ] && wstr="WHERE $wstr"
	q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	((c==0)) && return;
	qa_dbe $c "SELECT display,userName,foreignAddress,sessionId,\
 datetime(startTime,'unixepoch','localtime'),status\
 FROM sess $wstr ORDER BY startTime;" # ! check order !
}

# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
session_cleanup() {
	local checkTime st wstr;
	[ "$SESSION_HISTORY" -gt "-1" ] || return
	let checkTime=$(date +%s)-$SESSION_HISTORY
	st="Finished|Failed";
	wstr="WHERE $(str_eq_cond "status" "$st") AND startTime < $checkTime"
	q_dbe "DELETE FROM sess $wstr;"
}

session_list_all() { session_list_user "all"; }

session_add() {
#params: <session_id> <options>
	local t k v keys="" vals="";
	shift #sessid present separately for compat only
	t="$@"; t=${t//&/$'\n'}; t=${t//=/ }
	while read k v; do
		keys+="${keys:+,}$k"; vals+="${vals:+,}'$v'"
	done <<< "$t"
	q_dbe "INSERT INTO sess($keys) VALUES($vals);"
}

session_change() {
# <session_id> <parameter> <new_value> [<parameter> <new_value>]...
	local setls="" ssid="$1"; shift
	while [ -n "$1" -a  -n "$2" ]; do
		setls+="${setls:+,}$1='$2'"; shift; shift
	done
	q_dbe "UPDATE sess SET $setls WHERE sessionId='$ssid';"
}

# session_set_status <session_id> <new status>
session_set_status() { session_change "$1" "status" "$2"; }

# session_running <session_id> (? now dublicated session_find_id_user ?)
# return: true if running, false if not
session_running() { session_find_id_user "$1"; }

session_close() {
#param: <session_id>
	if [ "$SESSION_HISTORY" = "0" ] ; then
		q_dbe "DELETE FROM sess WHERE sessionId='$1';"
	else
		session_change "$1" "status" "Finished" "endTime" "$(date +%s)"
	fi
}

session_fail() {
#param: <session_id>
	if [ "$SESSION_HISTORY" = "0" ] ; then
		q_dbe "DELETE FROM sess WHERE sessionId='$1';"
	else
		session_change "$1" "status" "Failed" "endTime" "$(date +%s)"
	fi
}

session_suspend() {
#param: <session_id>
	session_change "$1" "status" "Suspended" "foreignAddress" "-"
}

#
# end of library
#


#
# Main nxserver <-> nxclient communication module
#

# config variables in use:
# NX_VERSION NX_LICENSE SERVER_NAME SSHD_PORT NX_LOGFILE
# COMMAND_SSH COMMAND_NETCAT
# ENABLE_LOG_FAILED_LOGINS ENABLE_USER_DB ENABLE_AUTORECONNECT_BEFORE_140
# ENABLE_PASSDB_AUTHENTICATION ENABLE_SSH_AUTHENTICATION
# ENABLE_SU_AUTHENTICATION ENABLE_USERMODE_AUTHENTICATION
# LOAD_BALANCE_SERVERS

# lost? conf vars:
# COMMAND_GUEST_LOGIN ENABLE_GUEST_LOGIN

# declare global variables:
declare -g CMD CMDLINE SERVER_PARAMS PROTO LOGIN_SUCCESS LOGIN_METHOD
declare -g SERVER_MODE NX_SESS_DIR PREFERRED_HOST
declare -g USER2 ENCRYPTION PROXY_DISPLAY SESS_DISPLAY SERVER_HOST RC

# env variables?
# NX_USERMODE USER

# do not run in server mode loop
SERVER_MODE="0"

# For users nxfree and nx run in SERVER MODE
[ "$USER" = "nx" ] && SERVER_MODE="1"

# We can override usermode via environment var
[ "$NX_USERMODE" = "1" ] && ENABLE_USERMODE_AUTHENTICATION="1"

# When usermode is 1, we only run in server loop
# if nxserver was run without any arguments or just with -c nxserver.
if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
	# do not run in server mode loop regardless of username
	SERVER_MODE="0"
	[ -z "$*" -o "$*" = "-c $PATH_BIN/nxserver" ] && SERVER_MODE="1"

	# Reread the config files (so that $USER.node.conf get sourced)
	. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf

	# We might need to reactivate this now
	ENABLE_USERMODE_AUTHENTICATION="1"
	# export the necessary variables
	export NX_SESS_DIR="$USER_FAKE_HOME/.nx/db/"
	export NX_LOGFILE="$USER_FAKE_HOME/.nx/temp/nxserver.log"
	mkdir -p $(dirname $NX_LOGFILE)
	open_dbe
	isdbs=""; [ -f $sess_bd ] && isdbs="1"
	attach_db $sess_bd
	init_sess_db
	[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
		-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs

	# we are logged in already
	LOGIN_SUCCESS="1"
	LOGIN_METHOD="USERMODE"

	# we do not use loadbalancing mode for usermode
	LOAD_BALANCE_SERVERS=""
fi

if [ "$SERVER_MODE" = "1" ]; then

nxnode_login() {
	PASS="$1"; shift
	NXNODE_TOSEND="$NXNODE_TOSEND" echo $PASS | $PATH_BIN/nxnode-login "$@"
}

nxnode_login_register_reader() {
# Register a reader
	NXNODE_READER="1"
}

# Start!
open_dbe
isdbs=""; [ -f $sess_bd ] && isdbs="1"
attach_db $sess_bd
init_sess_db
[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
	-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs

log 3 "-- NX SERVER START: $@ - ORIG_COMMAND=$SSH_ORIGINAL_COMMAND"

# Get the hostname out of SSH_ORIGINAL_COMMAND
PREFERRED_HOST=$(rematchfn "host=([^&]*)" "$SSH_ORIGINAL_COMMAND") #"

if [ "$NX_USERMODE" = "1" ]; then
	log 3 "Info: Usermode authentication: Logged in as $USER."
else
	echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
	# Login stage
	while true; do
		echo_x -n "NX> 105 "
		read CMD
		[ "$CMD" = "" ] && CMD="quit" # FIXME?
		echo_x "$CMD"
		case "$CMD" in
			quit|QUIT)
				echo_x "Quit"; echo_x "NX> 999 Bye"; exit_proc 0;
			;;
			exit|EXIT)
				echo_x "Exit"; echo_x "NX> 999 Bye"; exit_proc 0;
			;;
			bye|BYE)
				echo_x "Bye"; 	echo_x "NX> 999 Bye"; exit_proc 0;
			;;
			hello*|HELLO*)
				PROTO=$(rematchfn 'Version ([[:digit:][:punct:]]+)' "$CMD") #'
				echo_x "NX> 134 Accepted protocol: $PROTO"
				if [ "$PROTO" = "1.3.0" -o "$PROTO" = "1.3.2" ]; then
					[ "$ENABLE_AUTORECONNECT_BEFORE_140" = "1" ] && \
						ENABLE_AUTORECONNECT="1"
				fi
			;;
			"set auth_mode*"|"SET AUTH_MODE*")
				if [ "$CMD" = "set auth_mode password" -o \
					"$CMD" = "SET AUTH_MODE PASSWORD" ]; then
					echo_x "Set auth_mode: password"
				else
					echo_x "NX> 500 ERROR: unknown auth mode ''"
				fi
			;;
			login|LOGIN)
				LOGIN_SUCCESS="0"
				echo_x -n "NX> 101 User: "; read USER2; echo_x $USER2;
				echo_x -n "NX> 102 Password: ";
				old_ifs="$IFS"; export IFS=$'\n';
				read -r -s PASS; export IFS="$old_ifs"; echo_x ""
				log 6 -n "Info: Auth method: "
				# USER already logged in?
				if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
					LOGIN_SUCCESS="1"
					# we have read the user config already above,
					# so we don't get any new information here
					break
				fi
				USER=$USER2

				# Guest authentication
				if [ "$USER" = "NX guest user" ]; then
					if [ "$ENABLE_GUEST_LOGIN" != "1" -o \
								! -x "$COMMAND_GUEST_LOGIN" ]; then
						if [ "$ENABLE_GUEST_LOGIN" != "1" ]; then
							echo_x "NX> 404 ERROR: guest authentication not enabled"
						else
							echo_x "NX> 404 ERROR: $COMMAND_GUEST_LOGIN not correct"
						fi
						echo_x "NX> 999 Bye"
						if [ "$ENABLE_LOG_FAILED_LOGINS" = "1" ]; then
							logger -t nxserver -i -p auth.info \
								"($(whoami)) Failed login for user=$USER from IP=$(echo $SSH_CLIENT | awk '{print $1}')"
						fi
						exit_proc 1
					fi
					log 6 -n "guest "
					nxnode_login "" -- guest "" "" "$COMMAND_GUEST_LOGIN" \
						--check 2>&1 >/dev/null
					if [ $? -eq 0 ]; then LOGIN_SUCCESS="1"; LOGIN_METHOD="GUEST"; fi
				fi

				# PASSDB based auth
				if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" -a \
					"$LOGIN_SUCCESS" = "0" ]; then
					log 6 -n "passdb "
					if [ $(passdb_get_crypt_pass "$PASS") = \
						$(passdb_get_pass "$USER") ]; then
						LOGIN_SUCCESS="1"; LOGIN_METHOD="PASSDB"
					fi
				fi

				# SSH based auth
				if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$LOGIN_SUCCESS" = "0" ]; then
					log 6 -n "ssh "; export COMMAND_SSH;
					nxnode_login "$PASS" -- ssh "$USER" "$SSHD_PORT" \
						"$PATH_BIN/nxnode" --check 2>&1 >/dev/null
					if [ $? -eq 0 ]; then LOGIN_SUCCESS="1"; LOGIN_METHOD="SSH"; fi
				fi

				# SU based auth
				if [ "$ENABLE_SU_AUTHENTICATION" = "1" -a \
						"$LOGIN_SUCCESS" = "0" ]; then
					log 6 -n "su "
					# experimental don't start nxnode --check
					LOGIN_SUCCESS="1"; LOGIN_METHOD="SU";
					#nxnode_login "$PASS" -- su "$USER" "" \
					#	"$PATH_BIN/nxnode" --check 2>&1 >/dev/null
					#if [ $? -eq 0 ]; then LOGIN_SUCCESS="1"; LOGIN_METHOD="SU"; fi
				fi

				# Check if user in passdb
				if [ "$ENABLE_USER_DB" = "1" ]; then
					log 6 "userdb check"
					passdb_user_exists "$USER" || LOGIN_SUCCESS="0"
				fi
				log 6 ""

				if [ "$LOGIN_SUCCESS" = "1" ]; then
					# Reread the config files (so that $USER.node.conf get sourced)
					# dimbor: it's temporary
					. /usr/bin/nxloadconfig --userconf
					break
				else
					echo_x "NX> 404 ERROR: wrong password or login"
					echo_x "NX> 999 Bye"
					if [ "$ENABLE_LOG_FAILED_LOGINS" = "1" ]; then
						logger -t nxserver -i -p auth.info \
						"($(whoami)) Failed login for user=$USER from IP=$(echo $SSH_CLIENT | awk '{print $1}')"
					fi
					exit_proc 1
				fi
			;;
		esac
	done
fi
echo_x "NX> 103 Welcome to: $SERVER_NAME user: $USER"

# remove old session infos from history
session_cleanup

#
# call it with: server_get_params $CMD # no ""!
#
server_get_params() {
	shift; SERVER_PARAMS=" $@"; SERVER_PARAMS=${SERVER_PARAMS// --/\&};
	SERVER_PARAMS=${SERVER_PARAMS//\"/};
	if [ "$SERVER_PARAMS" = "" ]; then
		echo_x -n "NX> 106 Parameters: "
		read SERVER_PARAMS2
		SERVER_PARAMS=${SERVER_PARAMS2//%2B/+}
		echo_x
	fi
	SERVER_PARAMS=${SERVER_PARAMS//%20/ };
}

server_nxnode_start() {
	CMD="$1"; USER="$2"; shift; shift;

	# Find NODE_HOSTNAME
	NODE_HOSTNAME=""
	CMDLINE="$@"
	uniqueid=$(getparam uniqueid)
	[ -z "$uniqueid" ] && uniqueid=$(getparam sessionid)
	[ -z "$uniqueid" ] && uniqueid=$(getparam session_id)
	CMDLINE=$(session_get "$uniqueid")
	NODE_HOSTNAME="$(getparam host)"
	[ -z "$NODE_HOSTNAME" ] && NODE_HOSTNAME="127.0.0.1"
	export NODE_HOSTNAME
	# Use nxnode-login?
	if [ "$LOGIN_METHOD" = "GUEST" ]; then
		NXNODE_TOSEND="$@" nxnode_login "" -- \
			guest "" "" "$COMMAND_GUEST_LOGIN" "$CMD" 2>&1 | log_tee
	elif [ "$LOGIN_METHOD" = "SSH" ]; then
	    export COMMAND_SSH
	    NXNODE_TOSEND="$@" nxnode_login "$PASS" -- \
			ssh "$USER" "$SSHD_PORT" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
	elif [ "$LOGIN_METHOD" = "SU" ]; then
	    NXNODE_TOSEND="$@" nxnode_login "$PASS" -- \
			su "$USER" "" "$PATH_BIN/nxnode" "$CMD" 2>&1 | log_tee
	elif [ "$LOGIN_METHOD" = "USERMODE" ]; then
	    # we need to unset SSH_* variables so that nxnode
	    # chooses the right accept= value.
	    unset SSH_CLIENT SSH_CLIENT2
	    echo "$@" | $PATH_BIN/nxnode "$CMD" 2>&1 | log_tee
	else
	    echo "$@" | $COMMAND_SSH -l "$USER" "$NODE_HOSTNAME" -p $SSHD_PORT \
			-x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' \
			-o 'RSAAuthentication yes' -o 'RhostsAuthentication no' \
			-o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' \
			-o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$CMD" | log_tee
	fi
}

server_add_usession() {
	[ "$ENABLE_USESSION" = "1" ] || return
	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -a $USER 2>&1 | \
		log_error
}

server_remove_usession() {
	[ "$ENABLE_USESSION" = "1" ] || return
	$COMMAND_SESSREG -l ":$SESS_DISPLAY" -h "$USERIP" -d $USER 2>&1 | \
		log_error
}

server_nxnode_echo() {
	log 6 "server_nxnode_echo: $@"
	[ "$SERVER_CHANNEL" = "1" ] && echo "$@"
	[ "$SERVER_CHANNEL" = "2" ] && echo "$@" >&2
}

server_nxnode_exit_func() {
	log 1 "Info: Emergency-Shutting down due to kill signal ..."
	session_fail $uniqueid
	server_remove_usession
	# remove lock file
	[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock
}

server_nxnode_start_wait() {
	if [ "$1" = "--startsession" ]; then
		server_add_usession
		# We need to stop sending things when a SIGPIPE arrives
		trap "SERVER_CHANNEL=0" SIGPIPE
		trap server_nxnode_exit_func EXIT
		SERVER_CHANNEL=1; KILL_WAIT_PID=1
		server_nxnode_start "$@" | while read CMD;
		do
			case "$CMD" in
				"NX> 706"*)
					if [ -x "$COMMAND_NXSHADOWACL" ]; then
						# check if we should save the cookie
						$COMMAND_NXSHADOWACL "$USER"
						if [ $? -eq 0 ]; then
							SHADOW_COOKIE=$(cutfn "$CMD" ":" 1)
							SHADOW_COOKIE=${SHADOW_COOKIE// /}
							session_change "$uniqueid" "shadowcookie" "$SHADOW_COOKIE"
						fi
					fi
				;;
				"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
					case "$CMD" in
						*running*)
							[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
							KILL_WAIT_PID=0
							log 6 session_set_status $uniqueid "Running"
							session_set_status $uniqueid "Running"
							[ "$SERVER_CHANNEL" = "1" ] && SERVER_CHANNEL=2
						;;
						*closed*)
							log 6 session_close $uniqueid
							session_close $uniqueid
						;;
						*suspended*)
							[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
							KILL_WAIT_PID=0
							log 6 session_suspend $uniqueid
							session_suspend $uniqueid
						;;
						*suspending*)
							log 6 session_set_status $uniqueid "Suspending"
							session_set_status $uniqueid "Suspending"
							# we need to stop sending to client as it will have already
							# closed his side of the channel and this will lead to not
							# closed sessions.
							SERVER_CHANNEL=0
						;;
						*terminating*)
							log 6 session_set_status $uniqueid "Terminating"
							session_set_status $uniqueid "Terminating"
							# we need to stop sending to client as it will have already
							# closed his side of the channel and this will lead to not
							# closed sessions.
							SERVER_CHANNEL=0
						;;
					esac
				;;
				"NX> 1004"*)
					[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
					KILL_WAIT_PID=0
					session_fail $uniqueid
					server_nxnode_echo "NX> 596 Session startup failed."
					log 4 "NX> 596 Session startup failed."
				;;
			esac

			case $CMD in
				"NX> "*)
					server_nxnode_echo $CMD
				;;
			esac
		done

		trap - EXIT
		trap - SIGPIPE
		# Close it in case the session is still running
		session_running $uniqueid && session_close $uniqueid
		server_remove_usession

		# remove lock file
		[ -e "/tmp/.nX$SESS_DISPLAY-lock" ] && rm -f /tmp/.nX$SESS_DISPLAY-lock

	# $1 = restore
	else
		KILL_WAIT_PID=1
		SERVER_CHANNEL=1
		server_nxnode_start "$@" | while read CMD
		do
			case "$CMD" in
				"NX> 706"*)
					if [ -x "$COMMAND_NXSHADOWACL" ]; then
						# check if we should save the cookie
						$COMMAND_NXSHADOWACL "$USER"
						if [ $? -eq 0 ]; then
							SHADOW_COOKIE=$(cutfn "$CMD" ":" 1)
							SHADOW_COOKIE=${SHADOW_COOKIE// /}
							session_change "$uniqueid" "shadowcookie" "$SHADOW_COOKIE"
						fi
					fi
				;;
				"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
					case "$CMD" in
						*running*)
							[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
							KILL_WAIT_PID=0
							SERVER_CHANNEL=2
						;;
					esac
				;;
				"NX> 1004"*)
					[ "$KILL_WAIT_PID" = "1" ] && kill $SERVER_WAIT_PID
					KILL_WAIT_PID=0
					# This fail is correct here as somehow the
					# monitor process might have died and we don't
					# want the session to be resumed again.
					session_fail $uniqueid
					server_nxnode_echo "NX> 596 Session startup failed."
					log 4 "NX> 596 Session startup failed."
					break;
				;;
			esac
			case $CMD in
				"NX> "*)
					server_nxnode_echo $CMD
				;;
			esac
		done
		# $1 = start
	fi
}

server_check_session_count() {
	session_count_user "$USER"
	if [ "$SESSION_COUNT" -ge "$SESSION_LIMIT" ]; then
		echo_x "NX> 599 Reached the maximum number of concurrent sessions on this server."
		echo_x "NX> 500 ERROR: Last operation failed."
		return 1
	fi
	if [ "$SESSION_COUNT_USER" -ge "$SESSION_USER_LIMIT" ]; then
		echo_x "NX> 599 Server capacity: reached for user: $USER"
		echo_x "NX> 500 ERROR: Last operation failed."
		return 1
	fi
	return 0
}

server_loadbalance_random() {
	# Pick one based on "random" algorithm
	SERVER_LB_HOSTS=( $LOAD_BALANCE_SERVERS )
	SERVER_LB_NR_OF_HOSTS=${#SERVER_LB_HOSTS[@]}
	let SERVER_LB_NR=(RANDOM % SERVER_LB_NR_OF_HOSTS)
	SERVER_LB_HOST=${SERVER_LB_HOSTS[$SERVER_LB_NR]}
	echo $SERVER_LB_HOST
}

# run in subshell!
server_loadbalance_round_robin() {
	SERVER_LB_HOSTS=( $LOAD_BALANCE_SERVERS )
	SERVER_LB_NR_OF_HOSTS=${#SERVER_LB_HOSTS[@]}
	# Atomic incrementation:
	# Enter critical section
	# - Create .lock file
	SERVER_LB_LOCKFILE=$(mktemp "$NX_SESS_DIR/round-robin.lock.XXXXXXXXX")
	trap "rm -f $SERVER_LB_LOCKFILE" EXIT
	i=0
	while [ $i -lt 200 ]; do
		# ln is an atomic operation
		ln $SERVER_LB_LOCKFILE "$NX_SESS_DIR/round-robin.lock" && break
		LANG=C sleep 0.01
		let i=i+1
	done

	if [ $i -ge 200 ]; then
		log 1 "Load-Balancing: Round-Robin failed to gain lock file in 200 tries. Falling back to random."
		server_loadbalance_random
		return
	fi
	trap "rm -f \"$SERVER_LB_LOCKFILE\" \"$NX_SESS_DIR/round-robin.lock\"" EXIT

	# Lock held
	SERVER_LB_NR=$(cat $NX_SESS_DIR/round-robin 2>/dev/null)
	let SERVER_LB_NR=(SERVER_LB_NR+1)%SERVER_LB_NR_OF_HOSTS
	echo $SERVER_LB_NR >$NX_SESS_DIR/round-robin

	# Exit critical section
	rm -f "$SERVER_LB_LOCKFILE" "$NX_SESS_DIR/round-robin.lock"
	trap - EXIT

	SERVER_LB_HOST=${SERVER_LB_HOSTS[$SERVER_LB_NR]}
	echo $SERVER_LB_HOST
}

server_loadbalance_load() {
	SERVER_LB_MAX=0; SERVER_LB_HOST=""
	export PATH_BIN
	for i in $LOAD_BALANCE_SERVERS; do
		SERVER_LB_LOAD=$($COMMAND_NXCHECKLOAD $i)
		[ -z "$SERVER_LB_LOAD" ] && continue
		if [ $SERVER_LB_LOAD -gt $SERVER_LB_MAX ]; then
			SERVER_LB_MAX=$SERVER_LB_LOAD
			SERVER_LB_HOST=$i
		fi
	done
	echo $SERVER_LB_HOST
}

server_loadbalance() {
	SERVER_HOST="127.0.0.1"
	if [ -n "$LOAD_BALANCE_SERVERS" ]; then
		SERVER_HOST=""
		if [ -n "$PREFERRED_HOST" -a "$ENABLE_LOAD_BALANCE_PREFERENCE" = "1" ]; then
			stringinstring " $PREFERRED_HOST " " $LOAD_BALANCE_SERVERS " && \
				SERVER_HOST="$PREFERRED_HOST"
		fi
		# Fallback if still empty
		if [ -z "$SERVER_HOST" ]; then
			case "$LOAD_BALANCE_ALGORITHM" in
				random)
					SERVER_HOST=$(server_loadbalance_random)
				;;
				round-robin)
					SERVER_HOST=$(server_loadbalance_round_robin)
				;;
				load)
					SERVER_HOST=$(server_loadbalance_load)
				;;
			esac
		fi
		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"
		[ -n "$SERVER_HOST" ] && log 5 "Info: Load-Balancing (if possible) to $SERVER_HOST ..."
	fi
	echo "$SERVER_HOST"
}

server_startrestore_session() {
	local ACTION="$1" PARAMS

	server_get_params $CMD
	PARAMS="$SERVER_PARAMS&clientproto=$PROTO&login_method=$LOGIN_METHOD"
	CMDLINE=$PARAMS; set_vars_from_cmdstr "$CMDLINE"
	echo_x

	# special shadowed type
	[ "$ACTION" != "start" -a "$type" = "vnc" ] && ACTION="shadow"

	if [ "$ACTION" = "shadow" ]; then
		ACTION="start"
		uniqueid=$restore
		[ -z "$uniqueid" ] && uniqueid=$id # 1.4.0-5 compatibility
		CMDLINE=$(session_get "$uniqueid" 2>/dev/null)

		shadowdisplay=$display; shadowhost=$host; shadowuser=$userName
		[ "$shadowcookie" = "none" ] && shadowcookie=""
		if [ -z "$shadowdisplay"  ]; then
			# check for DESKTOP_SHARING_IDS
			shadowdisplay=$(rematchfn "$uniqueid=([^ ]*)" "$DESKTOP_SHARING_IDS") #"
			shadowhost="127.0.0.1"
		fi
		if [ -z "$shadowdisplay" ]; then
			echo_x "NX> 596 Could not find shadowed session $uniqueid. Session failed."
			echo_x "NX> 596 Sharing: $DESKTOP_SHARING_IDS"
			return 1
		fi
		[ "$shadowhost" = "127.0.0.1" ] && shadowhost=""

		# not the same user? So we have a shadow cookie, we add to xauth
		if [ -n "$shadowcookie" -a \
				"$ENABLE_SESSION_SHADOWING_AUTHORIZATION" = "1" ]; then
			# Ask for permission first:
			echo_x "NX> 726 Asking user for authorization to attach to session"
			export XAUTHORITY=".Xauthority-$RANDOM-$$"
			$COMMAND_XAUTH add "$shadowhost:$shadowdisplay" MIT-MAGIC-COOKIE-1 \
				"$shadowcookie" >/dev/null 2>&1
			PERMISSION=$(
				$PATH_BIN/nxdialog -display $shadowhost:$shadowdisplay \
					-dialog yesno -caption "Authorization Request" \
					-message "Do you want to allow $USER to shadow your session?" 2>/dev/null &
				SHADOW_DIALOG_PID=$!
				I=0
				while kill -0 $SHADOW_DIALOG_PID 2>/dev/null; do
					let I=I+1
					[ $I -gt "$AGENT_STARTUP_TIMEOUT" ] && \
						kill $SHADOW_DIALOG_PID 2>/dev/null
					sleep 1
				done
				echo "no"
			)
			$COMMAND_XAUTH remove "$shadowhost:$shadowdisplay"
			rm -f "$XAUTHORITY"

			if [ "$PERMISSION" = "no" ]; then
				# User answered NO
				echo_x "NX> 596 Error: Authorization refused by user: $shadowuser."
				return 1
			fi
		fi

		PARAMS+="&shadowdisplay=$shadowdisplay&shadowhost=$shadowhost&\
shadowcookie=$shadowcookie&shadowuser=$shadowuser"
		CMDLINE=$PARAMS
	fi
	if [ "$ACTION" = "start" ]; then

		# Hack for external RDP/RFB agents
		if [ "$ENABLE_EXTERNAL_NXDESKTOP" = "1" -a "$type" = "windows" ]; then
			type="windows-helper"
			PARAMS+="&type=$type&freenx_export_agents=1"
			CMDLINE=$PARAMS
		fi

		if [ "$ENABLE_EXTERNAL_NXVIEWER" = "1" -a \
				"$type" = "vnc" ]; then
			type="vnc-helper"
			application="$PATH_BIN/nxviewer_helper"
			PARAMS+="&type=$type&application=$application&freenx_export_agents=1"
			CMDLINE=$PARAMS
		fi
	fi
	# If we can't get the userip and SSHD_CHECK_IP is set to 1
	# we bail out.
	if [ -z "$SSH_CLIENT" -a -z "$SSH2_CLIENT" ]; then
		if [ "$SSHD_CHECK_IP" = "1" ]; then
			echo_x "NX> 596 Session startup failed. (Missing SSH_CLIENT environment variable)"
			return 1
		else
			log 2 "Warning: Failed to determine the client IP."
			log 2 "Warning: The SSH_CLIENT or SSH2_CLIENT variable was not provided by SSHD."
			log 2 "Warning: Please set SSHD_CHECK_IP=1 if you want to refuse the connection."
		fi
	fi
	export ENCRYPTION=$encryption
	if [ "$ENABLE_FORCE_ENCRYPTION" = "1" -a "$ENCRYPTION" != "1" ]; then
			echo_x "NX> 596 Unencrypted sessions are not allowed."
			return 1
	fi

	if [ -x "$COMMAND_NXACL" ]; then
			log 3 "Info: Using $COMMAND_NXACL to change session parameters or deny session."
			NEW_PARAMS=$($COMMAND_NXACL "$CMDLINE")
			if [ $? -ne 0 ]; then
				echo_x "NX> 596 The session failed due to a nxacl policy setting: $NEW_PARAMS"
				return 1
			fi

			# check if the acl input did make sense
			if [ -n "$NEW_PARAMS" ]; then
				PARAMS=$NEW_PARAMS
				CMDLINE=$PARAMS
			fi
	fi

	# check if there is a suspended session, which we could resume
	if [ "$ENABLE_AUTORECONNECT" = "1" -a "$ACTION" = "start" ]; then
		restore=$(session_get_user_suspended "$USER" "Suspended")
		if [ -n "$restore" ]; then
			PARAMS+="&restore=$restore"
			CMDLINE=$PARAMS
			ACTION="resume"
		fi
	fi

	# as only $SSH_CLIENT or $SSH2_CLIENT will be set, this should work
	USERIP=$(rematchfn "($ip4_pattern)" "$SSH_CLIENT $SSH2_CLIENT") #"
	[ -z "$USERIP" ] && USERIP="*"
	if [ "$ACTION" = "start" -o "$ACTION" = "shadow" ]; then
		server_check_session_count || return 1

		# Possibly do loadbalancing
		SERVER_HOST=$(server_loadbalance)

		# start nxnode
		SESS_DISPLAY=$DISPLAY_BASE
		let SESS_DISPLAY_LIMIT=$DISPLAY_BASE+$DISPLAY_LIMIT
		# stupid but working algo ...

		while true; do
			while [ -e /tmp/.X$SESS_DISPLAY-lock -o \
					-e "/tmp/.nX$SESS_DISPLAY-lock"  -o \
					-e "/tmp/.X11-unix/X$SESS_DISPLAY" ]; do
				let SESS_DISPLAY=$SESS_DISPLAY+1
			done

			# Check if there is already an agent running on that display on that host
			let AGENT_DISPLAY=$SESS_DISPLAY+6000
			if $COMMAND_NETCAT -z "$SERVER_HOST" $AGENT_DISPLAY 2>/dev/null; then
				log 2 "Warning: Stray nxagent without .nX$SESS_DISPLAY-lock found on host:port $SERVER_HOST:$AGENT_DISPLAY."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			let PROXY_DISPLAY=$SESS_DISPLAY+4000
			if $COMMAND_NETCAT -z "$SERVER_HOST" $PROXY_DISPLAY 2>/dev/null; then
				log 2 "Warning: nxagent proxy without .nX$SESS_DISPLAY-lock found on host:port $SERVER_HOST:$AGENT_DISPLAY."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			# Now check for the other enabled services
			let SAMBA_DISPLAY=$SESS_DISPLAY+3000
			if [ "$samba" = 1 ] && ( $COMMAND_NETCAT -z \
					"$SERVER_HOST" $SAMBA_DISPLAY 2>/dev/null ); then
				log 2 "Warning: Skipping $SERVER_HOST:$AGENT_DISPLAY as samba port is not free."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			let MEDIA_DISPLAY=$SESS_DISPLAY+7000
			if [ "$media" = 1 ] && ( $COMMAND_NETCAT -z \
					"$SERVER_HOST" $MEDIA_DISPLAY 2>/dev/null ); then
				log 2 "Warning: Skipping $SERVER_HOST:$AGENT_DISPLAY as media port is not free."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			let CUPS_DISPLAY=$SESS_DISPLAY+9000
			if [ "$cups" = 1 ] && ( $COMMAND_NETCAT -z \
					"$SERVER_HOST" $CUPS_DISPLAY 2>/dev/null ); then
				log 2 "Warning: Skipping $SERVER_HOST:$AGENT_DISPLAY as cups port is not free."
				let SESS_DISPLAY=$SESS_DISPLAY+1
				continue
			fi

			SESS_LOCKFILE=$(mktemp "/tmp/.nX$SESS_DISPLAY-lock.XXXXXXXXX")
			# ln is an atomic operation
			ln "$SESS_LOCKFILE" "/tmp/.nX$SESS_DISPLAY-lock" 2>/dev/null && break
		done

		rm -f "$SESS_LOCKFILE"
		if [ "$SESS_DISPLAY" -gt "$SESS_DISPLAY_LIMIT" ]; then
			echo_x "NX> 596 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock."
			rm -f "/tmp/.nX$SESS_DISPLAY-lock"
			return
		fi
		display=$SESS_DISPLAY
		uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
		uniqueid=${uniqueid%% *}; uniqueid=${uniqueid^^}
		FULL_PARAMS="$PARAMS&user=$USER&userip=$USERIP&uniqueid=$uniqueid&\
display=$display&host=$SERVER_HOST"
		log_secure "6" "$FULL_PARAMS"

		# now update the session listing
		sessionRootlessMode=0
		[ "$rootless" = "1" ] && sessionRootlessMode=1
		CMDLINE="a=b&$FULL_PARAMS"
		session_add $uniqueid "sessionName=$session&display=$display&\
status=Running&startTime=$(date +%s)&foreignAddress=$USERIP&\
sessionRootlessMode=$sessionRootlessMode&type=$type&sessionId=$uniqueid&\
creationTime=$(date +%s)&userName=$USER&serverPid=$SERVER_PID&\
screeninfo=$screeninfo&geometry=$geometry&host=$SERVER_HOST&shadowcookie=none"
	else
		uniqueid=$restore
		[ -z "$uniqueid" ] && uniqueid=$id # 1.4.0-5 compatibility
		session_change "$uniqueid" "foreignAddress" "$USERIP"

		CMDLINE=$(session_get "$uniqueid");
		display=$(getparam display); host=$(getparam host)
		FULL_PARAMS="$PARAMS&user=$USER&userip=$USERIP&\
uniqueid=$uniqueid&display=$display&status=$status"
		SESS_DISPLAY=$display
		SERVER_HOST=$host
		[ -z "$SERVER_HOST" ] && SERVER_HOST="127.0.0.1"

		if [ "$ENABLE_ADVANCED_SESSION_CONTROL" = "1" ]; then
			CMDLINE="$FULL_PARAMS"
			case "$session" in
				"add "*)
					server_nxnode_start --applicationsession "$USER" \
						"$FULL_PARAMS"
					echo_x "Quit"
					echo_x "NX> 999 Quit"
					exit_proc 1
				;;
			esac
		fi
	fi

	# now start the node
	sleep $AGENT_STARTUP_TIMEOUT &
	SERVER_WAIT_PID=$!
	( server_nxnode_start_wait --"$ACTION"session $USER "$FULL_PARAMS" ) &
	SERVER_PID=$!
	disown $SERVER_PID
	wait $SERVER_WAIT_PID 2>/dev/null
	if [ $? -eq 0 ]; then
		# Something went wrong ...
		[ "$ACTION" = "start" ] && session_fail $uniqueid
		echo_x "NX> 1004 Error: Session did not start."
		echo_x "NX> 596 Session $ACTION failed."
		echo_x "NX> 999 Bye"
		# FIXME: Send node signal to terminate
		exit_proc 1
	fi
	# We have now an active reader
	nxnode_login_register_reader
}

# Session stage
while true; do
	echo_x -n "NX> 105 "
	unset CMD
	read CMD 2>/dev/null
	# FIXME?
	[ "$CMD" = "" ] && CMD="quit"
	# Logging
	case "$CMD" in
		startsession*|restoresession*|addmount*|addprinter*)
			echo_secure "$CMD"
			log_secure "4" "$CMD"
		;;
		*)
			echo "$CMD"
			log "4" "$CMD"
		;;
	esac
	case "$CMD" in
		quit|QUIT)
			echo_x "Quit"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		exit|EXIT)
			echo_x "Exit"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		bye|BYE)
			echo_x "Bye" 1>&2
			echo_x "NX> 999 Bye" 1>&2
			if [ "$ENCRYPTION" = "1" ]; then
				let PROXY_DISPLAY=$SESS_DISPLAY+4000
				$COMMAND_NETCAT $SERVER_HOST $PROXY_DISPLAY 2>/dev/null
				RC=$?
				# kill our parent sshd process
				kill $PPID
				exit_proc $RC
			else
				echo_x "NX> 1001 Bye."
			fi
		;;
		startsession*)
			server_startrestore_session "start"
		;;
		list*)
			server_get_params $CMD; PARAMS=$SERVER_PARAMS
			CMDLINE=$PARAMS; set_vars_from_cmdstr "$CMDLINE"


			if [ "$status" = "Suspended" -a -n "$screeninfo" ]; then
				session_list_user_suspended "$USER" "Suspended" \
					"$screeninfo" "$type"
			elif [ "$status" = "Suspended,Running" -o "$status" = "Suspended" ]; then
				# disabled due to problems with 1.4.0-5 client
				#session_list_user_suspended "$USER" 'Suspended$|^status=Running$' "$(getparam geometry)" "$(getparam type)" | log_tee
				session_list_user_suspended "$USER" 'Suspended' "$geometry" "$type"
			elif [ "$status" = "suspended,running" -o "$status" = "suspended" ]; then
				# since 1.5.0
				status=${status/,/|}; status=${status/suspended/Suspended};
				status=${status/running/Running};
				[ "$ENABLE_SHOW_RUNNING_SESSIONS" = "0" ] && status="Suspended"
				session_list_user_suspended "$USER" "$status" "$geometry" "$type"
			elif [ "$type" = "shadow" ]; then
				session_list_user_suspended ".*" "Suspended|Running" "" "shadow"
			else
				session_list_user "$USER" | log_tee
			fi
		;;
		suspend*)
			server_get_params $CMD;	PARAMS=$SERVER_PARAMS
			CMDLINE=$PARAMS; set_vars_from_cmdstr "$CMDLINE"
			if session_find_id_user "$sessionid" "$USER"; then
				server_nxnode_start --suspend "$USER" "$PARAMS"
			fi
		;;
		terminate*)
			server_get_params $CMD; PARAMS=$SERVER_PARAMS
			CMDLINE=$PARAMS;
			if session_find_id_user "$(getparam sessionid)" "$USER"; then
				server_nxnode_start --terminate "$USER" "$PARAMS"
			fi
		;;
		restoresession*)
			server_startrestore_session "resume"
		;;
		attachsession*)
			server_startrestore_session "shadow"
		;;
		passwd)
			echo_x "NX> 113 Changing password of user '$USER'"
			echo_x -n "NX> 102 Current password:"
			read -r -s PASS
			ENC_PASS=$(passdb_get_crypt_pass "$PASS")
			REAL_PASS=$(passdb_get_pass "$USER")
			echo_x
			if [ "$ENC_PASS" = "$REAL_PASS" ]; then
				echo_x -n "NX> 102 Password:"
				read -r -s NEW_PASS1
				if [ ${#NEW_PASS1} -lt 5 ]; then
					echo_x "NX> 500 ERROR: incorrect password format, password must be long at least five characters"
					continue
				fi
				echo_x
				echo_x -n "NX> 102 Confirm password:"
				read -r -s NEW_PASS1
				echo_x
				if [ "$NEW_PASS1" = "$NEW_PASS2" ]; then
					ENC_PASS=$(passdb_get_crypt_pass "$NEW_PASS1")
					passdb_chpass "$USER" "$ENC_PASS"
					echo_x "NX> 114 Password of user '$USER' changed"
				else
					echo_x "NX> 537 ERROR: passwords do not match"
				fi
			else
				echo_x "NX> 500 ERROR: current password doesn't match"
			fi
		;;
		addmount*)
			server_get_params $CMD
			PARAMS="$SERVER_PARAMS"
			( server_nxnode_start --smbmount "$USER" "$PARAMS" >/dev/null 2>&1 ) &
		;;
		addprinter*)
			server_get_params $CMD
			PARAMS="$SERVER_PARAMS"
			( server_nxnode_start --addprinter "$USER" "$PARAMS" >/dev/null 2>&1 ) &
		;;
		*)
			# disabled for 1.4.0-5 snapshot client
			#echo_x "NX> 503 Error: undefined command: '$CMD'"
		;;
	esac
done

fi # SERVER_MODE == "1"

#
# End of Main nxserver <--> nxclient communication module
#

################### PACKAGE cmd.bm ############################

#
# library functions for nxserver-commandline cmds
#

# Policy: All functions and variables need to start with CMD_ / cmd_
# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN,
#			$NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
# Needed package: passdb
cmd_usage() {
	echo "NXSERVER - Version $NX_VERSION $NX_LICENSE" 1>&2
	echo "Usage: nxserver <option>" 1>&2

	if [ "$1" = "root" ]; then
		echo "--adduser <user>: Add a new user" 1>&2
		echo "--passwd <user>: Change password of <user>" 1>&2
		echo "--deluser <user>: Remove a user from nx" 1>&2
		echo "--listuser: List enabled users" 1>&2
		echo "" 1>&2
		echo "--start: Start the nx server" 1>&2
		echo "--stop: Stop the nx server" 1>&2
		echo "--status: Show status of nx server" 1>&2
		echo "--restart: Restart the nx server. (start,stop)" 1>&2
		echo "" 1>&2
		echo "--list [ user | sessionid ]: List running sessions of user or sessionid " 1>&2
		echo "--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history" 1>&2
		echo "--terminate <user | :display | sessionid>: Terminate the session pointed to by" 1>&2
		echo "       sessionid or display, or all sessions of the specified user." 1>&2
		echo "       Use * for all sessions." 1>&2
		echo "--force-terminate: Like terminate, but removes also session info." 1>&2
		echo "--suspend <user | :display | sessionid>: Suspend the session pointed to by" 1>&2
		echo "       sessionid or display, or all sessions of the specified user." 1>&2
		echo "       Use * for all sessions." 1>&2
		echo "--cleanup: Terminates all running sessions. Useful after power-outage."
		echo "" 1>&2
		echo "--broadcast <message>: Send a message to all users" 1>&2
		echo "--send <user | :display | sessionid> <message>: Send a message to the specified user or sessionid" 1>&2
	else
		echo "--passwd: Change password" 1>&2
	fi
	exit_proc 1
}


cmd_abort() {
	echo -e "NX> 500" "$@" 1>&2
	echo "NX> 999 Bye" 1>&2
	exit_proc 1
}

cmd_abort_success() {
	echo "NX> 500" "$@" 1>&2
	echo "NX> 999 Bye" 1>&2
	exit_proc 0
}

cmd_user_passwd() {
	echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
	echo "Sorry: Password changing for user is _not_ implemented, yet."
	echo "Please login to NX-Server to change password"
	echo "or ask your local system administrator."
	#echo "NX> 113 Changing password of user '$USER'"
	#echo "Old password:"
	#read -s OLDPASS
	#echo "New password:"
	#read -s NEWPASS1
	#echo "Repeat:"
	#read -s NEWPASS2
}

cmd_passwd() {
	CMD_CHUSER=$2
	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || \
		cmd_abort "Error: User $CMD_CHUSER not found in database."
	echo -n "New password: "
	read -r -s CMD_NEWPASS
	echo
	CMD_ENC_PASS=$(passdb_get_crypt_pass "$CMD_NEWPASS")
	passdb_chpass "$CMD_CHUSER" "$CMD_ENC_PASS"
	echo "Password changed."
}

cmd_checkpassdb() {
	if [ "$ENABLE_PASSDB_AUTHENTICATION" != "1" ]; then
		cmd_abort "Error: The passdb function is not activated in node.conf.\n\nMost probably your FreeNX setup will work out of the box without this\nfunctionality and you've been misleaded by an old tutorial or old\ndocumentation to do this step.\n\nIf however you really need this functionality, just set\nENABLE_PASSDB_AUTHENTICATION=\"1\" in node.conf.\n"
	fi
	return 0
}

cmd_adduser() {
	CMD_CHUSER=$2
	[ ${#CMD_CHUSER} -ge 32 ] && \
		cmd_abort "Error: User $CMD_CHUSER must be shorter than 32 characters."
	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords && \
		cmd_abort "Error: User $CMD_CHUSER already in database."
	getent passwd "$CMD_CHUSER" >/dev/null || \
		cmd_abort "Error: User $CMD_CHUSER not existing on local system. Can't add."
	passdb_add_user "$CMD_CHUSER"
}

cmd_deluser() {
	CMD_CHUSER=$2
	egrep -q "^$CMD_CHUSER:" $NX_ETC_DIR/passwords || \
		cmd_abort "Error: User $CMD_CHUSER not found in database."
	passdb_remove_user "$CMD_CHUSER"
}

cmd_listuser() {
	echo "NX> 146 NX users list"
	echo
	echo "Username"
	echo "---------------"
	echo
	passdb_list_user
	echo
}

cmd_start() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && \
		cmd_abort_success "ERROR: Service already running"
	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled \
		$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
	echo "NX> 122 Service started"
}

cmd_stop() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || \
	cmd_abort_success "Service was already stopped"
	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS \
		$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
	echo "NX> 123 Service stopped"
}

cmd_status() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && \
		echo "NX> 110 NX Server is running"
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || \
		echo "NX> 110 NX Server is stopped"
}

cmd_restart() { cmd_stop; cmd_start; }

cmd_parse_2_params()
{
	local CMD_APARAMS;
	if [ ${#1} -eq 32 ]; then
		CMD_APARAMS="sessionid=sessionId{$1}"
	elif [ "$1" != "" ]; then
		#egrep -q "^$1:" $NX_ETC_DIR/passwords || cmd_abort "Error: User $1 not found in database."
		CMD_APARAMS="user=$1"
	fi
	echo "$CMD_APARAMS"
}

cmd_parse_3_params()
{
	local CMD_PARAMS;
	if [ ${#1} -eq 32 ]; then
		CMD_PARAMS=$(session_find_id $1)
		[ -n "$CMD_PARAMS" ] || cmd_abort "Error: Session $1 could not be found."
	elif [ "${1:0:1}" = ":" ]; then
		CMD_PARAMS=$(session_find_display "${1:1}")
		[ -n "$CMD_PARAMS" ] || cmd_abort "Error: No running sessions found for display $1."
	elif [ "$1" = "*" ]; then
		CMD_PARAMS=$(session_find_all)
		[ -n "$CMD_PARAMS" ] || cmd_abort "Error: No running sessions found."
	elif [ "$1" != "" ]; then
		CMD_PARAMS=$(session_find_user "$1")
		[ -n "$CMD_PARAMS" ] || cmd_abort "Error: No running sessions found for user $1."
	else
		cmd_abort "Error: Not enough parameters."
	fi
	echo "$CMD_PARAMS"
}

cmd_list_suspended() {
	local CMD_PARAMS=$(cmd_parse_2_params "$2")
	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit_proc 1
	case $CMD_PARAMS in
		user=*)
			session_list_user_suspended $2 "Suspended"
		;;
	esac
}
cmd_list() {
	local CMD_PARAMS=$(cmd_parse_2_params "$2")
	[ -n "$2" -a -z "$CMD_PARAMS" ] && exit_proc 1
	case $CMD_PARAMS in
		user=*)
			session_list_user $2
		;;
		sessionid=*)
			session_list $2
		;;
		*)
			session_list_all
		;;
	esac
}

cmd_history_clear() {
	q_dbe "DELETE FROM sess WHERE status IN ('Finished','Failed');"
}

cmd_history() {
	local CMD_PARAMS user="" sessid=""
	if [ "$2" = "clear" ]; then cmd_history_clear; return; fi
	CMD_PARAMS=$(cmd_parse_2_params "$2")
	case $CMD_PARAMS in
		user=*)
			user="$2"
		;;
		sessionid=*)
			sessid="$2"
		;;
	esac
	session_history "$user" "$sessid"
}

cmd_execute() {
	local cmd_host="$1" cmd_user="$2" cmd_cmd="$3"
	if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
		sh -c "$cmd_cmd"
	elif [ "$cmd_host" = "127.0.0.1" -o "$cmd_host" = "localhost" ]; then
		/bin/su - "$cmd_user" -c "$cmd_cmd"
	else
		ssh "$cmd_host" su - "$cmd_user" -c "'$cmd_cmd'"
	fi
}

cmd_terminate_or_send() {
	local CMD="$1" CMD_PARAMS cmd_sessionid cmd_display cmd_user cmd_type \
		cmd_status cmd_host;
	if [ "$CMD" = "--broadcast" ]; then
		CMD_PARAMS=$(session_find_all)
		[ -z "$CMD_PARAMS" ] && cmd_abort "Error: No running session could be found."
	else
		CMD_PARAMS=$(cmd_parse_3_params "$2")
		[ -z "$CMD_PARAMS" ] && exit_proc 1
		shift
	fi
	shift

	while read CMDLINE; do
		[ -z "$CMDLINE" ] && continue
			cmd_sessionid=$(getparam sessionId)
			cmd_display=$(getparam display)
			cmd_user=$(getparam userName)
			cmd_type=$(getparam type)
			cmd_status=$(getparam status)
			cmd_host=$(getparam host)

			# is it a "good" session?
			case "$CMD" in
			--suspend)
				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
				then
					echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --suspend"
				fi
			;;
			--terminate)
				echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --terminate"
			;;
			--force-terminate)
				echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --terminate"
				session_close $cmd_sessionid
			;;
			--send|--broadcast)
				# is it a "good" session?
				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
				then
					cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxdialog --dialog ok --caption \"NX Administrator Message\" --message \"$@\" -display \":$cmd_display\" &"
				fi
			esac
	done <<< "$CMD_PARAMS"
}

if [ "$NX_LOG_LEVEL" -ge "1" -a ! -f "$NX_LOGFILE" ]; then
	touch "$NX_LOGFILE" >/dev/null 2>&1
fi
open_dbe
isdbs=""; [ -f $sess_bd ] && isdbs="1"
attach_db $sess_bd
init_sess_db
[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
	-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs
if [ "$UID" -eq "0" ]; then
	chown nx "$NX_LOGFILE" >/dev/null 2>&1; chmod 660 "$NX_LOGFILE"
	chown nx "$sess_bd" >/dev/null 2>&1; chmod 660 "$sess_bd"
fi

#
# normal user available functions
if [ $UID -ne 0 -a "$ENABLE_USERMODE_AUTHENTICATION" != "1" ]; then
	[ "$1" = "--agent" ] && exec $PATH_BIN/nxnode "$@"
	[ "$1" != "--passwd" ] && cmd_usage
	cmd_user_passwd
	exit_proc 0
fi

#
# root mode available functions
[ $# -lt 1 ] && cmd_usage "root"
[ "$1" = "--help" ] && cmd_usage "root"

if [ "$1" = "--version" ]; then
  echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
  exit_proc 0
fi

CMD=$1
echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
case $CMD in
	#
	# User functions ...
	--passwd)
		cmd_checkpassdb
		cmd_passwd "$@"
	;;
	--adduser|--useradd)
		cmd_checkpassdb
		cmd_adduser "$@"
	;;
	--deluser|--userdel)
		cmd_checkpassdb
		cmd_deluser "$@"
	;;
	--listuser|--userlist)
		cmd_checkpassdb
		cmd_listuser
	;;
	--start)
		cmd_start
	;;
	--stop)
		cmd_stop
	;;
	--status)
		cmd_status
	;;
	--restart)
		cmd_restart
	;;
	--list)
		cmd_list "$@"
	;;
	--list-suspended)
		cmd_list_suspended "$@"
	;;
	--history)
		cmd_history "$@"
	;;
	--terminate|--suspend|--force-terminate)
		cmd_terminate_or_send "$@"
	;;
	--cleanup)
		cmd_terminate_or_send "--force-terminate" "*"
	;;
	--send|--broadcast)
		cmd_terminate_or_send "$@"
	;;
	*)
		cmd_abort "Error: Function $CMD not implemented yet."
esac
echo "NX> 999 Bye"
