#!/bin/bash

# Free implementation of nxserver components
#
# To use nxserver add the user "nx"
# and use nxserver as default shell.
#
# Also make sure that hostkey based authentification works.
#
# Copyright (c) 2004 by Fabian Franz <FreeNX@fabian-franz.de>.
#           (c) 2008-19 by Dmitry Borisov <i@dimbor.ru>
#
# License: GNU GPL, version 2
#
# SVN: $Id: nxserver 612 2008-08-25 03:28:15Z fabianx $
#

shopt -s extglob

# Read the config file
# dimbor: it's temporary
. /usr/bin/nxloadconfig --userconf

. $SHARED_CONFS/nxfuncs

############### PACKAGE log.bm #######################
#
# Library of log functions (outsource)
#

# Loglevels:
# 1: Errors
# 2: Warnings
# 3: Important information
# 4: Server - Client communication
# 5: Information
# 6: Debugging information
# 7: stderror-channel of some applications

log() {
#args: <loglevel> <logstr>
	[ "$NX_LOG_LEVEL" -ge "$1" ] && shift && {
		[ -n "$1" ] &&
			echo -n "[$(date "+%d.%m %T.%3N")] " >> "$NX_LOGFILE"
		echo $@ >> "$NX_LOGFILE"
	}
}

# Log in a way that is secure for passwords / cookies / ...
echo_secure() {
	[ -n "$1" ] &&
		echo -n "[$(date "+%d.%m %T.%3N")] " >> "$NX_LOGFILE"
	local res=${@//&password=*&/&password=****&}
	res=${res//--cookie=\"+([^\"])\"/--cookie=\"****\"}
	res=${res//--password=\"+([^\"])\"/--password=\"****\"}
	echo "$res"
}

log_secure() {
#args: <loglevel> <logstr>
	if [ "$NX_LOG_SECURE" = "0" ]; then log $@
	elif [ "$NX_LOG_LEVEL" -ge "$1" ]; then
		shift && echo_secure $@ >> "$NX_LOGFILE"
	fi
}

log_tee() {
	if [ "$NX_LOG_LEVEL" -ge "4" ]; then exec tee -a "$NX_LOGFILE"
	else exec cat -
	fi
}

log_error() {
	if [ "$NX_LOG_LEVEL" -ge "7" ]; then exec tee -a "$NX_LOGFILE"
	else exec cat -
	fi
}

echo_x() { log "4" "$@"; echo "$@"; }

############### PACKAGE passdb.bm #######################
#
# Library of passdb functions (outsource)
#

# Policy: Variable and function names _must_ start with passdb_ / PASSDB_

# Needed global vars: $NX_ETC_DIR, $PATH_BIN

# Needed nonstd functions: md5sum

passdb_get_crypt_pass() { echo "$@" | $COMMAND_MD5SUM | cut -d" " -f1; }

passdb_get_pass() {
	local passdb_chuser="$1"
	local passdb_pass=$(egrep "^$passdb_chuser:" $NX_ETC_DIR/passwords 2>/dev/null | cut -d":" -f2)
	if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" ]; then
		egrep -q "^$passdb_chuser:" $NX_ETC_DIR/passwords 2>/dev/null && echo $passdb_pass
		egrep -q "^$passdb_chuser:" $NX_ETC_DIR/passwords 2>/dev/null || echo "NOT_VALID"
	else
		echo "NOT_VALID"
	fi
}

passdb_chpass() {
	local passdb_chuser="$1" passdb_enc_pass="$2"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	sed -i -e "s/$passdb_chuser:.*/$passdb_chuser:$passdb_enc_pass/g" $NX_ETC_DIR/passwords
}

passdb_user_exists() {
	local passdb_chuser="$1"
	egrep -q "^$passdb_chuser:" $NX_ETC_DIR/passwords 2>/dev/null
}


passdb_remove_user() {
	local passdb_chuser="$1"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	sed -i -e "/$passdb_chuser:/d" $NX_ETC_DIR/passwords
}

passdb_add_user() {
	local passdb_chuser="$1"
	cp -f $NX_ETC_DIR/passwords $NX_ETC_DIR/passwords.orig
	echo "$passdb_chuser:*" >> $NX_ETC_DIR/passwords
	# deactivated to avoid problems with comm-server
	su - $passdb_chuser -c "$PATH_BIN/nxnode --setkey"
}

passdb_list_user() {
	cat $NX_ETC_DIR/passwords | cut -d":" -f1
}

#
# End of passdb Library
#

############### PACKAGE session.bm #######################
#
# Library of session management functions
#

# Needed global vars: NX_SESS_DIR session_count session_count_user
# COMMAND_MD5SUM SESSION_USER_LIMIT SESSION_LIMIT SESSION_HISTORY
# COMMAND_NXSHADOWACL user ENABLE_MIRROR_VIA_VNC

# =================== sqlite3 stuff =====================

sess_bd="$NX_SESS_DIR/sessions.sq3"
sqcols_sess="sessionName, display, status, startTime, foreignAddress,\
 sessionRootlessMode, type, sessionId, creationTime, userName,\
 serverPid, screeninfo, geometry, host, shadowcookie, endTime"
sqcols_sess_c=16

migrate_old_conf_dirs() {
	local txt fn fields vals field val;
   for fn in $NX_SESS_DIR/{closed,failed}/*; do
		txt=$(< $fn); txt=${txt//=/ }; fields=""; vals="";
		while read field val; do
			fields+="${fields:+,}$field"; vals+="${vals:+,}'$val'";
		done <<< "$txt"
		q_dbe "INSERT INTO sess($fields) VALUES($vals);"
	done >/dev/null 2>&1
	log 1 "Info: Sessions db migrated to sqlite3 format."
	rm -rf $NX_SESS_DIR/{closed,failed,running} >/dev/null 2>&1
}

init_sess_db() {
	local sess_cols="sessionId TEXT PRIMARY KEY, sessionName TEXT,\
 display TEXT, status TEXT, startTime INT, foreignAddress TEXT,\
 sessionRootlessMode INT, type TEXT, creationTime INT, userName TEXT,\
 serverPid TEXT, screeninfo TEXT, geometry TEXT, host TEXT,\
 shadowcookie TEXT, endTime INT"
	local qstr="CREATE TABLE IF NOT EXISTS sessions.sess($sess_cols);"
	qstr+="CREATE INDEX IF NOT EXISTS sessions.idx_statusUserName ON\
 sess(status,userName);"
   q_dbe "$qstr"
}

exit_proc() {
	close_dbe; exit $1;
}

#-------------------------------------------------------------------

session_list() {
#params: sessId  ["format_times"]
#if you need to humane output put something in $2
	local qc fls res r2="";
	[ -n "$2" ] && { fls="sessionName, display, status,\
 datetime(startTime,'unixepoch','localtime') AS startTime,\
 foreignAddress, sessionRootlessMode, type, sessionId,\
 datetime(creationTime,'unixepoch','localtime') AS creationTime, userName,\
 serverPid, screeninfo, geometry, host, shadowcookie,\
 datetime(endTime,'unixepoch','localtime') AS endTime";
	} || { # original order of fields
		fls=$sqcols_sess;
	}
   q_dbe ".mode line sess"
	res=$(qa_dbe $sqcols_sess_c "SELECT $fls FROM sess WHERE sessionId='$1' LIMIT 1;")
	[ -n "$2" ] && { 	echo "$res"; return; }
	local line k v;
	while read line; do
		k=$(trim "$(cutfn "$line" "=" 0)"); v=$(trim "$(cutfn "$line" "=" 1)") #"
		r2+="$k=$v"$'\n'
	done <<< "$res"
	echo -n "$r2"
}

session_find_cmdstrs() {
#params: [sessid] [user] [display] [status="Running|Suspended"]
#ret: sessions command strings delimited by \n
	local st wstr qc res;
	st="Running|Suspended"; [ -n "$4" ] && st="$4"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	[ -n "$1" ] && wstr+=" AND $(str_eq_cond "sessionId" "$1")"
	[ -n "$2" -a "$2" != "all" -a "$2" != ".*" ] && \
		wstr+=" AND $(str_eq_cond "userName" "$2")"
	[ -n "$3" ] && wstr+=" AND $(str_eq_cond "display" "$3")"
   q_dbe ".mode tabs sess"
	qc=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;"); #"
	[ "$qc" -gt "0" 2>/dev/null ] || return
	qc=$((qc*sqcols_sess_c))
   q_dbe ".mode line sess"
	res=$(qa_dbe $qc "SELECT $sqcols_sess FROM sess $wstr ORDER BY startTime DESC;")
	qtxt2cmdstrs "$res"
}

# Find all running session-filenames
session_find_all() { session_find_cmdstrs; }

# Find all running sessions of a id
session_find_id() { session_find_cmdstrs "$1"; }

# Finds out if a session belongs to a user
session_find_user() { session_find_cmdstrs "" "$1"; }

# Find all running sessions of a display
session_find_display() { session_find_cmdstrs "" "" "$1"; }

# Finds out if a session belongs to a user
session_find_id_user() {
#params: sessid [user]
	local wstr c;
	wstr="WHERE sessionId='$1' AND status IN ('Running', 'Suspended')"
	[ -n "$2" -a "$2" != "all" -a "$2" != ".*" ] && \
		wstr+=" AND $(str_eq_cond "userName" "$2")"
   q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	[ "$c" -gt "0" 2>/dev/null ] || return 1
	return 0
}

# session_get <uniqueid>
session_get()  { session_find_cmdstrs "$1"; }

# Get the first session, which can be resumed
session_get_user_suspended() {
#params: user status
#ret: sessionId line[s] or empty
	local wstr r a;
	wstr="WHERE status='$2'AND username='$1'"
   q_dbe ".mode tabs sess"
	r=$(qa_dbe "SELECT count(sessionId), sessionId FROM sess $wstr ORDER BY startTime DESC LIMIT 1;") #"
	a=($r); ((${#a[@]}==2)) && echo "${a[1]}"
}

session_get_user_suspended() {
#params: user status
#ret: sessionId line[s] or empty
	local wstr r a;
	wstr="WHERE status='$2'AND username='$1'"
   q_dbe ".mode tabs sess"
	r=$(qa_dbe "SELECT count(sessionId), sessionId FROM sess $wstr ORDER BY startTime DESC LIMIT 1;") #"
	a=($r); ((${#a[@]}==2)) && echo "${a[1]}"
}

session_count_user() {
#params: userName [status]
# Count all sessions of a user
# and save it in session_count and session_count_user
	local st wstr r u="" sc="" uc
	session_count=0; session_count_user=0
	st="Running|Suspended"; [ -n "$2" ] && st="$2"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	q_dbe ".mode tabs sess"
	if [ "$1" = ".*" -o "$1" = "all" ]; then
		session_count=$(qa_dbe "SELECT count(*) FROM sess $wstr;") #"
		session_count_user=$session_count
		return 0
	fi
	uc=$(qa_dbe "SELECT count(DISTINCT userName) FROM sess $wstr LIMIT 1;") #"
	((uc==0)) && return;
	r=$(qa_dbe $uc "SELECT userName,count(*) FROM sess $wstr GROUP BY userName;") #"
	while read u sc; do
		[ -z "$sc" ] && continue
		((session_count+=sc))
		[ "$u" = "$1" ] && session_count_user=$sc
	done <<< "$r"
	return 0
}

_session_list_user_suspended() {
# use conf vars: COMMAND_NXSHADOWACL ENABLE_MIRROR_VIA_VNC COMMAND_MD5SUM
# use glob: user
	local CMDLINE cmdstrs pattern geom depth render udepth urender mode;
	local options available uniqueid geo2 displays;
	echo "NX> 127 Sessions list of user '$1' for reconnect:"
	echo
	if [ -z "$4" ]; then
		echo "Display Type             Session ID                       Options  Depth Screensize     Available Session Name"
		echo "------- ---------------- -------------------------------- -------- ----- -------------- --------- ----------------------"
	else
		echo "Display Type             Session ID                       Options  Depth Screen         Status      Session Name"
		echo "------- ---------------- -------------------------------- -------- ----- -------------- ----------- ------------------------------"
	fi
	cmdstrs=$(session_find_cmdstrs "" "$1" "" "$2")
	while read CMDLINE; do
		[ -z "$CMDLINE" ] && continue
		if [ "$4" = "shadow" -a "$(getparam userName)" != "$user" ]; then
			[ -z "$(getparam shadowcookie)" ] && continue
			if [ -x "$COMMAND_NXSHADOWACL" ]; then
				$COMMAND_NXSHADOWACL "$(getparam userName)" "$user" || continue
			fi
		fi

		pattern='^([0-9]*x[0-9]*)x([0-9]*)\+?([^+]*)'
		[[ $(getparam screeninfo) =~ $pattern ]]
		geom=${BASH_REMATCH[1]}; depth=${BASH_REMATCH[2]}; render=${BASH_REMATCH[3]}
		[[ $3 =~ $pattern ]]
		udepth=${BASH_REMATCH[2]}; urender=${BASH_REMATCH[3]}
		mode="D"; [ "$(getparam sessionRootlessMode)" = "1" ] && mode="-"
		options="-"; stringinstring "fullscreen" "$3" && options="F"
		[ "$(getparam geometry)" = "fullscreen" ] || options="-"
		[ "$urender" = "render" ] && options="${options}R${mode}--PSA"
		[ "$urender" = "render" ] || options="${options}-${mode}--PSA"
		[ "$udepth" = "$depth" -a "$urender" = "$render" ] && available=$(getparam status)
		# FIXME: HACK !!! to keep compatibility with old snapshot version (Knoppix 3.6 based for example)
		if [ -z "$4" -a "$available" != "N/A" ]; then
			available="Yes"
		fi
		# We automatically offer VNC shadowed sessions for "remote" support
		if [ "$4" = "vnc" -a "$ENABLE_MIRROR_VIA_VNC" = "1" ] \
					&& stringinstring "unix-" "$(getparam type)"; then
			available=$(getparam status)
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "vnc-shadowed" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName) (Mirrored)"
		elif [ "$4" = "shadow" ]; then
			available=$(getparam status)
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "$(getparam type)" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName) ($(getparam userName)) (Shadowed)"
		else
			# only unix-* sessions can be resumed, but other session types can still be terminated
			stringinstring "unix-" "$4" || available="N/A"
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$(getparam display)" "$(getparam type)" "$(getparam sessionId)" "$options" "$depth" "$geom" "$available" "$(getparam sessionName)"
		fi
	done <<< "$cmdstrs"

	if [ "$4" = "vnc" -o "$4" = "shadow" -a "$ENABLE_DESKTOP_SHARING" = "1" ]; then
		export DESKTOP_SHARING_IDS=""
		geo2=$(rematchfn '^([[:digit:]]+x[[:digit:]]+)' $3) #'
		displays=$(LC_ALL=C netstat -ln --protocol=unix)
		displays=$(rematchfn 'X11-unix/X([0-9]+)' "$displays" "all")  #'
		for i in $displays; do
			uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
			uniqueid=${uniqueid%% *}; uniqueid=${uniqueid^^}
			DESKTOP_SHARING_IDS="$DESKTOP_SHARING_IDS $uniqueid=$i"
			printf "%-7s %-16s %32s %8s %5s %-14s %-11s %s\n" "$i" "Local" "$uniqueid" "--------" "$udepth" "$geo2" "Running" "X$i (Local)"
		done
	fi
	echo ""
	echo ""

	session_count_user "$1"
	if [ "$session_count" -ge "$SESSION_LIMIT" -o \
			"$session_count_user" -ge "$SESSION_USER_LIMIT" ]; then
		echo "NX> 147 Server capacity: reached for user: $1"
	else
		echo "NX> 148 Server capacity: not reached for user: $1"
	fi
}

session_list_user_suspended() {
	local slcd=$(_session_list_user_suspended $@)
	echo "$slcd" | log_tee
}

session_list_user() {
#params: userName [status="Running|Suspended"]
	local st wstr c
	echo -n "NX> 127 Sessions list"
	if [ -n "$1" -a "$1" != "all" ]; then echo " of user '$1'"
	else echo ":"
	fi
	echo
	echo "Server	 Display Username		Remote IP	   Session ID"
	echo "------ ------- --------------- --------------- --------------------------------"
	st="Running|Suspended"; [ -n "$2" ] && st="$2"
	wstr="WHERE $(str_eq_cond "status" "$st")"
	[ -n "$1" -a "$1" != "all" ] && wstr+=" AND $(str_eq_cond "userName" "$1")"
	q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	((c==0)) && return;
	qa_dbe $c "SELECT host,display,userName,foreignAddress,sessionId\
 FROM sess $wstr ORDER BY startTime DESC;" # ! check order !
}

session_history() {
#params: userName sessionId
	local wstr="" c;
	echo "NX> 127 Session list:"
	echo
	echo "Display Username		Remote IP	   Session ID					   Date				Status"
	echo "------- --------------- --------------- -------------------------------- ------------------- -----------"
	[ -n "$1" -a "$1" != "all" ] && wstr="$(str_eq_cond "userName" "$1")"
	[ -n "$wstr" -a -n "$2" ] && wstr+=" AND "
	[ -n "$2" ] && wstr+=" sessionId='$2'"
	[ -n "$wstr" ] && wstr="WHERE $wstr"
	q_dbe ".mode tabs sess"
	c=$(qa_dbe "SELECT count(sessionId) FROM sess $wstr LIMIT 1;") #"
	((c==0)) && return;
	qa_dbe $c "SELECT display,userName,foreignAddress,sessionId,\
 datetime(startTime,'unixepoch','localtime'),status\
 FROM sess $wstr ORDER BY startTime;" # ! check order !
}

# remove all sessions older than $SESSION_HISTORY seconds in failed/closed.
session_cleanup() {
	local checkTime st wstr;
	[ "$SESSION_HISTORY" -gt "-1" ] || return
	let checkTime=$(date +%s)-$SESSION_HISTORY
	st="Finished|Failed";
	wstr="WHERE $(str_eq_cond "status" "$st") AND startTime < $checkTime"
	q_dbe "DELETE FROM sess $wstr;"
}

session_list_all() { session_list_user "all"; }

session_add() {
#params: <session_id> <options>
	local t k v keys="" vals="";
	shift #sessid present separately for compat only
	t="$@"; t=${t//&/$'\n'}; t=${t//=/ }
	while read k v; do
		keys+="${keys:+,}$k"; vals+="${vals:+,}'$v'"
	done <<< "$t"
	q_dbe "INSERT INTO sess($keys) VALUES($vals);"
}

session_change() {
# <session_id> <parameter> <new_value> [<parameter> <new_value>]...
	local setls="" ssid="$1"; shift
	while [ -n "$1" -a  -n "$2" ]; do
		setls+="${setls:+,}$1='$2'"; shift; shift
	done
	q_dbe "UPDATE sess SET $setls WHERE sessionId='$ssid';"
}

# session_set_status <session_id> <new status>
session_set_status() { session_change "$1" "status" "$2"; }

# session_running <session_id> (? now dublicated session_find_id_user ?)
# return: true if running, false if not
session_running() { session_find_id_user "$1"; }

session_close() {
#param: <session_id>
	if [ "$SESSION_HISTORY" = "0" ] ; then
		q_dbe "DELETE FROM sess WHERE sessionId='$1';"
	else
		session_change "$1" "status" "Finished" "endTime" "$(date +%s)"
	fi
}

session_fail() {
#param: <session_id>
	if [ "$SESSION_HISTORY" = "0" ] ; then
		q_dbe "DELETE FROM sess WHERE sessionId='$1';"
	else
		session_change "$1" "status" "Failed" "endTime" "$(date +%s)"
	fi
}

session_suspend() {
#param: <session_id>
	session_change "$1" "status" "Suspended" "foreignAddress" "-"
}

#
# end of library
#


#
# Main nxserver <-> nxclient communication module
#

# config variables in use:
# COMMAND_MD5SUM COMMAND_NETCAT COMMAND_NXACL COMMAND_NXSHADOWACL
# COMMAND_SESSREG COMMAND_SSH COMMAND_XAUTH
# ENABLE_AUTORECONNECT ENABLE_AUTORECONNECT_BEFORE_140
# ENABLE_EXTERNAL_NXDESKTOP ENABLE_EXTERNAL_NXVIEWER
# ENABLE_LOAD_BALANCE_PREFERENCE ENABLE_LOG_FAILED_LOGINS
# ENABLE_MIRROR_VIA_VNC ENABLE_PASSDB_AUTHENTICATION
# ENABLE_SESSION_SHADOWING_AUTHORIZATION ENABLE_SSH_AUTHENTICATION
# ENABLE_SU_AUTHENTICATION ENABLE_USER_DB ENABLE_USERMODE_AUTHENTICATION
# ENABLE_USESSION LOAD_BALANCE_SERVERS
# NX_ETC_DIR NX_HOME_DIR NX_LICENSE NX_LOGFILE NX_LOG_LEVEL
# NX_LOG_SECURE NX_SESS_DIR NX_VERSION
# SERVER_NAME SESSION_HISTORY SESSION_LIMIT SESSION_USER_LIMIT
# SHARED_CONFS SSHD_PORT

# lost? conf vars:
# COMMAND_GUEST_LOGIN ENABLE_GUEST_LOGIN

# declare global variables:
declare -g cmd CMDLINE server_params proto login_success login_method
declare -g server_mode preferred_host session_count session_count_user
declare -g user2 ENCRYPTION proxy_display sess_display server_host
declare -g oifs rc isdbs NODE_HOSTNAME user

# env variables?
# NX_USERMODE USER

server_mode="0"; [ "$USER" = "nx" ] && server_mode="1"

# We can override usermode via environment var
[ "$NX_USERMODE" = "1" ] && ENABLE_USERMODE_AUTHENTICATION="1"

# When usermode is 1, we only run in server loop
# if nxserver was run without any arguments or just with -c nxserver.
if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
	# do not run in server mode loop regardless of username
	server_mode="0"
	[ -z "$*" -o "$*" = "-c $PATH_BIN/nxserver" ] && server_mode="1"

	# Reread the config files (so that $USER.node.conf get sourced)
	. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf

	# We might need to reactivate this now
	ENABLE_USERMODE_AUTHENTICATION="1"
	# export the necessary variables
	export NX_SESS_DIR="$USER_FAKE_HOME/.nx/db/"
	export NX_LOGFILE="$USER_FAKE_HOME/.nx/temp/nxserver.log"
	mkdir -p $(dirname $NX_LOGFILE)
	open_dbe
	isdbs=""; [ -f $sess_bd ] && isdbs="1"
	attach_db $sess_bd
	init_sess_db
	[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
		-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs

	# we are logged in already
	login_success="1"
	login_method="USERMODE"

	# we do not use loadbalancing mode for usermode
	LOAD_BALANCE_SERVERS=""
fi

if [ "$server_mode" = "1" ]; then

nxnode_login() {
	local PASS="$1"; shift
	NXNODE_TOSEND="$NXNODE_TOSEND" echo $PASS | $PATH_BIN/nxnode-login "$@"
}

# Start!
open_dbe
isdbs=""; [ -f $sess_bd ] && isdbs="1"
attach_db $sess_bd
init_sess_db
[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
	-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs

log 3 "-- NX SERVER START: $@ - ORIG_COMMAND=$SSH_ORIGINAL_COMMAND"

# Get the hostname out of SSH_ORIGINAL_COMMAND
preferred_host=$(rematchfn "host=([^&]*)" "$SSH_ORIGINAL_COMMAND") #"

if [ "$NX_USERMODE" = "1" ]; then
	log 3 "Info: Usermode authentication: Logged in as $USER."
else
	echo_x "HELLO NXSERVER - Version $NX_VERSION $NX_LICENSE"
	# Login stage
	while true; do
		echo_x -n "NX> 105 "
		read cmd
		[ "$cmd" = "" ] && cmd="quit" # FIXME?
		echo_x "$cmd"
		case "$cmd" in
			quit|QUIT)
				echo_x "Quit"; echo_x "NX> 999 Bye"; exit_proc 0;
			;;
			exit|EXIT)
				echo_x "Exit"; echo_x "NX> 999 Bye"; exit_proc 0;
			;;
			bye|BYE)
				echo_x "Bye"; 	echo_x "NX> 999 Bye"; exit_proc 0;
			;;
			hello*|HELLO*)
				proto=$(rematchfn 'Version ([[:digit:][:punct:]]+)' "$cmd") #'
				echo_x "NX> 134 Accepted protocol: $proto"
				if [ "$proto" = "1.3.0" -o "$proto" = "1.3.2" ]; then
					[ "$ENABLE_AUTORECONNECT_BEFORE_140" = "1" ] && \
						ENABLE_AUTORECONNECT="1"
				fi
			;;
			"set auth_mode*"|"SET AUTH_MODE*")
				if [ "$cmd" = "set auth_mode password" -o \
					"$cmd" = "SET AUTH_MODE PASSWORD" ]; then
					echo_x "Set auth_mode: password"
				else
					echo_x "NX> 500 ERROR: unknown auth mode ''"
				fi
			;;
			login|LOGIN)
				login_success="0"
				echo_x -n "NX> 101 User: "; read user2; echo_x $user2;
				echo_x -n "NX> 102 Password: ";
				oifs="$IFS"; export IFS=$'\n';
				read -r -s PASS; export IFS=$oifs; echo_x ""
				log 6 -n "Info: Auth method: "
				# USER already logged in?
				if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
					login_success="1"
					# we have read the user config already above,
					# so we don't get any new information here
					break
				fi
				user=$user2

				# Guest authentication
				if [ "$user" = "NX guest user" ]; then
					if [ "$ENABLE_GUEST_LOGIN" != "1" -o \
								! -x "$COMMAND_GUEST_LOGIN" ]; then
						if [ "$ENABLE_GUEST_LOGIN" != "1" ]; then
							echo_x "NX> 404 ERROR: guest authentication not enabled"
						else
							echo_x "NX> 404 ERROR: $COMMAND_GUEST_LOGIN not correct"
						fi
						echo_x "NX> 999 Bye"
						if [ "$ENABLE_LOG_FAILED_LOGINS" = "1" ]; then
							logger -t nxserver -i -p auth.info \
								"($(whoami)) Failed login for user=$user from IP=$(echo $SSH_CLIENT | awk '{print $1}')"
						fi
						exit_proc 1
					fi
					log 6 -n "guest "
					nxnode_login "" -- guest "" "" "$COMMAND_GUEST_LOGIN" \
						--check 2>&1 >/dev/null
					if [ $? -eq 0 ]; then login_success="1"; login_method="GUEST"; fi
				fi

				# PASSDB based auth
				if [ "$ENABLE_PASSDB_AUTHENTICATION" = "1" -a \
					"$login_success" = "0" ]; then
					log 6 -n "passdb "
					if [ $(passdb_get_crypt_pass "$PASS") = \
						$(passdb_get_pass "$user") ]; then
						login_success="1"; login_method="PASSDB"
					fi
				fi

				# SSH based auth
				if [ "$ENABLE_SSH_AUTHENTICATION" = "1" -a "$login_success" = "0" ]; then
					log 6 -n "ssh "; export COMMAND_SSH;
					nxnode_login "$PASS" -- ssh "$user" "$SSHD_PORT" \
						"$PATH_BIN/nxnode" --check 2>&1 >/dev/null
					if [ $? -eq 0 ]; then login_success="1"; login_method="SSH"; fi
				fi

				# SU based auth
				if [ "$ENABLE_SU_AUTHENTICATION" = "1" -a \
						"$login_success" = "0" ]; then
					log 6 -n "su "
					# experimental don't start nxnode --check
					login_success="1"; login_method="SU";
					#nxnode_login "$PASS" -- su "$user" "" \
					#	"$PATH_BIN/nxnode" --check 2>&1 >/dev/null
					#if [ $? -eq 0 ]; then login_success="1"; login_method="SU"; fi
				fi

				# Check if user in passdb
				if [ "$ENABLE_USER_DB" = "1" ]; then
					log 6 "userdb check"
					passdb_user_exists "$user" || login_success="0"
				fi
				log 6 ""

				if [ "$login_success" = "1" ]; then
					# Reread the config files (so that $USER.node.conf get sourced)
					# dimbor: it's temporary
					# . /usr/bin/nxloadconfig --userconf
					break
				else
					echo_x "NX> 404 ERROR: wrong password or login"
					echo_x "NX> 999 Bye"
					if [ "$ENABLE_LOG_FAILED_LOGINS" = "1" ]; then
						logger -t nxserver -i -p auth.info \
						"($(whoami)) Failed login for user=$user from IP=$(echo $SSH_CLIENT | awk '{print $1}')"
					fi
					exit_proc 1
				fi
			;;
		esac
	done
fi
echo_x "NX> 103 Welcome to: $SERVER_NAME user: $user"

# remove old session infos from history
session_cleanup

#
# call it with: server_get_params $cmd # no ""!
#
server_get_params() {
	shift; server_params=" $@"; server_params=${server_params// --/\&};
	server_params=${server_params//\"/};
	if [ "$server_params" = "" ]; then
		echo_x -n "NX> 106 Parameters: "
		read server_params2; server_params=${server_params2//%2B/+}
		echo_x
	fi
	server_params=${server_params//%20/ };
}

server_nxnode_start() {
	local cmd="$1" user="$2"; shift; shift;

	# Find NODE_HOSTNAME
	NODE_HOSTNAME=""
	CMDLINE="$@"; uniqueid=$(getparam uniqueid)
	[ -z "$uniqueid" ] && uniqueid=$(getparam sessionid)
	[ -z "$uniqueid" ] && uniqueid=$(getparam session_id)
	CMDLINE=$(session_get "$uniqueid")
	NODE_HOSTNAME="$(getparam host)"
	[ -z "$NODE_HOSTNAME" ] && NODE_HOSTNAME="127.0.0.1"
	export NODE_HOSTNAME
	# Use nxnode-login?
	if [ "$login_method" = "SU" ]; then
	    NXNODE_TOSEND="$@" nxnode_login "$PASS" -- \
			su "$user" "" "$PATH_BIN/nxnode" "$cmd" 2>&1 | log_tee
	elif [ "$login_method" = "SSH" ]; then
	    export COMMAND_SSH
	    NXNODE_TOSEND="$@" nxnode_login "$PASS" -- \
			ssh "$user" "$SSHD_PORT" "$PATH_BIN/nxnode" "$cmd" 2>&1 | log_tee
	elif [ "$login_method" = "GUEST" ]; then
		NXNODE_TOSEND="$@" nxnode_login "" -- \
			guest "" "" "$COMMAND_GUEST_LOGIN" "$cmd" 2>&1 | log_tee
	elif [ "$login_method" = "USERMODE" ]; then
	    # we need to unset SSH_* variables so that nxnode
	    # chooses the right accept= value.
	    unset SSH_CLIENT SSH_CLIENT2
	    echo "$@" | $PATH_BIN/nxnode "$cmd" 2>&1 | log_tee
	else
	    echo "$@" | $COMMAND_SSH -l "$user" "$NODE_HOSTNAME" -p $SSHD_PORT \
			-x -2 -i $NX_ETC_DIR/users.id_dsa -o 'PubkeyAuthentication yes' \
			-o 'RSAAuthentication yes' -o 'RhostsAuthentication no' \
			-o 'PasswordAuthentication no' -o 'RhostsRSAAuthentication no' \
			-o 'StrictHostKeyChecking no' $PATH_BIN/nxnode "$cmd" | log_tee
	fi
}

server_add_usession() {
	[ "$ENABLE_USESSION" = "1" ] || return
	$COMMAND_SESSREG -l ":$sess_display" -h "$userip" -a $user 2>&1 | \
		log_error
}

server_remove_usession() {
	[ "$ENABLE_USESSION" = "1" ] || return
	$COMMAND_SESSREG -l ":$sess_display" -h "$userip" -d $user 2>&1 | \
		log_error
}

server_nxnode_echo() {
	log 6 "server_nxnode_echo: $@"
	if [ "$server_channel" = "1" ]; then echo "$@"
	elif [ "$server_channel" = "2" ]; then echo "$@" >&2
	fi
}

server_nxnode_exit_func() {
	log 1 "Info: Emergency-Shutting down due to kill signal ..."
	session_fail $uniqueid
	server_remove_usession
	# remove lock file
	[ -e "/tmp/.nX$sess_display-lock" ] && rm -f /tmp/.nX$sess_display-lock
}

server_nxnode_start_wait() {
# use uplevel: $server_wait_pid $user
	local server_channel=1 kill_wait_pid=1 shadow_cookie
	if [ "$1" = "--startsession" ]; then
		server_add_usession
		# We need to stop sending things when a SIGPIPE arrives
		trap "server_channel=0" SIGPIPE
		trap server_nxnode_exit_func EXIT
		server_nxnode_start "$@" | while read cmd;
		do
			case "$cmd" in
				"NX> 706"*)
					if [ -x "$COMMAND_NXSHADOWACL" ]; then
						# check if we should save the cookie
						$COMMAND_NXSHADOWACL "$user"
						if [ $? -eq 0 ]; then
							shadow_cookie=$(cutfn "$cmd" ":" 1)
							shadow_cookie=${shadow_cookie// /}
							session_change "$uniqueid" "shadowcookie" "$shadow_cookie"
						fi
					fi
				;;
				"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
					case "$cmd" in
						*running*)
							[ "$kill_wait_pid" = "1" ] && kill $server_wait_pid
							kill_wait_pid=0
							log 6 session_set_status $uniqueid "Running"
							session_set_status $uniqueid "Running"
							[ "$server_channel" = "1" ] && server_channel=2
						;;
						*closed*)
							log 6 session_close $uniqueid
							session_close $uniqueid
						;;
						*suspended*)
							[ "$kill_wait_pid" = "1" ] && kill $server_wait_pid
							kill_wait_pid=0
							log 6 session_suspend $uniqueid
							session_suspend $uniqueid
						;;
						*suspending*)
							log 6 session_set_status $uniqueid "Suspending"
							session_set_status $uniqueid "Suspending"
							# we need to stop sending to client as it will have already
							# closed his side of the channel and this will lead to not
							# closed sessions.
							server_channel=0
						;;
						*terminating*)
							log 6 session_set_status $uniqueid "Terminating"
							session_set_status $uniqueid "Terminating"
							# we need to stop sending to client as it will have already
							# closed his side of the channel and this will lead to not
							# closed sessions.
							server_channel=0
						;;
					esac
				;;
				"NX> 1004"*)
					[ "$kill_wait_pid" = "1" ] && kill $server_wait_pid
					kill_wait_pid=0
					session_fail $uniqueid
					server_nxnode_echo "NX> 596 Session startup failed."
					log 4 "NX> 596 Session startup failed."
				;;
			esac

			case $cmd in
				"NX> "*)
					server_nxnode_echo $cmd
				;;
			esac
		done

		trap - EXIT
		trap - SIGPIPE
		# Close it in case the session is still running
		session_running $uniqueid && session_close $uniqueid
		server_remove_usession

		# remove lock file
		[ -e "/tmp/.nX$sess_display-lock" ] && rm -f /tmp/.nX$sess_display-lock

	else # $1 = restore
		server_nxnode_start "$@" | while read cmd
		do
			case "$cmd" in
				"NX> 706"*)
					if [ -x "$COMMAND_NXSHADOWACL" ]; then
						# check if we should save the cookie
						$COMMAND_NXSHADOWACL "$user"
						if [ $? -eq 0 ]; then
							shadow_cookie=$(cutfn "$cmd" ":" 1)
							shadow_cookie=${shadow_cookie// /}
							session_change "$uniqueid" "shadowcookie" "$shadow_cookie"
						fi
					fi
				;;
				"NX> 1006"*|"NX> 1005"*|"NX> 1009"*)
					case "$cmd" in
						*running*)
							[ "$kill_wait_pid" = "1" ] && kill $server_wait_pid
							kill_wait_pid=0
							server_channel=2
						;;
					esac
				;;
				"NX> 1004"*)
					[ "$kill_wait_pid" = "1" ] && kill $server_wait_pid
					kill_wait_pid=0
					# This fail is correct here as somehow the
					# monitor process might have died and we don't
					# want the session to be resumed again.
					session_fail $uniqueid
					server_nxnode_echo "NX> 596 Session startup failed."
					log 4 "NX> 596 Session startup failed."
					break;
				;;
			esac
			case $cmd in
				"NX> "*)
					server_nxnode_echo $cmd
				;;
			esac
		done
	fi
}

server_check_session_count() {
	session_count_user "$user"
	if [ "$session_count" -ge "$SESSION_LIMIT" ]; then
		echo_x "NX> 599 Reached the maximum number of concurrent sessions on this server."
		echo_x "NX> 500 ERROR: Last operation failed."
		return 1
	fi
	if [ "$session_count_user" -ge "$SESSION_USER_LIMIT" ]; then
		echo_x "NX> 599 Server capacity: reached for user: $user"
		echo_x "NX> 500 ERROR: Last operation failed."
		return 1
	fi
	return 0
}

server_loadbalance_random() {
	# Pick one based on "random" algorithm
	local server_lb_hosts=( $LOAD_BALANCE_SERVERS )
	local server_lb_nr_of_hosts=${#server_lb_hosts[@]}
	let server_lb_nr=(RANDOM % server_lb_nr_of_host)
	local server_lb_host=${server_lb_hosts[$server_lb_nr]}
	echo $server_lb_host
}

# run in subshell!
server_loadbalance_round_robin() {
	local server_lb_hosts=( $LOAD_BALANCE_SERVERS )
	local server_lb_nr_of_hosts=${#server_lb_hosts[@]}
	# Atomic incrementation:
	# Enter critical section
	# - Create .lock file
	server_lb_lockfile=$(mktemp "$NX_SESS_DIR/round-robin.lock.XXXXXXXXX")
	trap "rm -f $server_lb_lockfile" EXIT
	i=0
	while [ $i -lt 200 ]; do
		# ln is an atomic operation
		ln $server_lb_lockfile "$NX_SESS_DIR/round-robin.lock" && break
		LANG=C sleep 0.01
		((i++))
	done

	if [ $i -ge 200 ]; then
		log 1 "Load-Balancing: Round-Robin failed to gain lock file in 200 tries. Falling back to random."
		server_loadbalance_random
		return
	fi
	trap "rm -f \"$server_lb_lockfile\" \"$NX_SESS_DIR/round-robin.lock\"" EXIT

	# Lock held
	server_lb_nr=$(cat $NX_SESS_DIR/round-robin 2>/dev/null)
	let server_lb_nr=(server_lb_nr+1)%server_lb_nr_of_hosts
	echo $server_lb_nr >$NX_SESS_DIR/round-robin

	# Exit critical section
	rm -f "$server_lb_lockfile" "$NX_SESS_DIR/round-robin.lock"
	trap - EXIT

	server_lb_host=${server_lb_hosts[$server_lb_nr]}
	echo $server_lb_host
}

server_loadbalance_load() {
	local server_lb_max=0 server_lb_host="" server_lb_load;
	export PATH_BIN
	for i in $LOAD_BALANCE_SERVERS; do
		server_lb_load=$($COMMAND_NXCHECKLOAD $i)
		[ -z "$server_lb_load" ] && continue
		if [ $server_lb_load -gt $server_lb_max ]; then
			server_lb_max=$server_lb_load
			server_lb_host=$i
		fi
	done
	echo $server_lb_host
}

server_loadbalance() {
	local server_host="127.0.0.1"
	if [ -n "$LOAD_BALANCE_SERVERS" ]; then
		server_host=""
		if [ -n "$preferred_host" -a "$ENABLE_LOAD_BALANCE_PREFERENCE" = "1" ]; then
			stringinstring " $preferred_host " " $LOAD_BALANCE_SERVERS " && \
				server_host="$preferred_host"
		fi
		# Fallback if still empty
		if [ -z "$server_host" ]; then
			case "$LOAD_BALANCE_ALGORITHM" in
				random)
					server_host=$(server_loadbalance_random)
				;;
				round-robin)
					server_host=$(server_loadbalance_round_robin)
				;;
				load)
					server_host=$(server_loadbalance_load)
				;;
			esac
		fi
		[ -z "$server_host" ] && server_host="127.0.0.1"
		[ -n "$server_host" ] && log 5 "Info: Load-Balancing (if possible) to $server_host ..."
	fi
	echo "$server_host"
}

server_startrestore_session() {
	local action="$1" params permission shadow_dialog_pid sess_lockfile
	local agent_display samba_display cups_display media_display
	local server_pid server_wait_pid new_params
	local pass enc_pass new_pass1 new_pass2 real_pass

	server_get_params $cmd
	params="$server_params&clientproto=$proto&login_method=$login_method"
	CMDLINE=$params; set_vars_from_cmdstr "$CMDLINE"
	echo_x

	# special shadowed type
	[ "$action" != "start" -a "$type" = "vnc" ] && action="shadow"

	if [ "$action" = "shadow" ]; then
		action="start"
		uniqueid=$restore
		[ -z "$uniqueid" ] && uniqueid=$id # 1.4.0-5 compatibility
		CMDLINE=$(session_get "$uniqueid" 2>/dev/null)

		shadowdisplay=$display; shadowhost=$host; shadowuser=$userName
		[ "$shadowcookie" = "none" ] && shadowcookie=""
		if [ -z "$shadowdisplay"  ]; then
			# check for DESKTOP_SHARING_IDS
			shadowdisplay=$(rematchfn "$uniqueid=([^ ]*)" "$DESKTOP_SHARING_IDS") #"
			shadowhost="127.0.0.1"
		fi
		if [ -z "$shadowdisplay" ]; then
			echo_x "NX> 596 Could not find shadowed session $uniqueid. Session failed."
			echo_x "NX> 596 Sharing: $DESKTOP_SHARING_IDS"
			return 1
		fi
		[ "$shadowhost" = "127.0.0.1" ] && shadowhost=""

		# not the same user? So we have a shadow cookie, we add to xauth
		if [ -n "$shadowcookie" -a \
				"$ENABLE_SESSION_SHADOWING_AUTHORIZATION" = "1" ]; then
			# Ask for permission first:
			echo_x "NX> 726 Asking user for authorization to attach to session"
			export XAUTHORITY=".Xauthority-$RANDOM-$$"
			$COMMAND_XAUTH add "$shadowhost:$shadowdisplay" MIT-MAGIC-COOKIE-1 \
				"$shadowcookie" >/dev/null 2>&1
			permission=$(
				$PATH_BIN/nxdialog -display $shadowhost:$shadowdisplay \
					-dialog yesno -caption "Authorization Request" \
					-message "Do you want to allow $user to shadow your session?" 2>/dev/null &
				shadow_dialog_pid=$!
				i=0
				while kill -0 $shadow_dialog_pid 2>/dev/null; do
					((i++))
					[ $I -gt "$AGENT_STARTUP_TIMEOUT" ] && \
						kill $shadow_dialog_pid 2>/dev/null
					sleep 1
				done
				echo "no"
			)
			$COMMAND_XAUTH remove "$shadowhost:$shadowdisplay"
			rm -f "$XAUTHORITY"

			if [ "$permission" = "no" ]; then
				# User answered NO
				echo_x "NX> 596 Error: Authorization refused by user: $shadowuser."
				return 1
			fi
		fi

		params+="&shadowdisplay=$shadowdisplay&shadowhost=$shadowhost&\
shadowcookie=$shadowcookie&shadowuser=$shadowuser"
		CMDLINE=$params
	fi
	if [ "$action" = "start" ]; then

		# Hack for external RDP/RFB agents
		if [ "$ENABLE_EXTERNAL_NXDESKTOP" = "1" -a "$type" = "windows" ]; then
			type="windows-helper"
			params+="&type=$type&freenx_export_agents=1"
			CMDLINE=$params
		fi

		if [ "$ENABLE_EXTERNAL_NXVIEWER" = "1" -a \
				"$type" = "vnc" ]; then
			type="vnc-helper"
			application="$PATH_BIN/nxviewer_helper"
			params+="&type=$type&application=$application&freenx_export_agents=1"
			CMDLINE=$params
		fi
	fi
	# If we can't get the userip and SSHD_CHECK_IP is set to 1
	# we bail out.
	if [ -z "$SSH_CLIENT" -a -z "$SSH2_CLIENT" ]; then
		if [ "$SSHD_CHECK_IP" = "1" ]; then
			echo_x "NX> 596 Session startup failed. (Missing SSH_CLIENT environment variable)"
			return 1
		else
			log 2 "Warning: Failed to determine the client IP."
			log 2 "Warning: The SSH_CLIENT or SSH2_CLIENT variable was not provided by SSHD."
			log 2 "Warning: Please set SSHD_CHECK_IP=1 if you want to refuse the connection."
		fi
	fi
	export ENCRYPTION=$encryption
	if [ "$ENABLE_FORCE_ENCRYPTION" = "1" -a "$ENCRYPTION" != "1" ]; then
			echo_x "NX> 596 Unencrypted sessions are not allowed."
			return 1
	fi

	if [ -x "$COMMAND_NXACL" ]; then
			log 3 "Info: Using $COMMAND_NXACL to change session parameters or deny session."
			new_params=$($COMMAND_NXACL "$CMDLINE")
			if [ $? -ne 0 ]; then
				echo_x "NX> 596 The session failed due to a nxacl policy setting: $new_params"
				return 1
			fi

			# check if the acl input did make sense
			if [ -n "$new_params" ]; then
				params=$new_params; CMDLINE=$params
			fi
	fi

	# check if there is a suspended session, which we could resume
	if [ "$ENABLE_AUTORECONNECT" = "1" -a "$action" = "start" ]; then
		restore=$(session_get_user_suspended "$user" "Suspended")
		if [ -n "$restore" ]; then
			params+="&restore=$restore"
			CMDLINE=$params
			action="resume"
		fi
	fi

	# as only $SSH_CLIENT or $SSH2_CLIENT will be set, this should work
	userip=$(rematchfn "($ip4_pattern)" "$SSH_CLIENT $SSH2_CLIENT") #"
	[ -z "$userip" ] && userip="*"
	if [ "$action" = "start" -o "$action" = "shadow" ]; then
		server_check_session_count || return 1

		# Possibly do loadbalancing
		server_host=$(server_loadbalance)

		# start nxnode
		sess_display=$DISPLAY_BASE
		((sess_display_limit=DISPLAY_BASE+DISPLAY_LIMIT))
		# stupid but working algo ...

		while true; do
			while [ -e /tmp/.X$sess_display-lock -o \
					-e "/tmp/.nX$sess_display-lock"  -o \
					-e "/tmp/.X11-unix/X$sess_display" ]; do
				((sess_display++))
			done

			# Check if there is already an agent running on that display on that host
			((agent_display=sess_display+6000))
			if $COMMAND_NETCAT -z "$server_host" $agent_display 2>/dev/null; then
				log 2 "Warning: Stray nxagent without .nX$sess_display-lock found on host:port $server_host:$agent_display."
				((sess_display++))
				continue
			fi

			((proxy_display=sess_display+4000))
			if $COMMAND_NETCAT -z "$server_host" $proxy_display 2>/dev/null; then
				log 2 "Warning: nxagent proxy without .nX$sess_display-lock found on host:port $server_host:$agent_display."
				((sess_display++))
				continue
			fi

			# Now check for the other enabled services
			((samba_display=$sess_display+3000))
			if [ "$samba" = 1 ] && ( $COMMAND_NETCAT -z \
					"$server_host" $samba_display 2>/dev/null ); then
				log 2 "Warning: Skipping $server_host:$agent_display as samba port is not free."
				((sess_display++))
				continue
			fi

			((media_display=sess_display+7000))
			if [ "$media" = 1 ] && ( $COMMAND_NETCAT -z \
					"$server_host" $media_display 2>/dev/null ); then
				log 2 "Warning: Skipping $server_host:$agent_display as media port is not free."
				((sess_display++))
				continue
			fi

			((cups_display=sess_display+9000))
			if [ "$cups" = 1 ] && ( $COMMAND_NETCAT -z \
					"$server_host" $cups_display 2>/dev/null ); then
				log 2 "Warning: Skipping $server_host:$agent_display as cups port is not free."
				((sess_display++))
				continue
			fi

			sess_lockfile=$(mktemp "/tmp/.nX$sess_display-lock.XXXXXXXXX")
			# ln is an atomic operation
			ln "$sess_lockfile" "/tmp/.nX$sess_display-lock" 2>/dev/null && break
		done

		rm -f "$sess_lockfile"
		if [ "$sess_display" -gt "$sess_display_limit" ]; then
			echo_x "NX> 596 Error: Display limit exceeded. Please remove some files from /tmp/.X*-lock."
			rm -f "/tmp/.nX$sess_display-lock"
			return
		fi
		display=$sess_display
		uniqueid=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
		uniqueid=${uniqueid%% *}; uniqueid=${uniqueid^^}
		params+="&user=$user&userip=$userip&uniqueid=$uniqueid&\
display=$display&host=$server_host"
		log_secure "6" "$params"

		# now update the session listing
		sessionRootlessMode=0
		[ "$rootless" = "1" ] && sessionRootlessMode=1
		CMDLINE="a=b&$params"
		session_add $uniqueid "sessionName=$session&display=$display&\
status=Running&startTime=$(date +%s)&foreignAddress=$userip&\
sessionRootlessMode=$sessionRootlessMode&type=$type&sessionId=$uniqueid&\
creationTime=$(date +%s)&userName=$user&serverPid=$server_pid&\
screeninfo=$screeninfo&geometry=$geometry&host=$server_host&shadowcookie=none"
	else
		uniqueid=$restore
		[ -z "$uniqueid" ] && uniqueid=$id # 1.4.0-5 compatibility
		session_change "$uniqueid" "foreignAddress" "$userip"

		CMDLINE=$(session_get "$uniqueid");
		display=$(getparam display); host=$(getparam host)
		params+="&user=$user&userip=$userip&\
uniqueid=$uniqueid&display=$display&status=$status"
		sess_display=$display
		server_host=$host
		[ -z "$server_host" ] && server_host="127.0.0.1"

		if [ "$ENABLE_ADVANCED_SESSION_CONTROL" = "1" ]; then
			CMDLINE="$params"
			case "$session" in
				"add "*)
					server_nxnode_start --applicationsession "$user" "$params"
					echo_x "Quit"
					echo_x "NX> 999 Quit"
					exit_proc 1
				;;
			esac
		fi
	fi

	# now start the node
	sleep $AGENT_STARTUP_TIMEOUT &
	server_wait_pid=$!
	( server_nxnode_start_wait --"$action"session $user "$params" ) &
	server_pid=$! # do we need this?
	disown $server_pid
	wait $server_wait_pid 2>/dev/null
	if [ $? -eq 0 ]; then
		# Something went wrong ...
		[ "$action" = "start" ] && session_fail $uniqueid
		echo_x "NX> 1004 Error: Session did not start."
		echo_x "NX> 596 Session $action failed."
		echo_x "NX> 999 Bye"
		# FIXME: Send node signal to terminate
		exit_proc 1
	fi
}

# Session stage
while true; do
	echo_x -n "NX> 105 "
	unset cmd
	read cmd 2>/dev/null
	# FIXME?
	[ "$cmd" = "" ] && cmd="quit"
	# Logging
	case "$cmd" in
		startsession*|restoresession*|addmount*|addprinter*)
			echo_secure "$cmd"
			log_secure "4" "$cmd"
		;;
		*)
			echo "$cmd"
			log "4" "$cmd"
		;;
	esac
	case "$cmd" in
		quit|QUIT)
			echo_x "Quit"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		exit|EXIT)
			echo_x "Exit"
			echo_x "NX> 999 Bye"
			exit_proc 0
		;;
		bye|BYE)
			echo_x "Bye" 1>&2
			echo_x "NX> 999 Bye" 1>&2
			if [ "$ENCRYPTION" = "1" ]; then
				((proxy_display=sess_display+4000))
				$COMMAND_NETCAT $server_host $proxy_display 2>/dev/null; rc=$?
				# kill our parent sshd process
				kill $PPID
				exit_proc $rc
			else
				echo_x "NX> 1001 Bye."
			fi
		;;
		startsession*)
			server_startrestore_session "start"
		;;
		list*)
			server_get_params $cmd; params=$server_params
			CMDLINE=$params; set_vars_from_cmdstr "$CMDLINE"


			if [ "$status" = "Suspended" -a -n "$screeninfo" ]; then
				session_list_user_suspended "$user" "Suspended" \
					"$screeninfo" "$type"
			elif [ "$status" = "Suspended,Running" -o "$status" = "Suspended" ]; then
				# disabled due to problems with 1.4.0-5 client
				#session_list_user_suspended "$user" 'Suspended$|^status=Running$' "$(getparam geometry)" "$(getparam type)" | log_tee
				session_list_user_suspended "$user" 'Suspended' "$geometry" "$type"
			elif [ "$status" = "suspended,running" -o "$status" = "suspended" ]; then
				# since 1.5.0
				status=${status/,/|}; status=${status/suspended/Suspended};
				status=${status/running/Running};
				[ "$ENABLE_SHOW_RUNNING_SESSIONS" = "0" ] && status="Suspended"
				session_list_user_suspended "$user" "$status" "$geometry" "$type"
			elif [ "$type" = "shadow" ]; then
				session_list_user_suspended ".*" "Suspended|Running" "" "shadow"
			else
				session_list_user "$user" | log_tee
			fi
		;;
		suspend*)
			server_get_params $cmd;	params=$server_params
			CMDLINE=$params; set_vars_from_cmdstr "$CMDLINE"
			if session_find_id_user "$sessionid" "$user"; then
				server_nxnode_start --suspend "$user" "$params"
			fi
		;;
		terminate*)
			server_get_params $cmd; params=$server_params
			CMDLINE=$params;
			if session_find_id_user "$(getparam sessionid)" "$user"; then
				server_nxnode_start --terminate "$user" "$params"
			fi
		;;
		restoresession*)
			server_startrestore_session "resume"
		;;
		attachsession*)
			server_startrestore_session "shadow"
		;;
		passwd)
			echo_x "NX> 113 Changing password of user '$user'"
			echo_x -n "NX> 102 Current password:"
			read -r -s pass
			enc_pass=$(passdb_get_crypt_pass "$pass")
			real_pass=$(passdb_get_pass "$user")
			echo_x
			if [ "$enc_pass" = "$real_pass" ]; then
				echo_x -n "NX> 102 Password:"
				read -r -s new_pass1
				if [ ${#new_pass1} -lt 5 ]; then
					echo_x "NX> 500 ERROR: incorrect password format, password must be long at least five characters"
					continue
				fi
				echo_x
				echo_x -n "NX> 102 Confirm password:"
				read -r -s new_pass2
				echo_x
				if [ "$new_pass1" = "$new_pass2" ]; then
					enc_pass=$(passdb_get_crypt_pass "$new_pass1")
					passdb_chpass "$user" "$enc_pass"
					echo_x "NX> 114 Password of user '$user' changed"
				else
					echo_x "NX> 537 ERROR: passwords do not match"
				fi
			else
				echo_x "NX> 500 ERROR: current password doesn't match"
			fi
		;;
		addmount*)
			server_get_params $cmd
			params="$server_params"
			( server_nxnode_start --smbmount "$user" "$params" >/dev/null 2>&1 ) &
		;;
		addprinter*)
			server_get_params $cmd
			params="$server_params"
			( server_nxnode_start --addprinter "$user" "$params" >/dev/null 2>&1 ) &
		;;
		*)
			# disabled for 1.4.0-5 snapshot client
			#echo_x "NX> 503 Error: undefined command: '$cmd'"
		;;
	esac
done

fi # server_mode == "1"

#
# End of Main nxserver <--> nxclient communication module
#

################### PACKAGE cmd.bm ############################

#
# library functions for nxserver-commandline cmds
#

# Policy: All functions and variables need to start with CMD_ / cmd_
# Needed global vars: $NX_VERSION, $NX_LICENSE, $NX_ETC_DIR, $PATH_BIN,
#			$NX_HOME_DIR, $SSH_AUTHORIZED_KEYS
# Needed package: passdb
cmd_usage() {
	echo "NXSERVER - Version $NX_VERSION $NX_LICENSE" 1>&2
	echo "Usage: nxserver <option>" 1>&2

	if [ "$1" = "root" ]; then
		echo "--adduser <user>: Add a new user" 1>&2
		echo "--passwd <user>: Change password of <user>" 1>&2
		echo "--deluser <user>: Remove a user from nx" 1>&2
		echo "--listuser: List enabled users" 1>&2
		echo "" 1>&2
		echo "--start: Start the nx server" 1>&2
		echo "--stop: Stop the nx server" 1>&2
		echo "--status: Show status of nx server" 1>&2
		echo "--restart: Restart the nx server. (start,stop)" 1>&2
		echo "" 1>&2
		echo "--list [ user | sessionid ]: List running sessions of user or sessionid " 1>&2
		echo "--history [ user | sessionid | clear ]: Show history [ of user | sessionid ] or clear the history" 1>&2
		echo "--terminate <user | :display | sessionid>: Terminate the session pointed to by" 1>&2
		echo "       sessionid or display, or all sessions of the specified user." 1>&2
		echo "       Use * for all sessions." 1>&2
		echo "--force-terminate: Like terminate, but removes also session info." 1>&2
		echo "--suspend <user | :display | sessionid>: Suspend the session pointed to by" 1>&2
		echo "       sessionid or display, or all sessions of the specified user." 1>&2
		echo "       Use * for all sessions." 1>&2
		echo "--cleanup: Terminates all running sessions. Useful after power-outage."
		echo "" 1>&2
		echo "--broadcast <message>: Send a message to all users" 1>&2
		echo "--send <user | :display | sessionid> <message>: Send a message to the specified user or sessionid" 1>&2
	else
		echo "--passwd: Change password" 1>&2
	fi
	exit_proc 1
}


cmd_abort() {
	echo -e "NX> 500" "$@" 1>&2
	echo "NX> 999 Bye" 1>&2
	exit_proc 1
}

cmd_abort_success() {
	echo "NX> 500" "$@" 1>&2
	echo "NX> 999 Bye" 1>&2
	exit_proc 0
}

cmd_user_passwd() {
	echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
	echo "Sorry: Password changing for user is _not_ implemented, yet."
	echo "Please login to NX-Server to change password"
	echo "or ask your local system administrator."
	#echo "NX> 113 Changing password of user '$user'"
	#echo "Old password:"
	#read -s OLDPASS
	#echo "New password:"
	#read -s NEWPASS1
	#echo "Repeat:"
	#read -s NEWPASS2
}

cmd_passwd() {
	local cmd_chuser=$2 cmd_newpass cmd_enc_pass
	egrep -q "^$cmd_chuser:" $NX_ETC_DIR/passwords || \
		cmd_abort "Error: User $cmd_chuser not found in database."
	echo -n "New password: "
	read -r -s cmd_newpass
	echo
	cmd_enc_pass=$(passdb_get_crypt_pass "$cmd_newpass")
	passdb_chpass "$cmd_chuser" "$cmd_enc_pass"
	echo "Password changed."
}

cmd_checkpassdb() {
	if [ "$ENABLE_PASSDB_AUTHENTICATION" != "1" ]; then
		cmd_abort "Error: The passdb function is not activated in node.conf.\n\nMost probably your FreeNX setup will work out of the box without this\nfunctionality and you've been misleaded by an old tutorial or old\ndocumentation to do this step.\n\nIf however you really need this functionality, just set\nENABLE_PASSDB_AUTHENTICATION=\"1\" in node.conf.\n"
	fi
	return 0
}

cmd_adduser() {
	local cmd_chuser=$2
	[ ${#cmd_chuser} -ge 32 ] && \
		cmd_abort "Error: User $cmd_chuser must be shorter than 32 characters."
	egrep -q "^$cmd_chuser:" $NX_ETC_DIR/passwords && \
		cmd_abort "Error: User $cmd_chuser already in database."
	getent passwd "$cmd_chuser" >/dev/null || \
		cmd_abort "Error: User $cmd_chuser not existing on local system. Can't add."
	passdb_add_user "$cmd_chuser"
}

cmd_deluser() {
	local cmd_chuser=$2
	egrep -q "^$cmd_chuser:" $NX_ETC_DIR/passwords || \
		cmd_abort "Error: User $cmd_chuser not found in database."
	passdb_remove_user "$cmd_chuser"
}

cmd_listuser() {
	echo "NX> 146 NX users list"
	echo
	echo "Username"
	echo "---------------"
	echo
	passdb_list_user
	echo
}

cmd_start() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && \
		cmd_abort_success "ERROR: Service already running"
	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled \
		$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS
	echo "NX> 122 Service started"
}

cmd_stop() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || \
	cmd_abort_success "Service was already stopped"
	mv $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS \
		$NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS.disabled
	echo "NX> 123 Service stopped"
}

cmd_status() {
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] && \
		echo "NX> 110 NX Server is running"
	[ -f $NX_HOME_DIR/.ssh/$SSH_AUTHORIZED_KEYS ] || \
		echo "NX> 110 NX Server is stopped"
}

cmd_restart() { cmd_stop; cmd_start; }

cmd_parse_2_params()
{
	local cmd_params;
	if [ ${#1} -eq 32 ]; then cmd_params="sessionid=sessionId{$1}"
	elif [ "$1" != "" ]; then cmd_params="user=$1"
	fi
	echo "$cmd_params"
}

cmd_parse_3_params()
{
	local cmd_params;
	if [ ${#1} -eq 32 ]; then
		cmd_params=$(session_find_id $1)
		[ -n "$cmd_params" ] || cmd_abort "Error: Session $1 could not be found."
	elif [ "${1:0:1}" = ":" ]; then
		cmd_params=$(session_find_display "${1:1}")
		[ -n "$cmd_params" ] || cmd_abort "Error: No running sessions found for display $1."
	elif [ "$1" = "*" ]; then
		cmd_params=$(session_find_all)
		[ -n "$cmd_params" ] || cmd_abort "Error: No running sessions found."
	elif [ "$1" != "" ]; then
		cmd_params=$(session_find_user "$1")
		[ -n "$cmd_params" ] || cmd_abort "Error: No running sessions found for user $1."
	else cmd_abort "Error: Not enough parameters."
	fi
	echo "$cmd_params"
}

cmd_list_suspended() {
	local cmd_params=$(cmd_parse_2_params "$2")
	[ -n "$2" -a -z "$cmd_params" ] && exit_proc 1
	case $cmd_params in
		user=*)
			session_list_user_suspended $2 "Suspended"
		;;
	esac
}
cmd_list() {
	local cmd_params=$(cmd_parse_2_params "$2")
	[ -n "$2" -a -z "$cmd_params" ] && exit_proc 1
	case $cmd_params in
		user=*)
			session_list_user $2
		;;
		sessionid=*)
			session_list $2
		;;
		*)
			session_list_all
		;;
	esac
}

cmd_history_clear() {
	q_dbe "DELETE FROM sess WHERE status IN ('Finished','Failed');"
}

cmd_history() {
	local cmd_params user="" sessid=""
	if [ "$2" = "clear" ]; then cmd_history_clear; return; fi
	cmd_params=$(cmd_parse_2_params "$2")
	case $cmd_params in
		user=*)
			user="$2"
		;;
		sessionid=*)
			sessid="$2"
		;;
	esac
	session_history "$user" "$sessid"
}

cmd_execute() {
	local cmd_host="$1" cmd_user="$2" cmd_cmd="$3"
	if [ "$ENABLE_USERMODE_AUTHENTICATION" = "1" ]; then
		sh -c "$cmd_cmd"
	elif [ "$cmd_host" = "127.0.0.1" -o "$cmd_host" = "localhost" ]; then
		/bin/su - "$cmd_user" -c "$cmd_cmd"
	else
		ssh "$cmd_host" su - "$cmd_user" -c "'$cmd_cmd'"
	fi
}

cmd_terminate_or_send() {
	local cmd="$1" cmd_params cmd_sessionid cmd_display cmd_user cmd_type \
		cmd_status cmd_host;
	if [ "$cmd" = "--broadcast" ]; then
		cmd_params=$(session_find_all)
		[ -z "$cmd_params" ] && cmd_abort "Error: No running session could be found."
	else
		cmd_params=$(cmd_parse_3_params "$2")
		[ -z "$cmd_params" ] && exit_proc 1
		shift
	fi
	shift

	while read CMDLINE; do
		[ -z "$CMDLINE" ] && continue
			cmd_sessionid=$(getparam sessionId)
			cmd_display=$(getparam display)
			cmd_user=$(getparam userName)
			cmd_type=$(getparam type)
			cmd_status=$(getparam status)
			cmd_host=$(getparam host)

			# is it a "good" session?
			case "$cmd" in
			--suspend)
				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
				then
					echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --suspend"
				fi
			;;
			--terminate)
				echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --terminate"
			;;
			--force-terminate)
				echo "sessionid=$cmd_sessionid" | cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxnode --terminate"
				session_close $cmd_sessionid
			;;
			--send|--broadcast)
				# is it a "good" session?
				if [ "$cmd_status" = "Running" ] && stringinstring "unix-" "$cmd_type"
				then
					cmd_execute "$cmd_host" "$cmd_user" "$PATH_BIN/nxdialog --dialog ok --caption \"NX Administrator Message\" --message \"$@\" -display \":$cmd_display\" &"
				fi
			esac
	done <<< "$cmd_params"
}

if [ "$NX_LOG_LEVEL" -ge "1" -a ! -f "$NX_LOGFILE" ]; then
	touch "$NX_LOGFILE" >/dev/null 2>&1
fi
open_dbe
isdbs=""; [ -f $sess_bd ] && isdbs="1"
attach_db $sess_bd
init_sess_db
[[ -z "$isdbs" && ( -d "$NX_SESS_DIR/closed" || \
	-d "$NX_SESS_DIR/failed" ) ]] && migrate_old_conf_dirs
if [ "$UID" -eq "0" ]; then
	chown nx "$NX_LOGFILE" >/dev/null 2>&1; chmod 660 "$NX_LOGFILE"
	chown nx "$sess_bd" >/dev/null 2>&1; chmod 660 "$sess_bd"
fi

#
# normal user available functions
if [ $UID -ne 0 -a "$ENABLE_USERMODE_AUTHENTICATION" != "1" ]; then
	[ "$1" = "--agent" ] && exec $PATH_BIN/nxnode "$@"
	[ "$1" != "--passwd" ] && cmd_usage
	cmd_user_passwd
	exit_proc 0
fi

#
# root mode available functions
[ $# -lt 1 ] && cmd_usage "root"
[ "$1" = "--help" ] && cmd_usage "root"

if [ "$1" = "--version" ]; then
  echo "NXSERVER - Version $NX_VERSION $NX_LICENSE"
  exit_proc 0
fi

cmd=$1
echo "NX> 100 NXSERVER - Version $NX_VERSION $NX_LICENSE"
case $cmd in
	#
	# User functions ...
	--passwd)
		cmd_checkpassdb
		cmd_passwd "$@"
	;;
	--adduser|--useradd)
		cmd_checkpassdb
		cmd_adduser "$@"
	;;
	--deluser|--userdel)
		cmd_checkpassdb
		cmd_deluser "$@"
	;;
	--listuser|--userlist)
		cmd_checkpassdb
		cmd_listuser
	;;
	--start)
		cmd_start
	;;
	--stop)
		cmd_stop
	;;
	--status)
		cmd_status
	;;
	--restart)
		cmd_restart
	;;
	--list)
		cmd_list "$@"
	;;
	--list-suspended)
		cmd_list_suspended "$@"
	;;
	--history)
		cmd_history "$@"
	;;
	--terminate|--suspend|--force-terminate)
		cmd_terminate_or_send "$@"
	;;
	--cleanup)
		cmd_terminate_or_send "--force-terminate" "*"
	;;
	--send|--broadcast)
		cmd_terminate_or_send "$@"
	;;
	*)
		cmd_abort "Error: Function $cmd not implemented yet."
esac
echo "NX> 999 Bye"
