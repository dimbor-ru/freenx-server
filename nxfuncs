#!/bin/bash
#
# Copyright (c) 2020 by Dmitry Borisov <i@dimbor.ru>
#
# License: GPL, version 2
#
# ========================================================================

ip4_pattern='[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+'
num_pattern='[+-]?[0-9]+([.][0-9]+)?'

# following two functions are Copyright by Klaus Knopper
stringinstring() { case "$2" in *$1*) return 0;; esac; return 1; }

getparam() {
#args: <instring> <param_name> [recode_hex_%NN]
# Reread given line; echo last parameter's argument or return false.
	local pattern=".*&$2=([^&]*)" str="&$1" r;
	[[ "$str" =~ $pattern ]]; r=${BASH_REMATCH[1]}
	[ -n "$3" ] && echo -e "${r//\%/\\x}" || echo "$r"
	[ "$BASH_REMATCH" != "" ]
}

trim() {
	local v="$*"; v=${v#${v%%[![:space:]]*}};
	v=${v%${v##*[![:space:]]}}; echo -n "$v"
}

cutfn() {
#args: line delim field_num_start_at_0
	local IFS="$2"; local a=($1);
	#echo "${a[($3)]}" # negative values works on all systems?
	echo "${a[@]:($3):1}"
}

rematchfn(){
#args: (pattern) <text> [match_num=0] [reversive]
# if match_num == "all" returns all found matches delimited by newlines
	local pat n OIFS a ntl nr a r r1 res;
	pat="$1"; [ -z "$3" -o "$3" = "all" ] && n=0 || n="$3"
	OIFS=$IFS; local IFS=$'\n'; a=($2); IFS=$OIFS;
	ntl=${#a[@]}; nr=0; r=(); res="";
	if [ -z "$4" ]; then
		for ((i=0;i<$ntl;i++)) {
			[[ "${a[$i]}" =~ $pat ]] || continue
			((nr++)); r+=(${BASH_REMATCH[1]})
			[ "$nr" = "$n" ] && break
		}
	else
		for ((i=$ntl;i>=0;i--)) {
			[[ "${a[$i]}" =~ $pat ]] || continue
			((nr++)); r+=(${BASH_REMATCH[1]})
			[ "$nr" = "$n" ] && break
		}
	fi
	if [ "$3" = "all" ]; then
		for r1 in ${r[@]}; do res+="${res:+$'\n'}$r1"; done
		echo "$res"
	else echo "${r[($n)]}"
	fi
	[ "$nr" != "0" ]
}

set_vars_from_params() {
#args: <instring> <varnames> [var_prefix=""] [%hex_recode=""]
# varnames_list_delimited_by_spaces_or_commas
	local vnames vn vv;
	vnames="${2//,/ }"
	for vn in $vnames; do
		vv=$(getparam "$1" $vn $4); #[ -z "$vv" ] && continue;
		declare -g $4$vn="$vv"
	done
}

set_vars_from_ampstr() {
#param: <ampstr> [var_prefix=""] [%hex_recode=""]
	local kv vn vv;
	local IFS='&'; local -a a=($1) a2;
	for kv in ${a[@]}; do
		IFS='=' a2=($kv); vn=${a2[0]}; [ -z "$vn" ] && continue;
		vv=${a2[1]}; [ -n "$3" ] && vv=$(echo -e  "${vv//\%/\\x}")
		declare -g $2$vn=$vv
	done
}

# ===========================================================================
# sqlite3 functions
declare -g sq_cmd="/usr/bin/sqlite3";
declare -g DBE_PID="" DBE_PIDS_FILE="";

q_dbe() { echo "$@" >/proc/$DBE_PID/fd/0; }

qa_dbe() {
#args: [count_strings_in_answer] <query_string> ...
	local c_max=1 c=1 r res=""
	if [ "$1" -gt "0" 2>/dev/null ]; then c_max="$1"; shift; fi
	echo "$@" >/proc/$DBE_PID/fd/0
	while ((c<=c_max)); do
		read r </proc/$DBE_PID/fd/1
		res+="${res:+$'\n'}$(trim "$r")"
		((c++))
	done
	echo "$res"
}

ctl_dbe() {
#arg: <pid_of_parent>
	coproc $sq_cmd -batch
	echo "$COPROC_PID" > "/tmp/nxdbe-$1"
	wait $COPROC_PID
}

open_dbe() {
#arg: <pid_of_parent>
#ret: 0 if dbe started, 1 - dbe connected, 2 - error;
	#echo "open dbe start $1"
	local new_dbe="" pids;
	if [ -z "$DBE_PID" ]; then
		if [ -r "$DBE_PIDS_FILE" ]; then
			pids=($(< "$DBE_PIDS_FILE")); DBE_PID=${pids[0]};
		else new_dbe="1"
		fi
	fi
	if [ -n "$DBE_PID" ]; then
		if kill -0 $DBE_PID 2>/dev/null; then
			echo "$1" >> "$DBE_PIDS_FILE"; return 1;
		else
			DBE_PID=""; rm -f "$DBE_PIDS_FILE"; new_dbe="1";
			#echo "rm old pidfile";
		fi
	fi
	if [ -n "$new_dbe" ]; then
		local dbc_pid="";
		(ctl_dbe $1) &
		dbc_pid=$!; disown $dbc_pid;
		local cntr=200;
		DBE_PIDS_FILE="/tmp/nxdbe-$1"
		while [ ! -e "$DBE_PIDS_FILE" ]; do sleep 0.01s; ((cntr--)); ((cntr<=0)) && break; done
		#echo "create dbe $((200-cntr))0 ms"
		DBE_PID=$(< "$DBE_PIDS_FILE"); echo "$1" >> "$DBE_PIDS_FILE"
		q_dbe ".timeout 500";
		q_dbe ".separator '&'" # not work with later attached tables after '.mode csv tname'
		#q_dbe "PRAGMA journal_mode = WAL;" # causes error on keyslst_for_user() now
		return 0
	fi
	return 2
}

attach_db() {
#args: <filename>
	local dbname=${1##*\/}; dbname=${dbname%.*}
	q_dbe "ATTACH DATABASE '$1' AS $dbname;"
}

close_dbe() {
#arg: <pid_of_parent>
# if arg empty close ultimately
	#echo "dbe close start - $1; $DBE_PIDS_FILE; $DBE_PID"
	[ -z "$DBE_PID" ] && return
	local pids="" i;
	if [ -n "$1" ]; then
		[ -r "$DBE_PIDS_FILE" ] && pids=($(< "$DBE_PIDS_FILE"))
		for ((i=1; i<${#pids[@]}; i++)) do
			#echo "'$1' '${pids[$i]}'"
			if [ "$1" = "${pids[$i]}" ]; then
				unset pids[i]; echo ${pids[@]} > "$DBE_PIDS_FILE"; break;
			fi
		done
		((${#pids[@]}>1)) && return 1 #|| echo "${#pids[@]}"
	fi
	q_dbe ".quit"; local cntr="500"
	while kill -0 $DBE_PID 2>/dev/null; do
		sleep 0.1s; ((cntr--)); ((cntr<=0)) && break
	done
	#echo "dbe close stop tm $((500-cntr)) $(pwd)"
	rm -f "$DBE_PIDS_FILE"; unset DBE_PID
	return 0
}

colval_set_or_cond() {
#args: <col1,col2...> <val1&val2...> [cond] [values_delim='&']
#ret: string of columns and values for SET or for WHERE
#		if cond='INS' returns list_cols&list_vals for INSERT env
	local delim="&"; [ -n "$4" ] && delim="$4"
	local ret="" r2="" key val keys=(${1//,/ });
	OIFS=$IFS; IFS=$delim; local -a vals=($2); IFS=$OIFS
	for idx in ${!keys[*]}; do
		key=${keys[$idx]}; val=${vals[$idx]}
		if [ -z "$3" ]; then # set env
			[ -z "$val" -o "$val" = "NULL" -o "$val" = "null" ] && continue
			ret+="${ret:+,}$key='$val'"
		elif [ "$3" = "INS" ]; then # ins env
			[ -z "$val" -o "$val" = "NULL" -o "$val" = "null" ] && continue
			ret+="${ret:+,}$key"; r2+="${r2:+,}'$val'"
		else # cond env
			if [ -z "$val" -o "$val" = "NULL" -o "$val" = "null" ]; then
				ret+="${ret:+ $4 }$key IS NULL"
			else ret+="${ret:+ $4 }$key='$val'"
			fi
		fi
		#echo "\"$key\" = \"$val\""
	done
	[ "$3" = "INS" ] && ret+="&$r2"
	echo "$ret"
}

str_eq_cond() {
#args: cond vals_str [vals_delim='|']
#ret: "cond IN ('A','B','C'...)" or "cond='A'"
	local delim="|"; [ -n "$3" ] && delim="$3";
	local comma="" ivs="$2" val vals;
	[ -z "$ivs" ] && ivs="NULL" || ivs=${ivs//$delim/$'\n'}
	while read val; do comma="${vals:+,}"; vals+="$comma'$val'"; done <<< "$ivs"
	if [ -n "$comma" ]; then echo "$1 IN ($vals)"
	elif [ "$ivs" = "NULL" ]; then echo "$1 IS NULL"
	else echo "$1=$vals"
	fi
}

qtxt2cmdstrs() {
#params: <text from sqlite3 query (.mode line)>
#ret: nx command strings
	local res="" fl="1" line k v;
	while read line; do
		[ -z "$line" ] && { res+=$'\n'; fl=1; continue; }
		[ "$fl" = "1" ] && { res+="a=b&"; fl=0; }
		k=$(trim "$(cutfn "$line" "=" 0)") #"
		v=$(trim "$(cutfn "$line" "=" 1)") #"
		res+="$k=$v&"
	done <<< "$@"
	echo "$res"
}
