#!/bin/bash
#
# Copyright (c) 2020 by Dmitry Borisov <i@dimbor.ru>
#
# License: GPL, version 2
#
# ========================================================================

ip4_pattern='[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+'
num_pattern='[+-]?[0-9]+([.][0-9]+)?'

# following two functions are Copyright by Klaus Knopper
stringinstring() { case "$2" in *$1*) return 0;; esac; return 1; }

getparam() {
#args: <instring> <param_name> [recode_hex_%NN]
# Reread given line; echo last parameter's argument or return false.
	local pattern=".*&$2=([^&]*)" str="&$1" r;
	[[ "$str" =~ $pattern ]]; r=${BASH_REMATCH[1]}
	[ -n "$3" ] && echo -e "${r//\%/\\x}" || echo "$r"
	[ "$BASH_REMATCH" != "" ]
}

trim() {
	local v="$*"; v=${v#${v%%[![:space:]]*}};
	v=${v%${v##*[![:space:]]}}; echo -n "$v"
}

cutfn() {
#args: line field_num_start_at_0 [delim=$IFS]
	if [ -n "$3" ]; then local IFS="$3"; fi
	local a=($1);
	#echo "${a[($2)]}" # negative values works on all systems?
	echo "${a[@]:($2):1}"
}

rematchfn(){
#args: (pattern) <text> [match_num=0] [reversive]
# if match_num == "all" returns all found matches delimited by newlines
	local pat n OIFS a ntl nr a r r1 res;
	pat="$1"; [ -z "$3" -o "$3" = "all" ] && n=0 || n="$3"
	OIFS=$IFS; local IFS=$'\n'; a=($2); IFS=$OIFS;
	ntl=${#a[@]}; nr=0; r=(); res="";
	if [ -z "$4" ]; then
		for ((i=0;i<$ntl;i++)) {
			[[ "${a[$i]}" =~ $pat ]] || continue
			((nr++)); r+=(${BASH_REMATCH[1]})
			[ "$nr" = "$n" ] && break
		}
	else
		for ((i=$ntl;i>=0;i--)) {
			[[ "${a[$i]}" =~ $pat ]] || continue
			((nr++)); r+=(${BASH_REMATCH[1]})
			[ "$nr" = "$n" ] && break
		}
	fi
	if [ "$3" = "all" ]; then
		for r1 in ${r[@]}; do res+="${res:+$'\n'}$r1"; done
		echo "$res"
	else echo "${r[($n)]}"
	fi
	[ "$nr" != "0" ]
}

set_vars_from_params() {
#args: <instring> <varnames> [var_prefix=""] [%hex_recode=""]
# varnames_list_delimited_by_spaces_or_commas
	local vnames vn vv;
	vnames="${2//,/ }"
	for vn in $vnames; do
		vv=$(getparam "$1" $vn $4); #[ -z "$vv" ] && continue;
		declare -g $4$vn="$vv"
	done
}

set_vars_from_ampstr() {
#param: <ampstr> [var_prefix=""] [%hex_recode=""]
	local kv vn vv;
	local IFS='&'; local -a a=($1) a2;
	for kv in ${a[@]}; do
		IFS='=' a2=($kv); vn=${a2[0]}; [ -z "$vn" ] && continue;
		vv=${a2[1]}; [ -n "$3" ] && vv=$(echo -e  "${vv//\%/\\x}")
		declare -g $2$vn=$vv
	done
}

# ===========================================================================
# sqlite3 functions
declare -g sq_cmd="/usr/bin/sqlite3";
declare -g DBE_PID="" DBE_PIDS_FILE="";

lock_dbe() {
#arg: [wait_hundredth_of_a_second==150]
	local cntr=150; [ -n "$1" ] && cntr=$1
	while [ -e "$DBE_PIDS_FILE.lock" ]; do
		sleep 0.01s; ((cntr--)); ((cntr<=0)) && break;
	done
	[ -e "$DBE_PIDS_FILE.lock" ] && return 1
	ln "$DBE_PIDS_FILE" "$DBE_PIDS_FILE.lock" &>/dev/null;
}

unlock_dbe() { rm -f "$DBE_PIDS_FILE.lock" &>/dev/null; return 0; }

q_dbe() {
	local rc; lock_dbe || return 1
	echo -e "$@" >/proc/$DBE_PID/fd/0; rc=$?
	unlock_dbe; return $rc
}

qa_dbe() {
#args: <query_string> ...
	local qstr="$@" r res=""
	qstr+="SELECT '{end}';"
	lock_dbe || return 1
	echo -e "$qstr" >/proc/$DBE_PID/fd/0 || return 1
	while read r </proc/$DBE_PID/fd/1; do
		r=$(trim "$r")
		[ "${r:(-5)}" = "{end}" ] && break
		res+="${res:+$'\n'}$r"
	done
	unlock_dbe
	echo "$res"
}

ctl_dbe() {
#arg: <pid_of_parent>
	coproc $sq_cmd -batch
	echo "$COPROC_PID" > "$DBE_PIDS_FILE"
	wait $COPROC_PID
}

open_dbe() {
#arg: <pid_of_parent>
#ret: 0 if dbe started, 1 - dbe connected, 2 - error;
	#echo "open dbe start $1"
	local new_dbe="" pids cntr;
	[ "$USER" != "nx" ] && DBE_PIDS_FILE="/tmp/nxdbe-$USER"
	if [ -z "$DBE_PID" ]; then
		if [ -r "$DBE_PIDS_FILE" ]; then
			pids=($(< "$DBE_PIDS_FILE")); DBE_PID=${pids[0]};
		else new_dbe="1"
		fi
	fi
	if [ -n "$DBE_PID" ]; then
		if kill -0 $DBE_PID 2>/dev/null; then
			echo "$1" >> "$DBE_PIDS_FILE"
			return 1
		else
			DBE_PID=""; rm -f "$DBE_PIDS_FILE"; new_dbe="1";
			#echo "rm old pidfile";
		fi
	fi
	if [ -n "$new_dbe" ]; then
		local dbc_pid="";
		[ "$USER" = "nx" ] && DBE_PIDS_FILE="/tmp/nxdbe-$1"
		(ctl_dbe $1) &
		dbc_pid=$!; disown $dbc_pid;
		cntr=200;
		while [ ! -e "$DBE_PIDS_FILE" ]; do sleep 0.01s; ((cntr--)); ((cntr<=0)) && break; done
		#echo "create dbe $((200-cntr))0 ms"
		DBE_PID=$(< "$DBE_PIDS_FILE"); echo "$1" >> "$DBE_PIDS_FILE"
		q_dbe ".timeout 500\n.separator '&'" # not work with later attached tables after '.mode csv tname'
		#q_dbe "PRAGMA journal_mode = WAL;" # causes error on keyslst_for_user() now
		return 0
	fi
	return 2
}

attach_db() {
#args: <filename>
	local dbname=${1##*\/}; dbname=${dbname%.*}
	q_dbe "ATTACH DATABASE '$1' AS $dbname;"
}

close_dbe() {
#arg: <pid_of_parent>
# if arg empty close ultimately
	#echo "dbe close start - $1; $DBE_PIDS_FILE; $DBE_PID"
	[ -z "$DBE_PID" ] && return
	[ ! -e "$DBE_PIDS_FILE" ] && return
	local spids pids="" isdbe="" i;
	if [ -n "$1" ]; then
		[ -r "$DBE_PIDS_FILE" ] && {
			isdbe="1"; pids=($(< "$DBE_PIDS_FILE"))
		}
		for ((i=1; i<${#pids[@]}; i++)) do
			#echo "'$1' '${pids[$i]}'"
			if [ "$1" = "${pids[$i]}" ]; then
				unset pids[i]; echo ${pids[@]} > "$DBE_PIDS_FILE"; break;
			fi
		done
		((${#pids[@]}>1)) && return 1 #|| echo "${#pids[@]}"
	fi
	q_dbe ".quit"; unset DBE_PID; rm -f "$DBE_PIDS_FILE"
	return 0
}

exit_proc() {
	close_dbe $$; exit $1;
}

colval_set_or_cond() {
#args: <col1,col2...> <val1&val2...> [cond] [values_delim='&']
#ret: string of columns and values for SET or for WHERE
#		if cond='INS' returns list_cols&list_vals for INSERT env
	local delim="&"; [ -n "$4" ] && delim="$4"
	local ret="" r2="" key val keys=(${1//,/ });
	OIFS=$IFS; IFS=$delim; local -a vals=($2); IFS=$OIFS
	for idx in ${!keys[*]}; do
		key=${keys[$idx]}; val=${vals[$idx]}
		if [ -z "$3" ]; then # set env
			[ "$val" = "NULL" -o "$val" = "null" ] && continue
			ret+="${ret:+,}$key='$val'"
		elif [ "$3" = "INS" ]; then # ins env
			[ "$val" = "NULL" -o "$val" = "null" ] && continue
			ret+="${ret:+,}$key"; r2+="${r2:+,}'$val'"
		else # cond env
			if [ "$val" = "NULL" -o "$val" = "null" ]; then
				ret+="${ret:+ $4 }$key IS NULL"
			else ret+="${ret:+ $4 }$key='$val'"
			fi
		fi
		#echo "\"$key\" = \"$val\""
	done
	[ "$3" = "INS" ] && ret+="&$r2"
	echo "$ret"
}

q_row_ins() {
#args: <table_name> <col1,col2...> <val1&val2...> [values_delim='&']
	local colvals=$(colval_set_or_cond "$2" "$3" "INS" "$4")
	local keys=${colvals%%&*} vals=${colvals#*&}
	q_dbe "INSERT INTO $1($keys) VALUES($vals);"
}

q_rows_upd() {
#args: <table_name> <where_str> <col1,col2...> <val1&val2...> [values_delim='&']
	local setls=$(colval_set_or_cond "$3" "$4" "" "$5")
	q_dbe "UPDATE $1 SET $setls WHERE $2;"
}

q_vals_str_get() {
#args: <table_name> <where_str> <col1,col2...> [values_delim='&']
	local d="&"; [ -n "$4" ] && d="$4";
	local mode=".mode csv $1\n.separator '$d'\n"
	local rs=$(qa_dbe "$mode" "SELECT count(*),$3 FROM $1 WHERE $2 LIMIT 1;") #"
	[ "${rs%%$d*}" -gt "0" 2>/dev/null ] || { echo; return 1; }
	local ret=${rs#*$d}; ret=${ret//\"/}
	echo "$ret"
}

str_eq_cond() {
#args: cond vals_str [vals_delim='|']
#ret: "cond IN ('A','B','C'...)" or "cond='A'"
	local delim="|"; [ -n "$3" ] && delim="$3";
	local comma="" ivs="$2" val vals;
	[ -z "$ivs" ] && ivs="NULL" || ivs=${ivs//$delim/$'\n'}
	while read val; do comma="${vals:+,}"; vals+="$comma'$val'"; done <<< "$ivs"
	if [ -n "$comma" ]; then echo "$1 IN ($vals)"
	elif [ "$ivs" = "NULL" ]; then echo "$1 IS NULL"
	else echo "$1=$vals"
	fi
}

qtxt2cmdstrs() {
#params: <text from sqlite3 query (.mode line)>
#ret: nx command strings
	local res="" fl="1" line k v;
	while read line; do
		[ -z "$line" ] && { res+=$'\n'; fl=1; continue; }
		[ "$fl" = "1" ] && { res+="a=b&"; fl=0; }
		k=$(trim "$(cutfn "$line" 0 '=')") #"
		v=$(trim "$(cutfn "$line" 1 '=')") #"
		res+="$k=$v&"
	done <<< "$@"
	echo "$res"
}
