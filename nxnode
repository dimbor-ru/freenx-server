#!/bin/bash

# Free implementation of nxserver components
# Copyright (c) 2004 by Fabian Franz.
#           (c) 2008-19 by Dmitry Borisov <i@dimbor.ru>
# License: GNU GPL, version 2

shopt -s extglob

# Read the config file
# dimbor: it's temporary
. /usr/bin/nxloadconfig --userconf

. $SHARED_CONFS/nxfuncs
#
# -----------------------------------------------------------------------------
# Various helper functions
# -----------------------------------------------------------------------------
#
echo_secure() {
	[ "$NX_LOG_SECURE" = "0" ] && echo "$@" || \
		echo "${@/password=+([^&])&/password=****&}"
}

nxlog() {
	[ "$NX_LOG_LEVEL" -lt 6 ] && return 0
	echo_secure "$(date "+%T.%3N"): $@" >> "$nxuser_logfile"
}

cp_conv() {
# arg: string
# convert string charset
	local lp="$FUNCNAME ($$/$BASHPID):";
	#nxlog "$lp starting with args \"$@\""
	local res=${1//+/ } cp_pair cp_from cp_to;
	for cp_pair in $WIN_CP_CONVERT_CHAIN ; do
		cp_from=$(cutfn "$cp_pair" 0 '>'); [ -n "$cp_from" ] || cp_from="UTF-8"
		cp_to=$(cutfn "$cp_pair" 1 '>'); [ -n "$cp_to" ] || cp_to="UTF-8"
		res=$(echo "$res" | iconv -f $cp_from -t $cp_to)
		#nxlog "$lp converting $cp_from > $cp_to == \"$res\""
	done
	#nxlog "$lp return res='$res'"
	echo "$res"
}

# =================== sqlite3 stuff =====================

declare -g sqcols_usess="session_id, status, display, type, agent_pid,\
 cookie, tail_pid, userip, acc_ip, mmport, cupsport, smbport"
declare -g sqcols_usess_c=12

init_usessions_db() {
	local usess_cols="session_id TEXT PRIMARY KEY, status TEXT, display TEXT,\
 type TEXT, agent_pid INT, cookie TEXT, tail_pid INT, userip TEXT, acc_ip TEXT,\
 mmport INT, cupsport INT, smbport INT"
	local qstr="CREATE TABLE IF NOT EXISTS usessions.usess($usess_cols);"
   q_dbe "$qstr"
}

usess_add() {
#args: <col1,col2...> <val1&val2...>
	q_row_ins "usess" "$1" "$2"
}

usess_set() {
#args: <session_id> <col1,col2...> <val1&val2...>
	q_rows_upd "usess" "session_id='$1'" "$2" "$3"
}

usess_get() {
#args: <session_id> <col1,col2...> [values_delim='&']
	q_vals_str_get "usess" "session_id='$1'" "$2" "$3"
}

usess_close() {
#args: <session_id> <status>
	if [ "$SESSION_LOG_CLEAN" = "1" ]; then
		q_dbe "DELETE FROM usess WHERE session_id='$1';"
	else
		q_rows_upd "usess" "session_id='$1'" "status" "$2"
	fi
}

#
# -----------------------------------------------------------------------------
# Node functions module
# -----------------------------------------------------------------------------
#

node_terminate_session() {
#args: <session_id> [status]
# Used gvars: nx_dir
# Used config vars: COMMAND_XAUTH, SESSION_LOG_CLEAN SERVER_NAME
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp Start terminating session_id='$1' with status '$2'"
	local status=$(usess_get "$1" "status")
	stringinstring "$status" "Terminating|Finished|Failed" && {
		nxlog "$lp Session status is already '$status'. Bye."; return;
	}
	usess_set "$1" "status" "Terminating"

	local qs=$(usess_get "$1" \
		"display,agent_pid,tail_pid,mmport,cupsport,smbport")
	[ -z "$qs" ] && {
		nxlog "$lp session_id='$1' not found in usess db. Bye."; return;
	}
	local display=$(cutfn "$qs" 0 '&'); local sess_id="$SERVER_NAME-$display-$1"
	local agent_pid=$(cutfn "$qs" 1 '&') tail_pid=$(cutfn "$qs" 2 '&')
	local t_status="$2"; [ -z "$2" ] && t_status="Finished"
	[ -d "$nx_dir/C-$sess_id" ] || {
		nxlog "$lp Session dir '$nx_dir/C-$sess_id' not found. Bye."; return;
	}
	local p1=$(cutfn "$qs" 3 '&') p2=$(cutfn "$qs" 4 '&') p3=$(cutfn "$qs" 5 '&')
	((p1+p2+p3!=0)) && node_stop_services
	kill -0 $agent_pid 2>/dev/null && {
		nxlog "$lp start killing of nxagent ($agent_pid)"
		kill $agent_pid 2>/dev/null
		wait $agent_pid 2>/dev/null
		kill -0 $agent_pid 2>/dev/null ||
			nxlog "$lp nxagent ($agent_pid) is dead now"
	}
	((tail_pid>0)) && kill -0 $tail_pid 2>/dev/null && { # Kill tail process
		nxlog "$lp kill tail process ($tail_pid)"
		kill $tail_pid 2>/dev/null
		wait $tail_pid 2>/dev/null
		kill -0 $tail_pid 2>/dev/null || {
			nxlog "$lp tail ($tail_pid) is dead now"; tail_pid="0"
			usess_set "$session_id" "tail_pid" "0"
		}
	}
	# Remove display information
	nxlog "$lp Remove display information"
	rm -f /tmp/.X$display-lock; rm -f /tmp/.X11-unix/X$display
	# Remove magic cookie information
	nxlog "$lp Remove magic cookie information"
	$COMMAND_XAUTH remove "localhost:$display" >/dev/null 2>&1
	$COMMAND_XAUTH remove ":$display" >/dev/null 2>&1
	# Preserve or remove session information
	nxlog "$lp Preserve or remove session information"
	if [ "$SESSION_LOG_CLEAN" = "1" ]; then
		nxlog "$lp Clean session information."
		rm -rf "$nx_dir/C-$sess_id/"
		rm -f  "$nx_dir/nxnode-$1.log"
		rm -f  "$nx_dir/nxnode.log"
	elif [ "$2" = "Failed" ]; then
		nxlog "$lp Session failed. Rename session directory \
from '$nx_dir/C-$sess_id/' to '$nx_dir/F-C-$sess_id'"
		mv "$nx_dir/C-$sess_id/" "$nx_dir/F-C-$sess_id"
	else
		nxlog "$lp Session terminated. Rename session directory \
from '$nx_dir/C-$sess_id/' to '$nx_dir/T-C-$sess_id'"
		mv "$nx_dir/C-$sess_id/" "$nx_dir/T-C-$sess_id"
	fi
	usess_close "$1" "$t_status"
	nxlog "$lp end"
}

node_fail_restore_session() {
#arg:  <session_id>
	local lp="$FUNCNAME ($$/$BASHPID):"; nxlog "$lp starting"
	echo "NX> 1004 Error: Could not resume session. nxagent process could not be found."
	node_terminate_session "$1" "Failed"
	nxlog "$lp end. Next is 'exit 1'"
	exit_proc 1
}

node_suspend_session() {
#arg:  <session_id>
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	local agent_pid=$(usess_get "$1" "agent_pid")
	nxlog "$lp Killing (HUP) agent_pid ($agent_pid)..."
	kill -0 $agent_pid 2>/dev/null || {
		nxlog "$lp nxagent is already dead. end (0)"; return 1;
	}
	kill -HUP $agent_pid 2>/dev/null && {
		nxlog "$lp end (HUP)"; return 0;
	}
	return 1
}

node_find_application() {
#args: <type>
# Used config vars: $COMMAND_START_KDE, $COMMAND_START_GNOME,
# $COMMAND_START_CDE, $COMMAND_XTERM, $USER_X_STARTUP_SCRIPT,$DEFAULT_X_SESSION
	local lp="$FUNCNAME ($$/$BASHPID):"; nxlog "$lp starting with args \"$@\""
	local node_startx=""
	case $1 in
		shadow|windows|vnc)
			:
		;;
		unix-kde)
			node_startx=$COMMAND_START_KDE
			[ "$KDE4_ENABLE" = "1" -a -n "$COMMAND_START_KDE" ] && \
				node_startx=$COMMAND_START_KDE4
		;;
		unix-gnome)
			node_startx=$COMMAND_START_GNOME
		;;
		unix-cde)
			node_startx=$COMMAND_START_CDE
		;;
		windows-helper)
			application="$PATH_BIN/nxdesktop_helper"
			node_startx=$application
		;;
		unix-application|vnc-helper)
			[ "$application" = "xterm" ] && application=$COMMAND_XTERM
			node_startx=$application
		;;
		unix-console)
			node_startx=$COMMAND_XTERM
		;;
		unix-default|*)
			if [ -x "$HOME/$USER_X_STARTUP_SCRIPT" ]; then
				node_startx="$HOME/$USER_X_STARTUP_SCRIPT"
			elif [ -x "$DEFAULT_X_SESSION" ]; then
				node_startx="$DEFAULT_X_SESSION"
			else node_startx=$COMMAND_XTERM
			fi
		;;
	esac

	# dimbor: another personalyzed way to ACLS control and replace X-application
	[ -d "$NX_ACL_DIR" -a -x "$PATH_BIN/nxacl.app" ] && {
		nxlog "$lp !!! call nxacl.app with source node_startx='$node_startx'"
		node_startx=$($PATH_BIN/nxacl.app "$node_startx" "$CMDLINE")
	}

	echo "$node_startx"
	nxlog "$lp return node_startx='$node_startx'"
}

node_start_applications() {
# Used glob vars: $type, $application, $sess_id, $mediahelper,
# $virtualdesktop, $rootless, $display
# Used config vars: <several>
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	local node_app mmode mmport params i;
	local second_app="" sapp_pids0="" napp;
	local spid node_app_pid sapp_pids="" sapp_pids1 node_wm_pid;
	# close input and output file descriptors
	exec 0<&-; exec 1>&-; exec 2>&-

	# Prepare application startup
	export DISPLAY=:$display

	nxlog "$lp display='$display', waiting for it's ready"
	local cntr=$((AGENT_STARTUP_TIMEOUT*100)); local cntr0=$cntr
	while [ ! -f /tmp/.X$display-lock ]; do
		sleep 0.01s; ((cntr--)); ((cntr<=0)) && break
	done
	nxlog "$lp Stop waiting for DISPLAY $((cntr0-cntr))0 ms"

	#numlockx
	if [ "$NUMLOCKX_STATUS" != "system" ]; then
		nxlog "$lp Run \"$NUMLOCKX $NUMLOCKX_STATUS\""
		"$NUMLOCKX" "$NUMLOCKX_STATUS"
	fi

	# Which application do we start?
	node_app=$(node_find_application "$type")
	# For rdesktop/VNC, there is no application to start
	if [ -n "$node_app" ]; then
		nxlog "$lp Got node_app is \"$node_app\""
	else
		nxlog "$lp node_app is empty"
		return
	fi

	[ "$cups" = "1" -o "$samba" = "1" ] && {
		nxlog "$lp export CUPS_SERVER=$CUPS_DEFAULT_SOCK"
		export CUPS_SERVER=$CUPS_DEFAULT_SOCK
	}
	if [ "$ENABLE_SAMBA_PRELOAD" = "1" ]; then
		NXSAMBA_PORT=$(usess_get "$session_id" "smbport")
		((NXSAMBA_PORT>0)) && {
			export NXSAMBA_PORT
			nxlog "$lp Preload SAMBA using nxredir. NXSAMBA_PORT is '$NXSAMBA_PORT'"
			node_app="$PATH_BIN/nxredir $node_app"
			echo "Info: NXNODE - Using nxredir wrapper script to forward \
SMB ports 139 and 445 to port $NXSAMBA_PORT." >> "$NXSESSION_DIRECTORY/session"
		}
	fi

	# Do we need to PRELOAD any libraries?
	[ "$virtualdesktop" = "0" -a "$rootless" != "1" ] && export LD_PRELOAD="$APPLICATION_LIBRARY_PRELOAD:$LD_PRELOAD"

	# Should we start a window manager?
	if [ "$virtualdesktop" = "1" -a "$type" = "unix-application" -a \
			-x "$DEFAULT_X_WM" ]; then
		nxlog "$lp start a window manager - \"DISPLAY=:$display $DEFAULT_X_WM\""
		DISPLAY=:$display $DEFAULT_X_WM >>"$NXSESSION_DIRECTORY/session" 2>&1 &
		node_wm_pid=$!
		nxlog "$lp node_wm_pid='$node_wm_pid'}"
	fi

	# Use Xsession to execute the Desktop session
	case $type in
		unix-gnome)
			export STARTUP="$node_app"
			if [ "$login_method" = "GUEST" ]; then
				node_app=$COMMAND_GUEST_X_SESSION
			elif [ "$BOOTSTRAP_X_SESSION" = "1" ]; then
				node_app=$COMMAND_GDM_X_SESSION
			fi
		;;
		unix-kde|unix-cde)
			export STARTUP="$node_app"
			if [ "$login_method" = "GUEST" ]; then
				node_app=$COMMAND_GUEST_X_SESSION
			elif [ "$BOOTSTRAP_X_SESSION" = "1" ]; then
				node_app=$DEFAULT_X_SESSION
			fi
		;;
	esac

	[ $ENABLE_ROOTLESS_TERMINATE_SESSION = "1" -a "$rootless" = "1" ] && {
		napp=$(cutfn "$node_app" 0); napp=$(cutfn "$napp" -1 '/')
		second_app=$(rematchfn "$napp:(.+)" "${APP_WAIT_MAP//;/$'\n'}") #"
		[ -n "$second_app" ] && {
			sapp_pids0=$(ps -wo pid= -C $(cutfn "$second_app" -1 '/'))
			nxlog "$lp PID of $second_app will be waiting too. Initial: \"$sapp_pids0\""
		}
	}

	# Startup the application
	nxlog "$lp Starting node_app with /etc/nxserver/Xsession"
	DISPLAY=:$display /etc/nxserver/Xsession $node_app >> \
		"$NXSESSION_DIRECTORY/session" 2>&1 &
	node_app_pid=$!
	nxlog "$lp Start successful. Waiting for node_app_pid='$node_app_pid'"
	wait $node_app_pid
	nxlog "$lp node_app_pid finished"

	# Kill or wait for the started window manager
	[ -n "$node_wm_pid" ] && {
		nxlog "$lp node_wm_pid is not empty"
		# kill the WM after application is finished?
		[ "$KILL_DEFAULT_X_WM" = "1" ] && { nxlog "$lp killing $node_wm_pid"
			kill $node_wm_pid 2>/dev/null; }
		# or just wait until it finishes?
		[ "$KILL_DEFAULT_X_WM" = "1" ] || { nxlog "$lp wait for $node_wm_pid is dead"
			wait $node_wm_pid; }
	}
	#sleep "$NODE_APP_WAIT_TIMEOUT"

	[ $ENABLE_ROOTLESS_TERMINATE_SESSION = "1" -a "$rootless" = "1"  ] && {
		if [ -n "$second_app" ] ; then
			sapp_pids1=$(ps -wo pid= -C $(cutfn "$second_app" -1 '/'))
			while read spid; do
				stringinstring "$spid" "$sapp_pids0" && continue
				sapp_pids+="${sapp_pids:+$' '}$spid"
			done <<< "$sapp_pids1"
			nxlog "$lp Waiting for $second_app PID(S) \"$sapp_pids\""
			while [ -n "$(ps -o pid= -p $sapp_pids 2>/dev/null)" ]; do
				sleep 1s
			done
			nxlog "$lp PID(S) \"$sapp_pids\" finished"
			node_terminate_session "$session_id"
		else  node_terminate_session "$session_id"
		fi
	}

	# Do not terminate agent in case of rootless agent mode.
	# The agent times out after a while by itself anyway.
	if [ "$virtualdesktop" = "1" -o "$rootless" != "1" ] ; then
		nxlog "$lp Call node_terminate_session for non-rootless or virtualdesktop session type"
		node_terminate_session "$session_id"
	fi
	nxlog "$lp end"
}

node_agent_persistent_session() {
# Is the user allowed to run a persistent session?
	local username IFS="," p="-nopersistent"
	# Guest sessions are always nonpersistent
	[ "$login_method" = "GUEST" ] && { echo "$p"; return; }
	[ "$ENABLE_PERSISTENT_SESSION" = "all" ] && p="-persistent" || {
		for username in $ENABLE_PERSISTENT_SESSION; do
			[ "${username:0:1}" != "@" ] && [ "$USER" = "$username" ] && \
				p="-persistent" && break;
			[ "${username:0:1}" = "@" ] && \
				[ -z $(groups "$USER" | egrep "^${username:1}:") ] && \
					p="-persistent" && break;
		done
	}
	for username in $DISABLE_PERSISTENT_SESSION; do
		[ "${username:0:1}" != "@" ] && [ "$USER" = "$username" ] && \
			p="-nopersistent" && break;
		[ "${username:0:1}" = "@" ] && \
			[ -z $(groups "$USER" | egrep "^${username:1}:") ] && \
				p="-nopersistent" && break;
	done
	echo "$p"
}

node_start_agent() {
# Ok, now we do some wicked fd magic.
# first part:	nxagent's fd #2 -> fd #3
# second part:	fd #1 -> #4; fd #3 -> #1; tee | node_start_monitor
# third part:	fd #4 -> #1
# => all output of nxagent goes to tee | node_start_monitor, while
#    leaving all other output flow through like normally.

	# preparations
	local lp="$FUNCNAME ($$/$BASHPID):";
	local k g b r fp vncfullscreen u p d agent_port viewonly
	local agent_exit_status node_failed
	nxlog "$lp starting"
	exec 3>&2; exec 4>&1;

	{

	{

	export DISPLAY="nx/nx,options=$NXSESSION_DIRECTORY/options:$display"
	export XAUTHORITY="$NXSESSION_DIRECTORY/authority"
	export HOME
	export NX_CLIENT="$PATH_BIN/nxdialog"

	# Setup optional parameters for nxagent
	# keyboard
	k=""
	# backwards compatibility
	[ -n "$keyboard" ] && k="-keyboard $keyboard"
	[ -n "$kbtype" ] && k="-kbtype $kbtype"

	# backingstore
	b=""
	if [ -n "$backingstore" -a "$ENABLE_1_5_0_BACKEND" = "1" ]; then
		[ "$backingstore" != 1 ] && b="-bs $backingstore"
		[ "$backingstore" = 1 ] && b="+bs"
	fi

	# geometry
	g=""
	[ -n "$geometry" ] && g="-geometry $geometry"

	# type of session
	r="-D"; [ "$rootless" = "1" ] && r="-R"

	# Setup fullscreen parameters
	vncfullscreen=""
	[ "$geometry" = "fullscreen" -a "$type" = "vnc" ] && \
		vncfullscreen="-fullscreen" && g=""
	[ "$geometry" = "fullscreen" -a "$type" = "windows" ] && \
		g="-geometry $(rematchfn '^([[:digit:]]+x[[:digit:]]+)' $screeninfo)"

	# Start the wanted nxagent
	if [ "$type" = "windows" ]; then
		nxlog "$lp Type \"windows\""
		# nxdesktop session (Windows RDP)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup optional parameters
		u=""; p=""; d=""
		[ -n "$agent_user" ] && u="-u $agent_user"
		[ -n "$agent_password" ] && p="-p -"
		[ -n "$agent_domain" ] && d="-d $agent_domain"
		# Start the agent
		echo "$agent_password" | $PATH_BIN/nxdesktop \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" \
			$k $g $u $p $d $agent_server $AGENT_EXTRA_OPTIONS_RDP 2>&3 &

	elif [ "$type" = "vnc" ]; then
		nxlog "$lp Type \"vnc\""
		# nxviewer session (VNC RFB)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup password
		mkdir -p "$NXSESSION_DIRECTORY/scripts/"
		echo "$agent_password" | $PATH_BIN/nxpasswd \
			"$NXSESSION_DIRECTORY/scripts/.passwd" doit
		# Start x11vnc
		if [ -n "$shadowdisplay" ]; then
			(
				viewonly=""
				[ "$ENABLE_INTERACTIVE_SESSION_SHADOWING" != "1" ] && \
					viewonly="-viewonly"
				DISPLAY="$shadowhost:$shadowdisplay" x11vnc -localhost \
					$viewonly -timeout 120 -rfbauth \
					"$NXSESSION_DIRECTORY/scripts/.passwd" \
					>"$NXSESSION_DIRECTORY/scripts/.vnc_port" 2>&3 &
			)
			local cntr="40"
			while [ ! -f $NXSESSION_DIRECTORY/scripts/.vnc_port ]; do
				sleep 0.05s; ((cntr--)); ((cntr<=0)) && break
			done
			agent_port=$(< $NXSESSION_DIRECTORY/scripts/.vnc_port)
			agent_port=$(rematchfn '^PORT=[[:space:]]*([[:digit:]]+)' $agent_port) #'
			[ -z "agent_port" ] && agent_port="0"
			# note the :: is not a mistake, but rather a hint for nxviewer
			# to use this as a port and not interpret it as a display.
			agent_server="127.0.0.1::$agent_port"
			rm -f "$NXSESSION_DIRECTORY/scripts/.vnc_port"
		fi
		# Start the agent
		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw \
			-passwd "$NXSESSION_DIRECTORY/scripts/.passwd" \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" $vncfullscreen \
			$g $k $agent_server $AGENT_EXTRA_OPTIONS_RFB 2>&3 &
	elif [ "$r" = "-R" -a "$rootless" != "1" ]; 	then
		# nxproxy single application mode session
		nxlog "$lp Start nxproxy for single application session mode"
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$PROXY_LIBRARY_PATH:$LD_LIBRARY_PATH"
		nxlog "$lp Start nxproxy by command: '$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS'"
		$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS 2>&3 &
	else
		nxlog "$lp NXAgent session type"
		# nxagent session (X11)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup optional parameters
		p=$(node_agent_persistent_session)
		fp=""; [ -n "$AGENT_FONT_SERVER" ] && fp="-fp $AGENT_FONT_SERVER"
		if [ "$type" = "shadow" ]; then
			nxlog "$lp Type \"shadow\". Add some args to nxagent"
			r="-S -shadow $shadowhost:$shadowdisplay -shadowmode $ENABLE_INTERACTIVE_SESSION_SHADOWING"
			p="-nopersistent"
		fi
		# Start the agent
		#nxlog "$lp env start `env`"; nxlog "$lp env end"
		nxlog "$lp Start nxagent by command: '$COMMAND_NXAGENT $p $r -name \"NX - $user@$SERVER_NAME:$display - $session (GPL Edition)\" -option \"$NXSESSION_DIRECTORY/options\" $b $fp $AGENT_EXTRA_OPTIONS_X :$display'"
		#PATH="$PATH_BIN:$PATH" $COMMAND_NXAGENT $p $r -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$NXSESSION_DIRECTORY/options" $k $g $b $fp $AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
		PATH="$PATH_BIN:$PATH" $COMMAND_NXAGENT $p $r \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" $b $fp \
			$AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
	fi

	# Wait for the agent
	agent_pid=$!
	usess_set "$session_id" "agent_pid" "$agent_pid"
	nxlog "$lp Wait for agent_pid='$agent_pid'"
	wait $agent_pid; agent_exit_status=$?
	nxlog "$lp agent_exit_status='$agent_exit_status'"
	node_failed=""
	if [ $agent_exit_status -ne 0 ]; then
		echo "NX> 1004 Error: NX Agent exited with exit status $agent_exit_status. To troubleshoot set SESSION_LOG_CLEAN=0 in node.conf and investigate \"$nx_dir/F-C-$sess_id/session\". You might also want to try: ssh -X myserver; $PATH_BIN/nxnode --agent to test the basic functionality. Session log follows:"
		echo "$(< $NXSESSION_DIRECTORY/session)" >&2
		node_failed="Failed"
		nxlog "$lp node_failed='$node_failed'"
	fi
	nxlog "$lp close session"
	echo "NX> 1006 Session status: closed"

	# Cleanup session information
	nxlog "$lp cleanup session information '$sess_id'"
	nxlog "$lp call 'node_terminate_session \"$session_id\" \"$node_failed\"'"
	node_terminate_session "$session_id" "$node_failed"

	# remove possible leftovers of nxagent
	nxlog "$FUNCNAME ($$):remove /tmp/.X$display-lock"
	rm -f /tmp/.X$display-lock
	nxlog "$lp remove /tmp/.X11-unix/X$display"
	rm -f /tmp/.X11-unix/X$display

	} 3>&1 1>&4 | tee "$NXSESSION_DIRECTORY/session" | \
		node_start_monitor; } 4>&1
}

node_stop_services() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	#nxlog "$lp call node_umount_smb"
	#nxlog "$lp call node_cups_reconnect"
	#nxlog "$lp call reconnect_pa"
	#reconnect_pa
	nxlog "$lp end"
}

node_emergency_exit() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	# umount shares & stop printers
	nxlog "$lp call node_stop_services"
	node_stop_services

	# kill the session
	nxlog "$lp call 'node_terminate_session \"$session_id\" \"Failed\"'"
	node_terminate_session "$session_id" "Failed"

	echo "NX> 1004 Error: Emergency exit due to kill signal."
	nxlog "$lp end"
}

node_start_monitor() {
#arg: <start|restore>
# Monitoring the nxagent: Its also kind of a "state-machine"
#                         as it has to keep track of different
#                         connection states and react differently.
	local lp="$FUNCNAME ($$/$BASHPID):"; nxlog "$lp starting with arg: $@"
	local tail_pid="" watchdog_pid tosend pars_sent=""
	local smbport="0" mmport="0" cupsport="0"

	while read line; do
		case "$line" in
			*"Info: Waiting for connection from"*)
				[ -n "$pars_sent" ] && continue; # send params only once
				tosend="NX> 700 Session id: $sess_id
NX> 705 Session display: $display\nNX> 703 Session type: $type
NX> 701 Proxy cookie: $cookie\nNX> 702 Proxy IP: $proxyip
NX> 706 Agent cookie: $cookie\nNX> 704 Session cache: $type
NX> 707 SSL tunneling: $encryption\n"
				# File-sharing port options
				[ "$samba" = "1" ] &&
					tosend+="NX> 709 File-sharing port: 445\n"
				echo -e "$tosend""NX> 710 Session status: running
NX> 1002 Commit\nNX> 1006 Session status: running"
				pars_sent="1"; continue;
			;;
			*"Info: Listening"*"SMB connections on port"*)
				# Catch NXAGENT SMB Port (sometimes the port differs from what we got from nxserver)
				smbport=$(cutfn "$line" 1 "'"); smbport=${smbport##*:}
				usess_set "$session_id" "smbport" "$smbport"
				continue;
			;;
			*"Info: Listening"*"multimedia connections on port"*)
				# Catch NXAGENT Multimedia Port
				mmport=$(cutfn "$line" 1 "'"); mmport=${mmport##*:}
				usess_set "$session_id" "mmport" "$mmport"
				continue;
			;;
			*"Info: Listening"*"CUPS connections on port"*)
				# Catch NXAGENT CUPS Port
				cupsport=$(cutfn "$line" 1 "'"); cupsport=${cupsport##*:}
				usess_set "$session_id" "cupsport" "$cupsport"
				continue;
			;;
			*"Info: Watchdog running with pid"*)
				# Watchdog termination
				watchdog_pid=$(cutfn "$line" 1 "'")
				continue;
			;;
			*"Info: Waiting the watchdog process to complete"*)
				# Kill the watchdog
				kill $watchdog_pid 2>/dev/null
				continue;
			;;
		esac

		if [ "$1" != "restore" ]; then # "start" instance
			case "$line" in
				*"Session: Starting session at"*)
					echo "NX> 1009 Session status: starting"
					usess_set "$session_id" "status" "Starting"
				;;
				*"Session: Session started at"*)
					usess_set "$session_id" "status" "Running"
				;;
				*"Session: Suspending session at"*)
					echo "NX> 1009 Session status: suspending"
					usess_set "$session_id" "status" "Suspending"
				;;
				*"Session: Terminating session at"*)
					echo "NX> 1009 Session status: terminating"
				;;
				*"Session: Session suspended at"*)
					# Session suspend
					echo "NX> 1005 Session status: suspended"
					nxlog "$lp $line"
					((mmport+smbport+cupsport>0)) && {
						nxlog "$lp call node_stop_services"
						node_stop_services
					}
					usess_set "$session_id" "status,userip,acc_ip" "Suspended&&"
				;;
			esac
		else # "restore" instance
			#nxlog "$lp nxagent output: $line"
			case "$line" in
				*"Info: tail -f running with pid"*)
					# Catch tail pid
					tail_pid=$(cutfn "$line" 1 "'")
					usess_set "$session_id" "tail_pid" "$tail_pid"
					#echo "$node_tail_pid" >"$nx_dir/C-$sess_id/pids/tail"
				;;
				*"Session: Resuming session at"*)
					echo "NX> 1009 Session status: resuming"
					usess_set "$session_id" "status" "Resuming"
				;;
				*"Session: Session resumed at"*)
					# Reconnection success!
					echo "NX> 718 Session restore succeded"
					usess_set "$session_id" "status,userip,acc_ip"\
						 "Running&$userip&$accept"
					kill $tail_pid 2>/dev/null; break
				;;
				*"Session: Display failure detected at"*)
					# Reconnection failure
					echo "NX> 596 Error: Session $1 failed. Reason was: $line"
					kill $tail_pid 2>/dev/null; break
				;;
			esac
		fi
	done

	trap "" EXIT

	[ "$1" != "restore" -a "$rootless" != "1" ] && {
		nxlog "$lp call node_stop_services at ending"
		node_stop_services;
	}
	# close all open file descriptors
	exec 0<&-; exec 1>&-; exec 2>&-;
	nxlog "$lp end"
	exit_proc 0
}

startsession() { # Start a new session.
# 1.5.0 options: rdpcolors,rdpcache,http
# nxclient > 1.5.0-106 variables: resize,keybd
# FreeNX specific variables: clientproto,status,host
# NX 3.0 shadow mode related variables: shadowusername,shadowcookie,
# shadowdisplay,shadowhost
# Authentication method needed by guest mode: login_method
# dimbor: additional extra-channels extra[1-3], patched nxcomp both
# on server and client are required

	local lp="$FUNCNAME ($$/$BASHPID):";
	local opt_vars opt_str pack cleanup product clipboard menu;
	local id fullscreen accept vn;
	nxlog "$lp starting with args \"$@\""

	[ "$1" = "start" ] && mkdir -p -m700 "$NXSESSION_DIRECTORY"
	# Setup environment
	[ -n "$SOURCE_SYS_PROFILE" ] && . "$SOURCE_SYS_PROFILE"
	[ -n "$SOURCE_USER_PROFILE" ] && . "$SOURCE_USER_PROFILE"

	[ "$PROXY_TCP_NODELAY" = "0" ] && nodelay=0
	[ "$ENABLE_ROOTLESS_MODE" = "0" ] && rootless=0
	[ -z "$samba" ] && samba=0; [ -z "$media" ] && media=0
	[ -z "$shmem" ] && shmem=0; [ -z "$shpix" ] && shpix=0
	[ "$geometry" = "fullscreen" ] && fullscreen="1" || fullscreen="0"
	[ "$ENABLE_EXTERNAL_NXDESKTOP_KEYBOARD" = "1" ] && \
		agent_keyboard=$(cutfn "$keyboard" 1 '/') || agent_keyboard=""
	[ -z "$nodelay" ] && nodelay=1 # ???
	cleanup=10; product=LFE/None/LFEN/None; id=$sess_id;
	clipboard="$ENABLE_CLIPBOARD"; menu="$ENABLE_PULLDOWN_MENU"
	windows_app=$application
	[ -z "$keybd" ] && keybd=$aux # backwards compatibility for keybd parameter

	[ "$EXPORT_USERIP" = "1" ] && export NXUSERIP="$userip"
	[ "$EXPORT_SESSIONID" = "1" ] && export NXSESSIONID="$sess_id"
	export SHADOW_XAUTHORITY="$NXSESSION_DIRECTORY/authority"
	# export the agent_* options for the helper scripts
	if [ "$freenx_export_agents" = "1" ]; then
		local export_vars="agent_user agent_password export agent_server\
 agent_domain windows_app agent_keyboard NXSESSION_DIRECTORY\
 AGENT_EXTRA_OPTIONS_RFB AGENT_EXTRA_OPTIONS_RDP COMMAND_RDESKTOP\
 COMMAND_VNCVIEWER COMMAND_VNCPASSWD COMMAND_X11VNC PATH_BIN shadowdisplay\
 shadowhost shadowuser shadowcookie ENABLE_SESSION_SHADOWING_AUTHORIZATION\
 ENABLE_INTERACTIVE_SESSION_SHADOWING"
		for vn in $export_vars; do export "$vn"; done
		# We do not want to suspend such a session
		# as RDP/RFB are both suspendable as well
		ENABLE_PERSISTENT_SESSION=""
	fi

	if [ "$encryption" = "1" ]; then
		# we need to use the IP of the "calling" server now
		accept=$(rematchfn "($ip4_pattern)" "$SSH_CLIENT $SSH2_CLIENT") #"
		# If host is the same, use 127.0.0.1, else fallback to default
		[ -z "$accept" -a "$host" = "127.0.0.1" ] && accept="127.0.0.1"
	else encryption=0; accept=$userip
	fi

	# We need our own external IP
	proxyip="$EXTERNAL_PROXY_IP"; [ -z "$proxyip" ] && proxyip="127.0.0.1"

	pack=""
	if [ -z "$imagecompressionlevel" ]; then imagecompressionlevel="9"
	elif [ "$imagecompressionmethod" = "0" ]; then pack="nopack"
	elif [ "$imagecompressionmethod" = "1" ]; then pack="16m-jpeg-$imagecompressionlevel"
	elif [ "$imagecompressionmethod" = "2" ]; then pack="16m-png-9"
	fi

	if [ "$1" = "start" ]; then
		cookie=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM); cookie=${cookie%% *}
		# add row to usses with defaults: session_id, status, display, type,
		# agent_pid, cookie, tail_pid, userip, acc_ip, mmport, cupsport, smbport
		usess_add "$sqcols_usess" "$session_id&Starting&$display&$type&\
0&$cookie&0&$userip&$accept&0&0&0&0&"
	elif [ "$1" = "restore" ]; then
		cookie=$(usess_get "$session_id" "cookie")
	fi

	if [ "$1" = "application" ]; then
		# This needs to be set, else nxagent is terminated
		rootless="1"; virtualdesktop="0"
		nxlog "$lp call 'node_start_applications'"
		node_start_applications &
		echo "NX> 596 Application $application started successfully."
		return
	fi

	nxlog "$lp generate \"$NXSESSION_DIRECTORY/options\""
	opt_vars="keyboard kbtype kbload keymap geometry\
 client resize cache images pack link nodelay type clipboard composite\
 cleanup product shmem backingstore shpix accept cookie id samba media\
 sync cups keybd aux http extra1 extra2 extra3 rdpcolors rdpcache\
 fullscreen menu"
	opt_str="nx/nx";
	for vn in $opt_vars; do [ -n "${!vn}" ] && opt_str+=",$vn=${!vn}"; done
	opt_str+=":$display"
	# write options file
	umask 0077;	echo "$opt_str" > "$NXSESSION_DIRECTORY/options"; umask $umask0

	if [ "$1" = "start" ]; then # write xauth script file
		nxlog "$lp write xauth script file"
		txt="add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
add :$display MIT-MAGIC-COOKIE-1 $cookie
exit"
		echo "$txt" | $COMMAND_XAUTH >/dev/null 2>&1
		echo "$txt" | $COMMAND_XAUTH -f "$NXSESSION_DIRECTORY/authority" >/dev/null 2>&1
	fi

	# If we have a shadow cookie, we add it to xauth session authority file as well
	if [ -n "$shadowcookie" ]; then
		nxlog "$lp If we have a shadow cookie, we add it to xauth session authority file as well"
		$COMMAND_XAUTH -f "$SHADOW_XAUTHORITY" add "$shadowhost:$shadowdisplay" MIT-MAGIC-COOKIE-1 "$shadowcookie"
	elif [ -n "$shadowdisplay" ]; then
		# we need to merge in the normal .Xauthority file
		nxlog "$lp we need to merge in the normal .Xauthority file"
		$COMMAND_XAUTH -f "$SHADOW_XAUTHORITY" merge "$HOME/.Xauthority"
	fi

	if [ "$1" = "restore" ]; then
		nxlog "$lp restore session"
		#echo > "$NXSESSION_DIRECTORY/session" #this cause to damage file
		sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '"$NXSESSION_DIRECTORY"'/session' | node_start_monitor "restore" &
		MONITOR_PID=$!; export MONITOR_PID
		nxlog "$lp call 'node_suspend_session \"$session_id\"'"
		node_suspend_session "$session_id" || { echo "Info: Reconnection failed: NX Agent process could not be found." >>"$NXSESSION_DIRECTORY/session"; node_fail_restore_session "$session_id"; }
	else # start
		nxlog "$lp call 'node_start_agent'"
		node_start_agent &
		nxlog "$lp call 'node_start_applications'"
		node_start_applications &
		if [ -x "$NODE_AUTOSTART" ]; then
			nxlog "$lp NODE_AUTOSTART: waiting for nxagent"
			local cntr=$((AGENT_STARTUP_TIMEOUT*100)); local cntr0=$cntr
			while [ ! -f /tmp/.X$display-lock ]; do
				sleep 0.01s; ((cntr--)); ((cntr<=0)) && break
			done
			nxlog "$lp NODE_AUTOSTART: Stop waiting $((cntr0-cntr))0 ms"
			# go into background immediately
			NXSESSIONID="$sess_id" DISPLAY=:$display "$NODE_AUTOSTART" "$1" >/dev/null 2>&1 &
			disown $! # dont't wait for this child!
		fi
	fi

	if [ -n "$MONITOR_PID" ]; then
		wait "$MONITOR_PID"
		usess_set "$session_id" "tail_pid" "0"
	fi
	wait # for all children
	nxlog "$lp end"
}

cmd_node_terminate() {
	echo "$delim 716 Terminating session $session_id on user request."
	node_terminate_session "$session_id"
}

cmd_node_suspend() {
	echo "$delim 716 Suspending session $session_id on user request."
	node_suspend_session "$session_id"
}

# -----------------------------------------------------------------------------
# Startup of nxnode
# -----------------------------------------------------------------------------
declare -g delim="NX>" CMDLINE="" nx_dir nxuser_logfile umask0=$(umask);
open_dbe $$

[ -n "$2" ] && delim="NX-$2>"
echo "$delim 1000 NXNODE - Version $NX_VERSION $NX_LICENSE"

if [ "$USER" = "nx" ]; then
	nx_dir="/var/lib/nxserver/home" # ???
	nxuser_logfile="/var/log/nx/nxnode.log"
else
	nx_dir="$HOME/.nx"
	[ -d $nx_dir ] || { umask 0077; mkdir -p $nx_dir; umask $umask0; }
	nxuser_logfile="$nx_dir/nxnode.log"
fi

attach_db "$nx_dir/usessions.sq3" && {
	init_usessions_db; chmod 0600 "$nx_dir/usessions.sq3" >/dev/null 2>&1; }

if ! stringinstring "$1" "--check|--setkey|--agent"; then
	read CMDLINE;
	set_vars_from_ampstr "$CMDLINE" "" "recode"
	if [ -z "$session_id" ]; then
		echo "NX> 500 Error: Fatal - Missing parameter session id." 1>&2
		exit_proc 1
	fi
	declare -g sess_id="$SERVER_NAME-$display-$session_id"
	declare -g NXSESSION_DIRECTORY="$nx_dir/C-$sess_id"
	nxuser_logfile="$nx_dir/nxnode-$session_id.log"
	nxlog "$0 ($$): run nxnode with PARAMS:\"$@\"; CMDLINE='$CMDLINE'"
else
	nxlog "$0 ($$): run nxnode with \"$@\""
fi

case "$1" in
	--startsession)
		startsession "start"
	;;
	--resumesession)
		startsession "restore"
	;;
	--applicationsession)
		startsession "application"
	;;
	--terminate)
		cmd_node_terminate
	;;
	--suspend)
		cmd_node_suspend
	;;
	--smbmount)
		#cmd_node_smbmount
	;;
	--addprinter)
		#cmd_node_addprinter
	;;
	--check)
		echo "NX> 716 finished"
	;;
	--agent)
		echo "NX> 716 Starting NX Agent ..."
		shift
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		PATH="$PATH:$PATH_BIN" $COMMAND_NXAGENT \
			-name "NX Agent Test - Args: $@" $@
		echo "NX> 716 NX Agent exited with status: $?"
	;;
	--setkey)
		mkdir -m 700 -p $HOME/.ssh
		if ! grep -q "$(cat $NX_ETC_DIR/users.id_dsa.pub)" $HOME/.ssh/$SSH_AUTHORIZED_KEYS 2>/dev/null; then
			cat $NX_ETC_DIR/users.id_dsa.pub >> $HOME/.ssh/$SSH_AUTHORIZED_KEYS
			chmod 600 $HOME/.ssh/$SSH_AUTHORIZED_KEYS
			echo "NX> 716 Public key added to: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
		else
			echo "NX> 716 Public key is already present in: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
		fi
	;;
	*)
		echo "NX> 500 Error: Command not found"
	;;
esac

echo "$delim 1001 Bye."
exit_proc 0
