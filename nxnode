#!/bin/bash

# Free implementation of nxserver components
# Copyright (c) 2004 by Fabian Franz.
#           (c) 2008-19 by Dmitry Borisov <i@dimbor.ru>
# License: GNU GPL, version 2

shopt -s extglob

# Read the config file
# dimbor: it's temporary
. /usr/bin/nxloadconfig --userconf

. $SHARED_CONFS/nxfuncs
#
# -----------------------------------------------------------------------------
# Various helper functions
# -----------------------------------------------------------------------------
#
echo_secure() {
	if [ "$NX_LOG_SECURE" = "0" ]; then echo "$@"
	else echo "${@/password=+([^&])&/password=****&}"
	fi
}

nxlog() {
	[ "$NX_LOG_LEVEL" -lt 6 ] && return 0
	echo_secure "$(date "+%T.%3N"): $@" >> "$nxuser_logfile"
}

cp_conv() {
# arg: string
# convert string charset
	local lp="$FUNCNAME ($$/$BASHPID):";
	#nxlog "$lp starting with args \"$@\""
	local res=${1//+/ } cp_pair cp_from cp_to;
	for cp_pair in $WIN_CP_CONVERT_CHAIN ; do
		cp_from=$(cutfn "$cp_pair" '>' 0); [ -n "$cp_from" ] || cp_from="UTF-8"
		cp_to=$(cutfn "$cp_pair" '>' 1); [ -n "$cp_to" ] || cp_to="UTF-8"
		res=$(echo "$res" | iconv -f $cp_from -t $cp_to)
		#nxlog "$lp converting $cp_from > $cp_to == \"$res\""
	done
	#nxlog "$lp return res='$res'"
	echo "$res"
}

#
# -----------------------------------------------------------------------------
# Node functions module
# -----------------------------------------------------------------------------
#

# dimbor: functions to control user's shares and printers in mode "per user"
# instead of "per session".

get_mport2sessdir() {
# args: session dir type="smb"|"ipp""
# ret: cups listening port or samba mount port
	local lp="$FUNCNAME ($$/$BASHPID):";
	local type=$2 mport="" smbport cport;
	[ -r "$1/scripts/mport" ] && 	smbport=$(< $1/scripts/mport)
	[ -r "$1/session" ] && cport=$(< $1/session);
	cport=$(rematchfn "Listening to CUPS.+'(.+)'" "$cport" 0 "rev") #'
	if [ "$type" != "smb" -a -n "$cport" ]; then mport=$cport; type="ipp";
	elif [ "$type" != "ipp" -a  -n "$smbport" ]; then
		mport=$smbport; type="smb";
	fi
	mport=${mport##*:}
	nxlog "$lp sessdir \"$1\"; mport='$mport' type='$type'"
	echo $mport
}

get_sessdir4res() {
# args: port - session's smb/ipp mount port OR filename of printer/share
# (flag-file) fl_current - if set then includes in search current session-dir
# if share is nx-controlled and nxagent from his session are leave,
# then returns name of session dir (except dir of own sesson)
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting with args \"$@\"; sess_id='$sess_id'"
	local digarg agent_pids sessdir node_agent_pid curport;
	[ "$1" -gt 0 2>/dev/null ] && digarg=1 || digarg=0
	agent_pids=$(ps -wo pid= -C "nxagent")
	for sessdir in $nx_dir/C-* ; do
		[ -z "$2" -a "$sessdir" == "$nx_dir/C-$sess_id" ] && continue
		node_agent_pid=""
		[ -r "$sessdir/pids/agent" ] && node_agent_pid=$(< $sessdir/pids/agent)
		[ -z "$node_agent_pid" ] && continue
		stringinstring "$node_agent_pid" "$agent_pids" || continue
		#nxlog "$lp browse sessdir \"$sessdir\" for filename = \"$sessdir/scripts/$1\", digarg=$digarg"
		if [ "$digarg" = "1" ]; then
			curport=$(get_mport2sessdir "$sessdir")
			[ "$curport" = "$1" ] && {
				nxlog "$lp found sessdir='$sessdir' for mport = $1"
				echo "$sessdir"; return;
			}
		else
			[ -f "$sessdir/scripts/$1" ] && {
				nxlog "$lp found sessdir='$sessdir' for filename = $1"
				echo "$sessdir"; return;
			}
		fi
	done
	nxlog "$lp target sessdir not found"
}

check_local_pa_tunnel() {
# params:	tunnel ip:port
#		resample rate
#		amount of channels
# return:	pid of pa process
# This starts user's local pulseaudio server if not running and tune its own
# modules - (re)create tunneled sink and source to remote pa
	local lp="$FUNCNAME ($$/$BASHPID):";
	local errstr retpid lpa_mods tunn_opts tunn_exists mname rmids rpa_info;
	local errids="" errstr="" errstr2="" mname_tunn_sink mname_tunn_source;
	local success="" def_rsink def_rsource rsi_args rso_args
	local pactl_bin="env LANG=C /usr/bin/pactl"
	unset PULSE_SERVER; unset PULSE_SINK; unset PULSE_SOURCE
	# automatic start user's pa is here (pa starting with default system settings)
	errstr=$($pactl_bin info 2>&1)
	[ -n "$(rematchfn '(failure)' "$errstr")" ] && {
		nxlog "$lp Local PA is not reachable ($errstr)."
		echo ""; return 1;
	}
	retpid=$(ps -wo pid= -C "pulseaudio")
	[ -n "$retpid" ] && nxlog "$lp Found PA:$retpid"
	lpa_mods=$($pactl_bin list short 2>/dev/null)
	tunn_opts="server=$1"
	tunn_exists=$(rematchfn "($tunn_opts)" "$lpa_mods") #"
	[ -n "$tunn_exists" ] && {
		nxlog "$lp Right modules already exists: $tunn_exists"
		echo $retpid; return 0;
	}
	mname="module-always-sink" # automatic null-sinks will be disabled
	rmids=$(rematchfn "^([[:digit:]]+)[[:space:]]+$mname" "$lpa_mods") #"
	# any sinks and sources will be unloaded too
	rmids+="${rmids:+ }$(rematchfn "^([[:digit:]]+).+sink_name" "$lpa_mods")" #"
	rmids+="${rmids:+ }$(rematchfn "^([[:digit:]]+).+source_name" "$lpa_mods")" #"
	[ -n "$rmids" ] && {
		for i in $rmids; do
			errstr2=$($pactl_bin unload-module $i 2>&1)
			[ $? -ne 0 ] && { errids+=" $i"; errstr+="; $errstr2"; }
		done
	}
	[ -n "$errids" ] && {
		nxlog "$lp Removing PA modules error. errids='$errids'; errsrr='$errstr' "
	}
	mname_tunn_sink="module-tunnel-sink"; mname_tunn_source="module-tunnel-source";
	rpa_info=$($pactl_bin -s $1 info 2>/dev/null)
	[ -z "$rpa_info" ] && {
		nxlog "$lp Couldn't get defaults from REMOTE pulseaudio $1."
		echo ""; return 1;
	}
	[ -n "$2" ] && {
		tunn_opts+=" rate=$2"
		[ -n "$3" ] && {
			tunn_opts+=" channels=$3"
			[ "$3" == "1" ] && tunn_opts+=" channel_map=mono"
		}
	}
	def_rsink=$(rematchfn "Default Sink:[[:space:]]+(.+)" "$rpa_info") #"
	if [ -z "$def_rsink" -o "$def_rsink" == "(null)" ]; then
		nxlog "$lp Couldn't get default sink from REMOTE pulseaudio $1."
	else # load module-tunnel-sink
		rsi_args="sink_name=tcl_out sink=$def_rsink $tunn_opts"
		errstr=$($pactl_bin load-module $mname_tunn_sink $rsi_args 2>&1)
		[ $? -ne 0 ] && {
			nxlog "$lp Loading module $mname_tunn_sink error (\"$rsi_args\"); \"$errstr\""
		} || {
			success="1"
			nxlog "$lp Successfully loadded module $mname_tunn_sink  (\"$rsi_args\")."
		}
	fi
	def_rsource=$(rematchfn "Default Source:[[:space:]]+(.+)" "$rpa_info") #"
	if [ -z "$def_rsource" -o "$def_rsource" == "(null)" -o \
			"$def_rsource" == "$def_rsink.monitor" ]; then
		nxlog "$lp Couldn't get default source from REMOTE pulseaudio $1."
	else # load module-tunnel-source
		rso_args="source_name=tcl_in source=$def_rsource $tunn_opts"
		errstr=$($pactl_bin load-module $mname_tunn_source $rso_args 2>&1)
		[ $? -ne 0 ] && {
			nxlog "$lp Loading module $mname_tunn_source error (\"$rso_args\"); \"$errstr\""
		} || {
			success="1"
			nxlog "$lp Successfully loadded module $mname_tunn_source  (\"$rso_args\")."
		}
	fi
	[ -n "$success" ] && echo $retpid || echo ""
}

reconnect_pa() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	local mmport="" papars="" node_agent_pid rate channels papid="" agent_pids;
	local sessdir;
	[ -r "$nx_dir/C-$sess_id/scripts/pa_pid" ] && \
		papid=$(< $nx_dir/C-$sess_id/scripts/pa_pid)
	[ -z "$papid" ] && return
	agent_pids=$(ps -wo pid= -C "nxagent")
	for sessdir in $nx_dir/C-*; do # start port search
		[ "$sessdir" == "$nx_dir/C-$sess_id" ] && continue
		node_agent_pid=""; [ -r "$sessdir/pids/agent" ] && \
			node_agent_pid=$(< $sessdir/pids/agent)
		[ -z "$node_agent_pid" ] && continue
		stringinstring $node_agent_pid "$agent_pids" || continue
		mmport=""; [ -r "$sessdir/scripts/mmport" ] && \
			mmport=$(< $sessdir/scripts/mmport)
		[ -n "$mmport" ] && break
	done
	if [ -n "$mmport" ]; then # try reconnect
		papars=$(< $nx_dir/C-$sess_id/scripts/params.pa)
		rate=$(cutfn "$papars" ":" 0)
		channels=$(cutfn "$papars" ":" 1)
		[ -z "$(check_local_pa_tunnel 127.0.0.1:$mmport $rate $channels)" ] && {
			nxlog "$lp Couldn't reconnect PA tunnel to port $mmport."
		}
	else # kill local PA
		kill $papid 2>/dev/null
	fi
}

# node_terminate_agent <session id>
node_terminate_agent() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	local node_agent_pid;
	[ -r "$nx_dir/C-$1/pids/agent" ] && \
		node_agent_pid=$(< $nx_dir/C-$1/pids/agent)
	[ -n "$node_agent_pid" ] && {
		nxlog "$lp killing node_agent_pid='$node_agent_pid'"
		kill $node_agent_pid 2>/dev/null;
		sleep 0.3s
	}
	kill -0 $node_agent_pid && {
		nxlog "$lp killing node_agent_pid. Try #2"
		kill -9 $node_agent_pid 2>/dev/null
	}
	nxlog "$lp end"
}

# node_terminate_session <session id>
#	Used glob vars: $virtualdesktop, $rootless
#	Used config vars: $COMMAND_XAUTH, $SESSION_LOG_CLEAN
node_terminate_session() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	local node_agent_pid node_tail_pid="" display sessdir
	nxlog "$lp Start terminating session \"$1\" with status \"$2\""
	sessdir="$nx_dir/C-$1"
	[ -e "$sessdir/terminating" ] && {\
		nxlog "$lp Terminating still in progress. Bye."
		return;
	}
	[ -d "$sessdir" ] || {\
		nxlog "$lp Session directory not found."
		return;
	}
	touch "$sessdir/terminating"

	# Kill nxagent
	[ -r "$sessdir/pids/agent" ] && \
		node_agent_pid=$(< $sessdir/pids/agent)

	# JJK: Kill running services
	# FF: Seems this is needed also here ...
	# dimbor: ... but have to be a little more tender ;)
	nxlog "$lp call node_stop_services"
	node_stop_services
	if [ -n "$node_agent_pid" ]; then
		nxlog "$lp start killing of nxagent"
		kill $node_agent_pid 2>/dev/null
		wait $node_agent_pid 2>/dev/null
		kill -0 $node_agent_pid ||
			nxlog "$lp nxagent ($node_agent_pid) is dead now"
	fi

	# Kill tail process
	[ -r "$sessdir/pids/tail" ] && {
		node_tail_pid=$(< $sessdir/pids/tail)
		nxlog "$lp kill tail process"
		kill $node_tail_pid 2>/dev/null;
	}

	# Remove display information
	nxlog "$lp Remove display information"
	display=$(cutfn "$1" "-" -2)
	rm -f /tmp/.X$display-lock; rm -f /tmp/.X11-unix/X$display

	# Remove magic cookie information
	nxlog "$lp Remove magic cookie information"
	$COMMAND_XAUTH -v source "$nx_dir/C-$1/scripts/authority" >/dev/null 2>&1

	# Preserve or remove session information
	nxlog "$lp Preserve or remove session information"
	if [ "$SESSION_LOG_CLEAN" = "1" ]; then
		nxlog "$lp Clean session information."
		rm -rf "$nx_dir/C-$1/"
		rm -f  "$nx_dir/nxnode-$1.log"
		rm -f  "$nx_dir/nxnode.log"
	fi
	if [ "$SESSION_LOG_CLEAN" = "0" -a "$2" = "failed" ] ; then
		nxlog "$lp Session failed. Rename session directory from \"$nx_dir/C-$1/\" to \"$nx_dir/F-C-$1\""
		mv "$nx_dir/C-$1/" "$nx_dir/F-C-$1"
		rm -f "$nx_dir/F-C-$1/terminating"
	elif [ "$SESSION_LOG_CLEAN" = "0" -a "$2" != "failed" ] ; then
		nxlog "$lp Session terminated. Rename session directory from \"$nx_dir/C-$1/\" to \"$nx_dir/T-C-$1\""
		mv "$nx_dir/C-$1/" "$nx_dir/T-C-$1"
		rm -f "$nx_dir/T-C-$1/terminating"
	fi
	nxlog "$lp end"
}


# node_fail_restore_session <session id>
# TODO: Kill still running tail -f process.
node_fail_restore_session() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	local node_tail_pid;
	nxlog "$lp starting"
	echo "NX> 1004 Error: Could not resume session. nxagent process could not be found."
	[ -r "$nx_dir/C-$sess_id/pids/tail" ] && {
		node_tail_pid=$(< $nx_dir/C-$sess_id/pids/tail)
		nxlog "$lp kill tail process"
		kill $node_tail_pid 2>/dev/null;
		echo "NX 1004> kill $node_tail_pid"
	}
	node_terminate_session "$1" "failed"
	nxlog "$lp end. Next is 'exit 1'"
	exit 1
}


# node_suspend_session <session id>
node_suspend_session() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	local node_agent_pid;
	[ -r "$nx_dir/C-$1/pids/agent" ] && \
		node_agent_pid=$(< $nx_dir/C-$1/pids/agent)
	if [ -n "$node_agent_pid" ]; then
		nxlog "$lp node_agent_pid='$node_agent_pid' Killing..."
		kill -0 $node_agent_pid || {
			nxlog "$lp end (0)"
			return 1;
		}
		kill -HUP $node_agent_pid && {
			nxlog "$lp end (HUP)"
			return 0;
		}
	else nxlog "$lp node_agent_pid is empty; end"
	fi
	return 1
}


# node_find_application <type>
#	Used config vars: $COMMAND_START_KDE, $COMMAND_START_GNOME,
#			  $COMMAND_START_CDE, $COMMAND_XTERM, $USER_X_STARTUP_SCRIPT,
#			  $DEFAULT_X_SESSION
node_find_application() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting with args \"$@\""
	local node_startx=""
	case $1 in
		shadow|windows|vnc)
			:
		;;
		unix-kde)
			node_startx=$COMMAND_START_KDE
			[ "$KDE4_ENABLE" = "1" -a -n "$COMMAND_START_KDE" ] && \
				node_startx=$COMMAND_START_KDE4
		;;
		unix-gnome)
			node_startx=$COMMAND_START_GNOME
		;;
		unix-cde)
			node_startx=$COMMAND_START_CDE
		;;
		windows-helper)
			application="$PATH_BIN/nxdesktop_helper"
			node_startx=$application
		;;
		unix-application|vnc-helper)
			[ "$application" = "xterm" ] && application=$COMMAND_XTERM
			node_startx=$application
		;;
		unix-console)
			node_startx=$COMMAND_XTERM
		;;
		unix-default|*)
			if [ -x "$HOME/$USER_X_STARTUP_SCRIPT" ]; then
				node_startx="$HOME/$USER_X_STARTUP_SCRIPT"
			elif [ -x "$DEFAULT_X_SESSION" ]; then
				node_startx="$DEFAULT_X_SESSION"
			else node_startx=$COMMAND_XTERM
			fi
		;;
	esac

	# dimbor: another personalyzed way to ACLS control and replace X-application
	[ -d "$NX_ACL_DIR" -a -x "$PATH_BIN/nxacl.app" ] && {
		nxlog "$lp !!! call nxacl.app with source node_startx='$node_startx'"
		node_startx=$($PATH_BIN/nxacl.app "$node_startx" "$CMDLINE")
	}

	echo "$node_startx"
	nxlog "$lp return node_startx='$node_startx'"
}

get_pa_sound_mode() {
# params:	port of pa server
#		ipaddr
	local lp="$FUNCNAME ($$/$BASHPID):";
	local cl_pa_mods
	[ -z "$2" ] && {
		nxlog "$lp Client's IP-address is not defined."
		echo ""; return 1;
	}
	stringinstring "open" "$($COMMAND_NETCAT -nvz -w 1 $2 $1 2>&1)" || {
		nxlog "$lp Client's pulseaudio at $2:$1 is not reachable."
		echo ""; return 1;
	}
	pactl_bin="env LANG=C /usr/bin/pactl -s $2:$1"
	nxlog "$lp $pactl_bin list short"
	cl_pa_mods=$($pactl_bin list short)
	#nxlog "$lp $cl_pa_mods"
	stringinstring "ts_receiver" "$cl_pa_mods" && \
		stringinstring "ts_sender" "$cl_pa_mods" && {
		nxlog "$lp Specials sink and source at $2:$1 are found."
		echo "special"; return 0;
	}
	nxlog "$lp Defaults sink and source at $2:$1 be used."
	echo "default"; return 0;
}

# node_start_applications
#	Used glob vars: $type, $application, $sess_id, $mediahelper,
#				 $virtualdesktop, $rootless, $display
#	Used config vars: <several>
node_start_applications() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	local node_app mmode rate channels mmport pa_remote pa_pid params;
	local native_sound_mode second_app="" sapp_pids0="" napp;
	local spid node_app_pid sapp_pids="" sapp_pids1 node_wm_pid;
	# close input and output file descriptors
	exec 0<&-; exec 1>&-; exec 2>&-

	# Prepare application startup
	export DISPLAY=:$display
	if [ "$ENABLE_SOURCE_PROFILE" = "1" ]; then
		nxlog "$lp source profile"
		. /etc/profile
	fi
	if [ "$ENABLE_SOURCE_BASH_PROFILE" = "1" ]; then
		nxlog "$lp source bash profile"
		[ -f ~/.bash_profile ] && . ~/.bash_profile
		[ -f /etc/bashrc ] && . /etc/bashrc
	fi

	nxlog "$lp display='$display', waiting for it's ready"
	local cntr=$((AGENT_STARTUP_TIMEOUT*100)); local cntr0=$cntr
	while [ ! -f /tmp/.X$display-lock ]; do
		sleep 0.01s; ((cntr--)); ((cntr<=0)) && break
	done
	nxlog "$lp Stop waiting for DISPLAY $((cntr0-cntr))0 ms"

	#numlockx
	if [ "$NUMLOCKX_STATUS" != "system" ]; then
		nxlog "$lp Run \"$NUMLOCKX $NUMLOCKX_STATUS\""
		"$NUMLOCKX" "$NUMLOCKX_STATUS"
	fi

	mkdir -p "$NXSESSION_DIRECTORY/pids/apps/"
	# Which application do we start?
	node_app=$(node_find_application "$type")
	# For rdesktop/VNC, there is no application to start
	if [ -n "$node_app" ]; then
		nxlog "$lp Got node_app is \"$node_app\""
	else
		nxlog "$lp node_app is empty"
		return
	fi

	# Check if we want to use a mediahelper
	mmode="$(cutfn "$mediahelper" "-" 0)"
	rate="$(cutfn "$mediahelper" "-" 1)"
	channels="$(cutfn "$mediahelper" "-" 2)"
	[ -r "$NXSESSION_DIRECTORY/scripts/mmport" ] && \
		mmport="$(< $NXSESSION_DIRECTORY/scripts/mmport)"
	if [ "$mmode" == "pa" -a -n "$mmport" ]; then
		pa_remote="127.0.0.1:$mmport"
		pa_pid="$(check_local_pa_tunnel $pa_remote $rate $channels)"
		if [ -n "$pa_pid" ]; then
			nxlog "$lp Local pulseaudio is started ($pa_pid). Sound mode set to tunneled."
			echo $pa_pid > "$NXSESSION_DIRECTORY/scripts/pa_pid"
			params=$rate
			[ -n "$channels" ] && params+=":$channels"
			[ -n "$params" ] && echo "$params" > "$NXSESSION_DIRECTORY/scripts/params.pa"
		else
			nxlog "$lp Local pulseaudio NOT STARTED. Set PULSE_SERVER=127.0.0.1:$mmport"
			export PULSE_SERVER="127.0.0.1:$mmport"
		fi
	elif [ "$ENABLE_DIRECT_NATIVE_PA_CHECK" = "1" ] ; then
		native_sound_mode="$(get_pa_sound_mode 4713 $NXUSERIP)"
		if [ -n "$native_sound_mode" ]; then
			nxlog "$lp Sound mode set to direct $native_sound_mode"
			export PULSE_SERVER="$NXUSERIP:4713"
			if [ "$native_sound_mode" = "special" ]; then
				export PULSE_SINK="ts_receiver"
				export PULSE_SOURCE="ts_sender.monitor"
			fi
			node_app="/usr/bin/padsp $node_app"
		fi
	fi

	[ "$cups" = "1" -o "$samba" = "1" ] && {
		nxlog "$lp export CUPS_SERVER=$CUPS_DEFAULT_SOCK"
		export CUPS_SERVER=$CUPS_DEFAULT_SOCK
	}
	if [ "$ENABLE_SAMBA_PRELOAD" = "1" -a -x "$PATH_BIN/nxredir" ]; then
		let NXSAMBA_PORT=$display+3000
		export NXSAMBA_PORT
		nxlog "$lp Preload SAMBA using nxredir. NXSAMBA_PORT is \"$NXSAMBA_PORT\""
		node_app="$PATH_BIN/nxredir $node_app"
		echo "Info: NXNODE - Using nxredir wrapper script to forward SMB ports 139 and 445 to port $NXSAMBA_PORT." >> "$NXSESSION_DIRECTORY/session"
	fi


	# Do we need to PRELOAD any libraries?
	[ "$virtualdesktop" = "0" -a "$rootless" != "1" ] && export LD_PRELOAD="$APPLICATION_LIBRARY_PRELOAD:$LD_PRELOAD"

	# Should we start a window manager?
	if [ "$virtualdesktop" = "1" -a "$type" = "unix-application" -a \
			-x "$DEFAULT_X_WM" ]; then
		nxlog "$lp start a window manager - \"DISPLAY=:$display $DEFAULT_X_WM\""
		DISPLAY=:$display $DEFAULT_X_WM >>"$NXSESSION_DIRECTORY/session" 2>&1 &
		node_wm_pid=$!
		nxlog "$lp node_wm_pid='$node_wm_pid'}"
	fi

	# Use Xsession to execute the Desktop session
	case $type in
		unix-gnome)
			export STARTUP="$node_app"
			if [ "$login_method" = "GUEST" ]; then
				node_app=$COMMAND_GUEST_X_SESSION
			elif [ "$BOOTSTRAP_X_SESSION" = "1" ]; then
				node_app=$COMMAND_GDM_X_SESSION
			fi
		;;
		unix-kde|unix-cde)
			export STARTUP="$node_app"
			if [ "$login_method" = "GUEST" ]; then
				node_app=$COMMAND_GUEST_X_SESSION
			elif [ "$BOOTSTRAP_X_SESSION" = "1" ]; then
				node_app=$DEFAULT_X_SESSION
			fi
		;;
	esac

	[ $ENABLE_ROOTLESS_TERMINATE_SESSION = "1" -a "$rootless" = "1" ] && {
		napp=$(cutfn "$node_app" " " 0); napp=$(cutfn "$napp" "/" -1)
		second_app=$(rematchfn "$napp:(.+)" "${APP_WAIT_MAP//;/$'\n'}") #"
		[ -n "$second_app" ] && {
			sapp_pids0=$(ps -wo pid= -C $(cutfn "$second_app" "/" -1))
			nxlog "$lp PID of $second_app will be waiting too. Initial: \"$sapp_pids0\""
		}
	}

	# Startup the application
	nxlog "$lp Starting node_app with /etc/nxserver/Xsession"
	DISPLAY=:$display /etc/nxserver/Xsession $node_app >> \
		"$NXSESSION_DIRECTORY/session" 2>&1 &
	node_app_pid=$!
	nxlog "$lp Start successful. node_app_pid='$node_app_pid'"

	mkdir -p "$NXSESSION_DIRECTORY/pids/"
	echo "$node_app_pid" >"$NXSESSION_DIRECTORY/pids/apps/$node_app_pid"
	nxlog "$lp Waiting for node_app_pid"
	wait $node_app_pid
	nxlog "$lp node_app_pid finished"

	# Kill or wait for the started window manager
	[ -n "$node_wm_pid" ] && {
		nxlog "$lp node_wm_pid is not empty"
		# kill the WM after application is finished?
		[ "$KILL_DEFAULT_X_WM" = "1" ] && { nxlog "$lp killing $node_wm_pid"
			kill $node_wm_pid 2>/dev/null; }
		# or just wait until it finishes?
		[ "$KILL_DEFAULT_X_WM" = "1" ] || { nxlog "$lp wait for $node_wm_pid is dead"
			wait $node_wm_pid; }
	}
	nxlog "$lp Clean pids/apps/$node_app_pid"
	rm -f "$NXSESSION_DIRECTORY/pids/apps/$node_app_pid"
	sleep "$NODE_APP_WAIT_TIMEOUT"

	[ $ENABLE_ROOTLESS_TERMINATE_SESSION = "1" -a "$rootless" = "1"  ] && {
		if [ -n "$second_app" ] ; then
			sapp_pids1=$(ps -wo pid= -C $(cutfn "$second_app" "/" -1))
			while read spid; do
				stringinstring "$spid" "$sapp_pids0" && continue
				sapp_pids+="${sapp_pids:+$' '}$spid"
			done <<< "$sapp_pids1"
			nxlog "$lp Waiting for $second_app PID(S) \"$sapp_pids\""
			while [ -n "$(ps -o pid= -p $sapp_pids 2>/dev/null)" ]; do
				sleep 1s
			done
			nxlog "$lp PID(S) \"$sapp_pids\" finished"
			node_terminate_session "$sess_id"
		else  node_terminate_session "$sess_id"
		fi
	}

	# Do not terminate agent in case of rootless agent mode.
	# The agent times out after a while by itself anyway.
	if [ "$virtualdesktop" = "1" -o "$rootless" != "1" ] ; then
		nxlog "$lp Call node_terminate_agent for non-rootless or virtualdesktop session type"
		nxlog "$lp Call 'node_terminate_agent \"$sess_id\"'"
		node_terminate_session "$sess_id"
	fi
	nxlog "$lp end"
}


# node_persistent_session
# Is the user allowed to run a persistent session?
node_agent_persistent_session() {
	local username oifs p
	p="-nopersistent"
	# Guest sessions are always nonpersistent
	if [ "$login_method" = "GUEST" ]; then
		echo "$p"; return
	fi
	oifs=$IFS; IFS=","
	if [ "$ENABLE_PERSISTENT_SESSION" = "all" ]; then p="-persistent"
	else
		for username in $ENABLE_PERSISTENT_SESSION; do
			[ "${username:0:1}" != "@" ] && [ "$USER" = "$username" ] && \
				p="-persistent" && break;
			[ "${username:0:1}" = "@" ] && \
				[ -z $(groups "$USER" | egrep "^${username:1}:") ] && \
					p="-persistent" && break;
		done
	fi
	for username in $DISABLE_PERSISTENT_SESSION; do
		[ "${username:0:1}" != "@" ] && [ "$USER" = "$username" ] && \
			p="-nopersistent" && break;
		[ "${username:0:1}" = "@" ] && \
			[ -z $(groups "$USER" | egrep "^${username:1}:") ] && \
				p="-nopersistent" && break;
	done
	IFS=$oifs; echo "$p"
}

# node_start_agent
node_start_agent() {
	# Ok, now we do some wicked fd magic.
	# first part:	nxagent's fd #2 -> fd #3
	# second part:	fd #1 -> #4; fd #3 -> #1; tee | node_start_monitor
	# third part:	fd #4 -> #1
	# => all output of nxagent goes to tee | node_start_monitor, while
	#    leaving all other output flow through like normally.

	# preparations
	local lp="$FUNCNAME ($$/$BASHPID):";
	local k g b r fp vncfullscreen u p d agent_port viewonly
	local node_agent_exit_status node_failed
	nxlog "$lp starting"
	exec 3>&2; exec 4>&1;

	{

	{

	# Setup environment
	if [ "$ENABLE_SOURCE_PROFILE" = "1" ]; then
		nxlog "$lp source profile"
		. /etc/profile
	fi
	if [ "$ENABLE_SOURCE_BASH_PROFILE" = "1" ]; then
		nxlog "$lp source bash profile"
		[ -f ~/.bash_profile ] && . ~/.bash_profile
		[ -f /etc/bashrc ] && . /etc/bashrc
	fi

	export DISPLAY="nx/nx,options=$NXSESSION_DIRECTORY/options:$display"
	export XAUTHORITY="$NXSESSION_DIRECTORY/authority"
	export HOME="$USER_FAKE_HOME"
	export NX_CLIENT="$PATH_BIN/nxdialog"

	# Setup optional parameters for nxagent
	# keyboard
	k=""
	# backwards compatibility
	[ -n "$keyboard" ] && k="-keyboard $keyboard"
	[ -n "$kbtype" ] && k="-kbtype $kbtype"

	# backingstore
	b=""
	if [ -n "$backingstore" -a "$ENABLE_1_5_0_BACKEND" = "1" ]; then
		[ "$backingstore" != 1 ] && b="-bs $backingstore"
		[ "$backingstore" = 1 ] && b="+bs"
	fi

	# geometry
	g=""
	[ -n "$geometry" ] && g="-geometry $geometry"

	# type of session
	r="-D"; [ "$rootless" = "1" ] && r="-R"

	# Setup fullscreen parameters
	vncfullscreen=""
	[ "$geometry" = "fullscreen" -a "$type" = "vnc" ] && \
		vncfullscreen="-fullscreen" && g=""
	[ "$geometry" = "fullscreen" -a "$type" = "windows" ] && \
		g="-geometry $(rematchfn '^([[:digit:]]+x[[:digit:]]+)' $screeninfo)"

	# Start the wanted nxagent
	if [ "$type" = "windows" ]; then
		nxlog "$lp Type \"windows\""
		# nxdesktop session (Windows RDP)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup optional parameters
		u=""; p=""; d=""
		[ -n "$agent_user" ] && u="-u $agent_user"
		[ -n "$agent_password" ] && p="-p -"
		[ -n "$agent_domain" ] && d="-d $agent_domain"
		# Start the agent
		echo "$agent_password" | $PATH_BIN/nxdesktop \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" \
			$k $g $u $p $d $agent_server $AGENT_EXTRA_OPTIONS_RDP 2>&3 &

	elif [ "$type" = "vnc" ]; then
		nxlog "$lp Type \"vnc\""
		# nxviewer session (VNC RFB)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup password
		mkdir -p "$NXSESSION_DIRECTORY/scripts/"
		echo "$agent_password" | $PATH_BIN/nxpasswd \
			"$NXSESSION_DIRECTORY/scripts/.passwd" doit
		# Start x11vnc
		if [ -n "$shadowdisplay" ]; then
			(
				viewonly=""
				[ "$ENABLE_INTERACTIVE_SESSION_SHADOWING" != "1" ] && \
					viewonly="-viewonly"
				DISPLAY="$shadowhost:$shadowdisplay" x11vnc -localhost \
					$viewonly -timeout 120 -rfbauth \
					"$NXSESSION_DIRECTORY/scripts/.passwd" \
					>"$NXSESSION_DIRECTORY/scripts/.vnc_port" 2>&3 &
			)
			local cntr="40"
			while [ ! -f $NXSESSION_DIRECTORY/scripts/.vnc_port ]; do
				sleep 0.05s; ((cntr--)); ((cntr<=0)) && break
			done
			agent_port=$(< $NXSESSION_DIRECTORY/scripts/.vnc_port)
			agent_port=$(rematchfn '^PORT=[[:space:]]*([[:digit:]]+)' $agent_port) #'
			[ -z "agent_port" ] && agent_port="0"
			# note the :: is not a mistake, but rather a hint for nxviewer
			# to use this as a port and not interpret it as a display.
			agent_server="127.0.0.1::$agent_port"
			rm -f "$NXSESSION_DIRECTORY/scripts/.vnc_port"
		fi
		# Start the agent
		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw \
			-passwd "$NXSESSION_DIRECTORY/scripts/.passwd" \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" $vncfullscreen \
			$g $k $agent_server $AGENT_EXTRA_OPTIONS_RFB 2>&3 &
	elif [ "$r" = "-R" -a "$rootless" != "1" ]; 	then
		# nxproxy single application mode session
		nxlog "$lp Start nxproxy for single application session mode"
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$PROXY_LIBRARY_PATH:$LD_LIBRARY_PATH"
		nxlog "$lp Start nxproxy by command: '$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS'"
		$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS 2>&3 &
	else
		nxlog "$lp NXAgent session type"
		# nxagent session (X11)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup optional parameters
		p=$(node_agent_persistent_session)
		fp=""; [ -n "$AGENT_FONT_SERVER" ] && fp="-fp $AGENT_FONT_SERVER"
		if [ "$type" = "shadow" ]; then
			nxlog "$lp Type \"shadow\". Add some args to nxagent"
			r="-S -shadow $shadowhost:$shadowdisplay -shadowmode $ENABLE_INTERACTIVE_SESSION_SHADOWING"
			p="-nopersistent"
		fi
		# Start the agent
#		nxlog "$lp env start `env`"
#		nxlog "$lp env end"
		nxlog "$lp Start nxagent by command: '$COMMAND_NXAGENT $p $r -name \"NX - $user@$SERVER_NAME:$display - $session (GPL Edition)\" -option \"$NXSESSION_DIRECTORY/options\" $b $fp $AGENT_EXTRA_OPTIONS_X :$display'"
		#PATH="$PATH_BIN:$PATH" $COMMAND_NXAGENT $p $r -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$NXSESSION_DIRECTORY/options" $k $g $b $fp $AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
		PATH="$PATH_BIN:$PATH" $COMMAND_NXAGENT $p $r \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" $b $fp \
			$AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
	fi

	# Wait for the agent
	node_agent_pid=$!
	mkdir -p "$NXSESSION_DIRECTORY/pids/"
	echo "$node_agent_pid" >"$NXSESSION_DIRECTORY/pids/agent"
	nxlog "$lp Wait for node_agent_pid='$node_agent_pid'"
	wait $node_agent_pid
	node_agent_exit_status=$?
	nxlog "$lp node_agent_exit_status='$node_agent_exit_status'"
	node_failed=""
	if [ $node_agent_exit_status -ne 0 ]; then
		echo "NX> 1004 Error: NX Agent exited with exit status 1. To troubleshoot set SESSION_LOG_CLEAN=0 in node.conf and investigate \"$nx_dir/F-C-$sess_id/session\". You might also want to try: ssh -X myserver; $PATH_BIN/nxnode --agent to test the basic functionality. Session log follows:"
		echo "$(< $NXSESSION_DIRECTORY/session)" >&2
		node_failed="failed"
		nxlog "$lp node_failed='$node_failed'"
	fi
	nxlog "$lp close session"
	echo "NX> 1006 Session status: closed"

	# Cleanup session information
	nxlog "$lp cleanup session information '$sess_id'"
	nxlog "$lp remove agent pidfile -- '$NXSESSION_DIRECTORY/pids/agent'"
	rm -f "$NXSESSION_DIRECTORY/pids/agent"
	nxlog "$lp call 'node_terminate_session \"$sess_id\" \"$node_failed\"'"
	node_terminate_session "$sess_id" "$node_failed"

	# remove possible leftovers of nxagent
	nxlog "$FUNCNAME ($$):remove /tmp/.X$display-lock"
	rm -f /tmp/.X$display-lock
	nxlog "$lp remove /tmp/.X11-unix/X$display"
	rm -f /tmp/.X11-unix/X$display

	} 3>&1 1>&4 | tee "$NXSESSION_DIRECTORY/session" | \
		node_start_monitor; } 4>&1
}

check_remote_printer() {
# args: type - "smb" or "ipp"
# short sharename/printername
# port - nx controlled mount port
# name - user name
# pass - password (optional)
# if shared printer accessible, returns 1, else - 0
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting with args \"$@\""
	local res i nxredir_lib cmdstr numa upass ret dport;
	if [ "$1" = "ipp" ]; then # checking ipp printer port only
		res=0;
		for (( i=10; $i; --i )); do
			nxlog "$lp wait for ipp-port 127.0.0.1:$3 - $((10-i))"
			$COMMAND_NETCAT -znvw 1 127.0.0.1 $3 2> /dev/null > /dev/null
			[ $? -eq 0 ] && { res=1; break; }
			sleep 1
		done
		nxlog "$lp end with res = $res"
		echo $res; return 0;
	fi
	[ "$(cutfn "$2" "-" "-1")" = "nocheck" ] && {
		res=1
		nxlog "$lp special sharename \"$2\" - stop checking, end with res='$res'"
		echo $res; return 0;
	}
	nxredir_lib="$PATH_LIB/freenx-server/libnxredir.so.0"
	[ -n "$5" ] && upass="$4%$5" || upass="$4 -N"
	stringinstring "$SAMBA_MOUNT_SHARE_PROTOCOL" "cifs|both" && dport=445 || \
		dport=139
	cmdstr="/usr/bin/rpcclient -U '$upass' -c 'openprinter $2' \
-p $dport -I 127.0.0.1 127.0.0.1 2>&1"
	nxlog "$lp invoke command \"$cmdstr\""
	res=""; numa="0"; ret="0"
	while [ "$ret" = "0" ]; do
		# addprinter and addmount try to use one mport at the same time,
		# we need to endure ;)
		(( numa++ ))
		res=$(NXSAMBA_PORT=$3 LD_PRELOAD=$nxredir_lib eval $cmdstr)
		nxlog "$lp on attempt $numa says \"$res\""
		[ -n "$(rematchfn '(successfully)' "$res")" ] && { ret="1"; continue; }
		[ "$numa" -gt 4 ] && ret="1" && res="timeout"
	done
	[ -n "$(rematchfn '(successfully)' "$res")" ] && res=1 || res=0
	nxlog "$lp end with res = $res"
	echo $res
}

node_cups_reconnect() {
# args: none
# if found another running session with same smb/ipp-printers,
# try to remount from current, else - umount
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting."
	local spname type mport new_port new_dir desc_fn descstr device_uri prstr;
	local share upass username password model defaultPrinter cmdstr id drv pname;
	local sessdir="$nx_dir/C-$sess_id"
	local scr_dir="$sessdir/scripts"
	[ ! -d "$sessdir" ] && { nxlog "$lp Dir sessdir='$sessdir' NOT FOUND!"
		return 1; }
	for spname in $scr_dir/@p@* ; do
		[ "$spname" = "*" ] && { nxlog "$lp No printers found. end."
			return 1; }
		pname=$(cutfn "$spname" "/" -1); pname=${pname/@p@/}
		nxlog "$lp process printer \"$pname\", search in system cups."
		prstr=$(LC_ALL=C /usr/bin/lpstat -v "$pname" 2>/dev/null)
		[ -z "$prstr" ] && { nxlog "$lp printer \"$pname\" NOT FOUND in system cups"
			continue;
		}
		[ -n "$(rematchfn '(ipp)://' "$prstr")" ] && type="ipp" || type="smb"
		mport=$(get_mport2sessdir "$sessdir" "$type")
		[ -z "$(rematchfn ':('$mport')/' "$prstr")" ] && { nxlog "$lp printer \"$pname\" has mport rather than $mport, skiping."
			continue; }
		# printer already present at own mport
		nxlog "$lp printer \"$pname\" (port:$mport) found - deleting"
		/usr/bin/sudo /usr/sbin/lpadmin -x "$pname"
		new_dir=$(get_sessdir4res "@p@$pname")
		[ -z "$new_dir" ] && { nxlog "$lp no running sessions found for printer \"$pname\", stop remounting"
			continue;
		}
		new_port=$(get_mport2sessdir "$new_dir" "$type")
		desc_fn="$nx_dir/shares_priv/@p@$pname"
		[ -r "$desc_fn" ] || { nxlog "$lp description file \"$desc_fn\" for printer \"$pname\" NOT ACCESSIBLE, stop remounting"
			continue; }
		descstr=$(< $desc_fn)
		device_uri=$(cutfn "$descstr" "&" 1)
		device_uri=${device_uri/:$mport/:$new_port}
		share=$(cutfn "$device_uri" "/" -1)
		upass=$(cutfn "$(cutfn "$device_uri" "/" 2)" "@" 0) #"
		username="$(cutfn "$upass" ":" 0)"
		password="$(cutfn "$upass" ":" 1)"
		#[ "$type" = "ipp" ] && {
		#	newpass=$(cat "$new_dir/scripts/@p@$pname" 2>/dev/null)
		#	[ ! -z "$newpass" ] && { nxlog "$lp new password for printer \"$pname\" ARE LOST, stop remounting"
		#	continue;
		#	}
		#	device_uri=${device_uri/:$password/:$newpass}
		#	password="$newpass"
		#}
		[ "$(check_remote_printer $type $share $new_port $username $password)" \
				= "0" ] && { nxlog "$lp smb/cifs-share \"$share\" for printer \"$pname\" NOT ACCESSIBLE, stop remounting"
			continue;
		}
		model=$(cutfn "$descstr" "&" 0)
		defaultPrinter=$(cutfn "$descstr" "&" 3)
		if [ -r "$model" ]; then # ppd only
			cmdstr="/usr/bin/sudo /usr/sbin/lpadmin -p $pname -P $model -v $device_uri -E"
		else # foomatic
			id="$model"; drv=$(cutfn "$descstr" "&" 4)
			cmdstr="/usr/bin/sudo /usr/bin/foomatic-configure -s cups -n $pname -p $id -d $drv -c $device_uri -q"
		fi
		nxlog "$lp invoke $cmdstr"
		$cmdstr
		if [ $? -eq 0 ]; then
			nxlog "$lp printer \"$pname\" installed"
			[ "$type" = "ipp" ] && {
				descstr=${descstr/:$mport/:$new_port}
				echo "$descstr" > "$desc_fn"
			}
			public=$(cutfn "$descstr" "&" 2)
			[ -n "$public" ] && { /usr/bin/sudo /usr/sbin/lpadmin -p $pname $public;
				[ $? -ne 0 ] && nxlog "$lp FAILED to set options \"$public\" for printer \"$pname\""
			}
			[ "$defaultPrinter" = "1" ] && {
				/usr/bin/sudo /usr/sbin/lpadmin -d "$pname";
				[ $? -ne 0 ] && nxlog "$lp FAILED to set default printer \"$pname\""
			}
		else
			nxlog "$lp FAILED to reinstall printer \"$pname\""
		fi
	done
	nxlog "$lp end."
}

create_mountpoint() {
# creates directory and checks its attrs
#params: dir owner group
	local errstr logstr duser dgroup dacr;
	[ ! -e "$1" ] && {
		errstr=$(mkdir -p "$1" 2>&1)
		[ $? -ne 0 ] && {
			echo "Unable to create \"$1\". Error: \"$errstr\""; return 1
		} || echo "\"$1\" successfully created."
	} || echo "\"$1\" already exist."
	duser=$(stat -c %U "$1"); dgroup=$(stat -c %G "$1")
	[ "$duser" != "$2" -o "$dgroup" != "$3" ] && {
		logstr="\"$1\" ($duser:$dgroup). Attempt to change owners to $2:$3 - "
		errstr=$(chown "$2:$3" "$1" 2>&1)
		[	 $? -ne 0 ] && {
			echo "$logstr - FAILED! Error: \"$errstr\""; return 1
		} || echo "$logstr - successfully completed."
	}
	dacr=$(stat -c %a "$1")
	[ "$dacr" != "770" ] && {
		logstr="\"$1\" ($dacr). Attempt to change access rights to 0770 - "
		errstr=$(chmod 0770 "$1" 2>&1)
		[ $? -ne 0 ] && {
			echo "$logstr - FAILED! Error: \"$errstr\""; return 1
		} || echo "$logstr - successfully completed."
	}
	return 0
}

try_mount_smb() {
# params: sharename(1), mountpoint(2), smb-username(3), port(4),
# ex-options/uid,gid/(5), smb-password(6)
	local lp="$FUNCNAME ($$/$BASHPID):";
	local rc=1 smb_opts error mntstr mnt_opts
	nxlog "$lp Starting with args: '$@'}"
	[ -n "$SMB_MOUNT_OPTIONS" -a "${SMB_MOUNT_OPTIONS:0:1}" != "," ] && \
		mnt_opts=",$SMB_MOUNT_OPTIONS"
	smb_opts="username=$3,"
	[ -n "$6" ] && smb_opts="$smb_opts""password=$6," || \
		smb_opts="$smb_opts""password=,"
	smb_opts="$smb_opts""ip=127.0.0.1,port=$4$mnt_opts"
# !!!
	mntstr="/usr/bin/sudo $COMMAND_SMBMOUNT $1 $2 -o $5$smb_opts"
	#nxlog "$lp invoke $mntstr 2>&1"
	error=$($mntstr 2>&1); rc=$?
	[ $rc -ne 0 ] && nxlog "$lp Mount error: \"$error\""
	[ $rc -eq 0 ] && nxlog "$lp Finished successfully."
	return $rc
}

try_umount_smb() {
# param: mountpoint
	local lp="$FUNCNAME ($$/$BASHPID):";
	local amnt=3 cn=0 ostr;
	local logstr1 logstr2 rc=0 i ffl;
	nxlog "$lp Starting with arg '$@'"
	for (( i=$amnt; $i; --i )); do
		stringinstring "$1" "$(mount)" || {
			nxlog "$lp Mountpoint \"$1\" not mounted"; return 0;
		}
		((i<amnt/2)) && { ffl="-f"; logstr1="$lp force (-f)";
			} || { ffl=""; logstr1="$lp"; }
		(( cn++ ))
		logstr2="$logstr1"" umount attempt #$cn \"$1\""
# !!!
		ostr=$(/usr/bin/sudo $COMMAND_SMBUMOUNT $ffl "$1" 2>&1); rc=$?
		[ $rc -eq 0 ] && { nxlog "$logstr2 completed succesfully."
			break; } || nxlog "$logstr2 FAILED. Error: \"$ostr\""
		sleep 0.5s
	done
	[ $rc -eq 0 ] && nxlog "$lp Finished successfully."
	return $rc
}

node_umount_smb() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting with sess_id='$sess_id'"
	local scr_dir mport mpoints ssname sname desc_fn descstr new_dir new_port rc;
	local smbport fsname username password ids_opts;
	scr_dir="$nx_dir/C-$sess_id/scripts"
	[ -r "$scr_dir/smbport" ] && \
		smbport=$(< $scr_dir/smbport)
# !!!
	[ "$smbport" = "445" ] && {
		COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS; COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
	}
	[ -r "$scr_dir/mport" ] && mport=$(< $scr_dir/mport)
	[ -r "$scr_dir/mpoint" ] && mpoints=$(< $scr_dir/mpoint) || {
		nxlog "$lp No shares controlled by session found. Stop remounting."
		return;
	}
	for ssname in $scr_dir/@s@*; do
		sname=$(cutfn "$ssname" "/" -1); sname=${sname/@s@/}
		desc_fn="$nx_dir/shares_priv/@s@$sname"
		[ ! -r "$desc_fn" ] && {
			nxlog "$lp description file \"$desc_fn\" for share \"$sname\" NOT ACCESSIBLE, stop remounting it"
			continue;
		}
		descstr=$(< $desc_fn); mpoint=$(cutfn "$descstr" "&" 1)
		stringinstring "$mpoint" "$mpoints" || {
			nxlog "$lp share \"$sname\" at \"$mpoint\" is not controlled by session. Stop remounting."
			continue;
		}
		try_umount_smb "$mpoint"; rc=$? # umount here
		[ $rc -ne 0 ] && {
			nxlog "$lp mountpoint \"$mpoint\" failed to unmount."
			continue;
		}
		new_dir=$(get_sessdir4res "@s@$sname")
		[ -z "$new_dir" ] && {
			nxlog "$lp no running sessions found for share \"$sname\", stop remounting"
			rmdir "$mpoint" >/dev/null 2>/dev/null; continue;
		}
		new_port=$(< $new_dir/scripts/mport); fsname=$(cutfn "$descstr" "&" 0)
		username=$(cutfn "$descstr" "&" 2); password=$(cutfn "$descstr" "&" 3)
		ids_opts=$(cutfn "$descstr" "&" 4)
		try_mount_smb "$fsname" "$mpoint" "$username" $new_port "$ids_opts" "$password"
		rc=$?
		[ $rc -eq 0 ] && {
			nxlog "$lp share \"$fsname\" remount to \"$mpoint\""
			echo "$mpoint" >> "$new_dir/scripts/mpoint"
		} || {
			nxlog "$lp share \"$fsname\" failed to remount: $error"
			rmdir "$mpoint" >/dev/null 2>/dev/null
		}
	done
	nxlog "$lp end"
}

node_stop_services() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	nxlog "$lp call node_umount_smb"
	node_umount_smb
	nxlog "$lp call node_cups_reconnect"
	node_cups_reconnect
	nxlog "$lp call reconnect_pa"
	reconnect_pa
	nxlog "$lp end"
}

node_emergency_exit() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	# umount shares & stop printers
	nxlog "$lp call node_stop_services"
	node_stop_services

	# kill the session
	nxlog "$lp call 'node_terminate_session \"$sess_id\" \"failed\"'"
	node_terminate_session "$sess_id" "failed"

	echo "NX> 1004 Error: Emergency exit due to kill signal."
	nxlog "$lp end"
}

# node_start_monitor <start|restore> <Running|Suspended>
# Monitoring the nxagent: Its also kind of a "state-machine"
#                         as it has to keep track of different
#                         connection states and react differently.
node_start_monitor() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	nxlog "$lp starting"
	local node_tail_pid="" node_suspend_status="$2";
	local smbmount_port media_port node_watchdog_pid tosend

	while read line; do
		# Catch tail pid
		if stringinstring "Info: tail -f running with pid" "$line"; then
			node_tail_pid=$(cutfn "$line" "'" 1)
			echo "$node_tail_pid" >"$nx_dir/C-$sess_id/pids/tail"
		elif stringinstring "Info: Listening * SMB connections on port" "$line"; then
			# Catch NXAGENT SMB Port (sometimes the port differs from what we got from nxserver)
			smbmount_port=$(cutfn "$line" "'" 1); smbmount_port=${smbmount_port##*:}
			echo "$smbmount_port" >"$nx_dir/C-$sess_id/scripts/mport"
		elif stringinstring "Info: Listening * multimedia connections on port" "$line"; then
			# Catch NXAGENT Multimedia Port
			media_port=$(cutfn "$line" "'" 1); media_port=${media_port##*:}
			echo "$media_port" >"$nx_dir/C-$sess_id/scripts/mmport"
		elif stringinstring "Session: Starting session at" "$line"; then
		# Session messages
			echo "NX> 1009 Session status: starting"
		elif stringinstring "Session: Suspending session at" "$line"; then
			echo "NX> 1009 Session status: suspending"
		elif stringinstring "Session: Terminating session at" "$line"; then
			echo "NX> 1009 Session status: terminating"
		elif stringinstring "Session: Resuming session at" "$line"; then
			echo "NX> 1009 Session status: resuming"
		elif stringinstring "Session: Session suspended at" "$line"; then
			# Session suspend
			echo "NX> 1005 Session status: suspended"
			# umount shares & stop printers
			[ "$node_suspend_status" != "Suspended" ] && {
				nxlog "$lp node suspended, call node_stop_services"
				node_stop_services
			}
		elif stringinstring "Info: Watchdog running with pid" "$line"; then
			# Watchdog termination
			node_watchdog_pid=$(cutfn "$line" "'" 1)
		elif stringinstring "Info: Waiting the watchdog process to complete." "$line"; then
			# Kill the watchdog
			kill $node_watchdog_pid 2>/dev/null
		elif stringinstring "Info: Waiting for connection from" "$line"; then
			tosend="NX> 700 Session id: $sess_id
NX> 705 Session display: $display\nNX> 703 Session type: $type
NX> 701 Proxy cookie: $cookie\nNX> 702 Proxy IP: $proxyip
NX> 706 Agent cookie: $cookie\nNX> 704 Session cache: $type
NX> 707 SSL tunneling: $encryption\n"
			# File-sharing port options
			if [ "$samba" = "1" -a -n "$smbport" ]; then
				tosend+="NX> 709 File-sharing port: $smbport\n"
			fi
			echo -e "$tosend""NX> 710 Session status: running\nNX> 1002 Commit\nNX> 1006 Session status: running"
		elif stringinstring "Session: Session resumed at" "$line"; then
			# Reconnection success!
			echo "NX> 718 Session restore succeded"
			if [ "$1" = "restore" ]; then
				kill $node_tail_pid
				break
			fi
		elif stringinstring "Session: Display failure detected at" "$line"; then
			# Reconnection failure
			if [ "$1" = "restore" ]; then
				echo "NX> 596 Error: Session $1 failed. Reason was: $line"
				kill $node_tail_pid
				break
			fi
		fi
	done

	trap "" EXIT

	[ "$1" != "restore" -a "$rootless" != "1" ] && {
		nxlog "$lp call node_stop_services at ending"
		node_stop_services;
	}
	# close all open file descriptors
	exec 0<&-; exec 1>&-; exec 2>&-;
	nxlog "$lp end"
	exit 0
}

#
# -----------------------------------------------------------------------------
# startsession - Start a new session.
# -----------------------------------------------------------------------------
#
startsession() {
	local lp="$FUNCNAME ($$/$BASHPID):";
	local opt_vars opt_str old_umask pack cleanup product;
	local id fullscreen accept vn;
	nxlog "$lp starting with args \"$@\""

	# 1.5.0 options: rdpcolors,rdpcache,http
	# nxclient > 1.5.0-106 variables: resize,keybd
	# FreeNX specific variables: clientproto,status,host
	# NX 3.0 shadow mode related variables: shadowusername,shadowcookie,
	# shadowdisplay,shadowhost
	# Authentication method needed by guest mode: login_method
	# dimbor: additional extra-channels extra[1-3], patched nxcomp both
	# on server and client are required

	windows_app=$application
	# ok, lets make the session dir first:
	old_umask=$(umask);
	[ -d $USER_FAKE_HOME ] || { umask 0022; mkdir -p $USER_FAKE_HOME; }
	umask 0077; mkdir -p "$NXSESSION_DIRECTORY"; umask $old_umask

	[ "$geometry" = "fullscreen" ] && fullscreen="1" || fullscreen="0"
	[ "$PROXY_TCP_NODELAY" = "0" ] && nodelay=0
	[ "$ENABLE_ROOTLESS_MODE" = "0" ] && rootless=0
	[ "$ENABLE_EXTERNAL_NXDESKTOP_KEYBOARD" = "1" ] && \
		agent_keyboard=$(cutfn "$keyboard" '/' 1) || agent_keyboard=""
	[ -z "$samba" ] && samba=0
	[ -z "$media" ] && media=0
	[ -z "$nodelay" ] && nodelay=1 # ???
	cleanup=10; product=LFE/None/LFEN/None; id=$sess_id;
	[ -z "$shmem" ] && shmem=0; [ -z "$shpix" ] && shpix=0

	[ -z "$keybd" ] && keybd=$aux # backwards compatibility for keybd parameter

	[ "$EXPORT_USERIP" = "1" ] && export NXUSERIP="$userip"
	[ "$EXPORT_SESSIONID" = "1" ] && export NXSESSIONID="$sess_id"
	export SHADOW_XAUTHORITY="$NXSESSION_DIRECTORY/authority"

	# export the agent_* options for the helper scripts
	if [ "$freenx_export_agents" = "1" ]; then
		export agent_user
		export agent_password
		export agent_server
		export agent_domain
		export windows_app
		export agent_keyboard
		export NXSESSION_DIRECTORY
		export AGENT_EXTRA_OPTIONS_RFB
		export AGENT_EXTRA_OPTIONS_RDP
		export COMMAND_RDESKTOP
		export COMMAND_VNCVIEWER
		export COMMAND_VNCPASSWD
		export COMMAND_X11VNC
		export PATH_BIN
		export shadowdisplay
		export shadowhost
		export shadowuser
		export shadowcookie
		export ENABLE_SESSION_SHADOWING_AUTHORIZATION
		export ENABLE_INTERACTIVE_SESSION_SHADOWING
		# We do not want to suspend such a session
		# as RDP/RFB are both suspendable as well
		ENABLE_PERSISTENT_SESSION=""
	fi

	# NX 2.1.0 file-sharing port options
	smbport=""
	if [ "$samba" = "1" ]; then
		# We know from protocol traces that client=linux,winnt,macosx are valid values.
		# I hope with smbclientproto=smb on default and smbclientproto=cifs on all valid
		# values we get support for all those systems.
		smbproto="$SAMBA_MOUNT_SHARE_PROTOCOL"
		if [ "$smbproto" = "both" ]; then
			smbproto="smbfs"
			[ "$client" = "linux" ] && smbproto="cifs"
			[ "$client" = "winnt" ] && smbproto="cifs"
			[ "$client" = "macosx" ] && smbproto="cifs"
			# FIXME: This is a rather wild guess
			[ "$client" = "win9x" ] && smbproto="smbfs"
		fi
		if [ "$smbproto" = "cifs" ]; then
			smbport=445
			COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS
			COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
		elif [ "$smbproto" = "none" ]; then
			# we set this to true so that the
			# SMB mount does not give an error message.
			COMMAND_SMBMOUNT=/bin/true; COMMAND_SMBUMOUNT=/bin/true
			smbport=139    #JJK: still may want to do printer sharing...
		else # smbfs
			smbport=139
		fi
	fi
	if [ "$encryption" = "1" ]; then
		# we need to use the IP of the "calling" server now
		# FIXME: cut and sed rm
		#userip=$(echo $SSH_CLIENT $SSH2_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
		#nxlog "$lp userip='$userip'"
		userip=""
		# If host is the same, use 127.0.0.1, else fallback to default
		[ -z "$userip" -a "$host" = "127.0.0.1" ] && userip="127.0.0.1"
		[ -z "$userip" ] && userip="*"
	else encryption=0
	fi
	# We need our own external IP
	proxyip="$EXTERNAL_PROXY_IP"
	if [ -z "$proxyip" -a -n "$host" ]; then
		[ "$host" = "127.0.0.1" ] && host=$SERVER_NAME
		# FIXME: on modern systems ping resolves lo addr also
		proxyip=$(rematchfn "PING .+\(($ip4_pattern)\)" "$(ping -c1 "$host")") #"
	fi
	[ -z "$proxyip" ] && proxyip="127.0.0.1"

	pack=""
	[ -z "$imagecompressionlevel" ] && imagecompressionlevel="9"
	[ "$imagecompressionmethod" = "0" ] && pack="nopack"
	[ "$imagecompressionmethod" = "1" ] && pack="16m-jpeg-$imagecompressionlevel"
	[ "$imagecompressionmethod" = "2" ] && pack="16m-png-9"

	cookie=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
	cookie=${cookie%% *}

	# write options file
	clipboard="$ENABLE_CLIPBOARD"; menu="$ENABLE_PULLDOWN_MENU"
	[ "$userip" = "*" ] && accept="" || accept=$userip

	if [ "$1" = "application" ]; then
		# This needs to be set, else nxagent is terminated
		rootless="1"; virtualdesktop="0"
		nxlog "$lp call 'node_start_applications'"
		node_start_applications &
		echo "NX> 596 Application $application started successfully."
		return
	fi

	old_umask=$(umask); umask 0077
	nxlog "$lp generate \"$NXSESSION_DIRECTORY/options\""
	opt_vars="keyboard kbtype kbload keymap geometry\
 client resize cache images pack link nodelay type clipboard composite\
 cleanup product shmem backingstore shpix accept cookie id samba media\
 sync cups keybd aux http extra1 extra2 extra3 rdpcolors rdpcache\
 fullscreen menu"
	opt_str="nx/nx";
	for vn in $opt_vars; do [ -n "${!vn}" ] && opt_str+=",$vn=${!vn}"; done
	opt_str+=":$display"
	echo "$opt_str" > "$NXSESSION_DIRECTORY/options"
	umask $old_umask

	# write xauth script file
	nxlog "$lp write xauth script file"
	txt="add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
add :$display MIT-MAGIC-COOKIE-1 $cookie
exit"
	echo "$txt" | $COMMAND_XAUTH >/dev/null 2>&1
	echo "$txt" | $COMMAND_XAUTH -f "$NXSESSION_DIRECTORY/authority" >/dev/null 2>&1

	mkdir -m700 "$NXSESSION_DIRECTORY/scripts/" 2>/dev/null || \
		chmod 700 "$NXSESSION_DIRECTORY/scripts/"
	txt="remove localhost:$display\nremove :$display\nexit"
	echo -e "$txt" >"$NXSESSION_DIRECTORY/scripts/authority"

	# If we have a shadow cookie, we add it to xauth session authority file as well
	if [ -n "$shadowcookie" ]; then
		nxlog "$lp If we have a shadow cookie, we add it to xauth session authority file as well"
		$COMMAND_XAUTH -f "$SHADOW_XAUTHORITY" add "$shadowhost:$shadowdisplay" MIT-MAGIC-COOKIE-1 "$shadowcookie"
	elif [ -n "$shadowdisplay" ]; then
		# we need to merge in the normal .Xauthority file
		nxlog "$lp we need to merge in the normal .Xauthority file"
		$COMMAND_XAUTH -f "$SHADOW_XAUTHORITY" merge "$HOME/.Xauthority"
	fi

	if [ "$1" = "restore" ]; then
		nxlog "$lp restore session"
		echo > "$NXSESSION_DIRECTORY/session"
		sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '"$USER_FAKE_HOME"'/.nx/C-'"$sess_id"'/session' | node_start_monitor "$1" "$status" &
		MONITOR_PID=$!; export MONITOR_PID
		mkdir -p "$NXSESSION_DIRECTORY/pids/"
		echo "$MONITOR_PID" > "$NXSESSION_DIRECTORY/pids/monitor"
		nxlog "$lp call 'node_suspend_session \"$sess_id\"'"
		node_suspend_session "$sess_id" || { echo "Info: Reconnection failed: NX Agent process could not be found." >>"$NXSESSION_DIRECTORY/session"; node_fail_restore_session "$sess_id"; }
	else
		nxlog "$lp call 'node_start_agent'"
		node_start_agent &
		nxlog "$lp call 'node_start_applications'"
		node_start_applications &
		if [ -x "$NODE_AUTOSTART" ]; then
			nxlog "$lp NODE_AUTOSTART: waiting for nxagent"
			local cntr=$((AGENT_STARTUP_TIMEOUT*100)); local cntr0=$cntr
			while [ ! -f /tmp/.X$display-lock ]; do
				sleep 0.01s; ((cntr--)); ((cntr<=0)) && break
			done
			nxlog "$lp NODE_AUTOSTART: Stop waiting $((cntr0-cntr))0 ms"
			# go into background immediately
			NXSESSIONID="$sess_id" DISPLAY=:$display "$NODE_AUTOSTART" "$1" >/dev/null 2>&1 &
			disown $! # dont't wait for this child!
		fi
	fi


	# File-sharing port options
	if [ "$samba" = "1" -a -n "$smbport" ]; then
		echo "$smbport" >"$NXSESSION_DIRECTORY/scripts/smbport"
	fi

	if [ -n "$MONITOR_PID" ]; then
		wait "$MONITOR_PID"
		rm -f "$NXSESSION_DIRECTORY/pids/monitor"
		rm -f "$NXSESSION_DIRECTORY/pids/tail"
	fi
	wait # for all children
	nxlog "$lp end"
}

#
# -----------------------------------------------------------------------------
# cmd_node functions - changes lots of small variables
# -----------------------------------------------------------------------------
#
cmd_node_terminate() {
	echo "$delim 716 Terminating session $session_id on user request."
	node_terminate_session "$sess_id"
}

cmd_node_suspend() {
	echo "$delim 716 Suspending session $session_id on user request."
	node_suspend_session "$sess_id"
}

cmd_node_smbmount() {
# used vars: port, username, password, share, dir, computername
	local lp="$FUNCNAME ($$/$BASHPID):";
	local try_user try_sudo ids_ops egroup sfn rc outstr smbport desc_dir
	nxlog "$lp starting with sessionid = $session_id"
	# Due to a too quick session start, port does not have time to initialize
	sleep 0.2s

	computername=127.0.0.1 # http://bugs.etersoft.ru/show_bug.cgi?id=8841
	dir=${dir/'$(SHARES)'/MyShares}; dir=$(cp_conv $dir)
	[ -n "$(rematchfn "(MyShares)" "$dir")" ] && dir="$HOME/$dir" #"
	username=$(cp_conv $username); password=$(cp_conv $password)
	share=$(cp_conv $share)

	# dimbor: checking mountpoint
	egroup=$(id -gn "$USER"); rc=$?
	outstr="$(create_mountpoint "$dir" "$USER" "$egroup")"
	[ -n "$outstr" ] && nxlog "$lp create_mountpoint says: \"$outstr\""
	[ $rc -ne 0 ] && { nxlog "$lp Stop mounting."; return 1; }
	smbport=""; [ -r "$NXSESSION_DIRECTORY/scripts/smbport" ] && \
		smbport=$(< $NXSESSION_DIRECTORY/scripts/smbport)
	ids_ops="uid=$USER,gid=$egroup,";
	# this function run dedicated. We must define smbproto and COMMAND_SMBMOUNT here, not in startsession.
# !!!
	if [ "$smbport" = "445" ]; then
		COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS; COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
	elif [ "x$smbport" = "x" ]; then COMMAND_SMBMOUNT=/bin/true
	else smbport=139 # smbfs
	fi

	#do not mount twice
	local mnts=$(rematchfn "(.+)[[:space:]].+$dir" "$(mount)") #"
	if [ -n "$mnts" ]; then
		nxlog "$lp share $mnts already mounted on $dir"
		if [ -z "$(get_sessdir4res "@s@$share")" ]; then
			nxlog "$lp Try to force umount dead mountpoint \"$dir\""
			try_umount_smb "$dir"; rc=$?
			[ $rc -ne 0 ] && {
				nxlog "$lp Umounting FAILED! Stop mounting."; return 1;
			}
		else
			touch "$NXSESSION_DIRECTORY/scripts/@s@$share"; return;
		fi
	fi
	# wait up to 30 sec until nxagent has opened the listener port
	# for samba connections
	for (( i=300; $i; --i )); do
		[ -f "$NXSESSION_DIRECTORY/scripts/mport" ] && break
		sleep 0.1s
	done
	# sometimes the samba port we get from nxserver is not the right one,
	# so let's get it from nxagent
	[ -r "$NXSESSION_DIRECTORY/scripts/mport" ] && port=$(< $NXSESSION_DIRECTORY/scripts/mport)
	try_mount_smb "//$computername/$share" "$dir" "$username" $port "$ids_ops" "$password"
	rc=$?
	if [ $rc -eq 0 ]; then
		nxlog "$lp share \"//$computername/$share\" mount on \"$dir\""
		sfn="@s@$share"; touch "$NXSESSION_DIRECTORY/scripts/$sfn"
		desc_dir="$nx_dir/shares_priv" # directory with connection parameters to use sessions together
		[ -d "$desc_dir" ] || {
			mkdir "$desc_dir" && chmod 700 "$desc_dir";
		}
		[ ! -e "$desc_dir/$sfn" ] && touch "$desc_dir/$sfn" && \
			chmod 600 "$desc_dir/$sfn" # create "top-secret" description file
		echo "//$computername/$share&$dir&$username&$password&$ids_ops" > "$desc_dir/$sfn"
		echo "$dir" >> "$nx_dir/C-$SERVER_NAME-$display-$session_id/scripts/mpoint"
	else
		nxlog "$lp Share //$computername/$share mount FAILED."
		rmdir "$dir" >/dev/null 2>/dev/null #JJK: Remove mount point if empty
	fi
}

cmd_node_addprinter() {
# used vars: type, username, password, port, share, computername, model,
# defaultprinter/defaultPrinter public
	local lp="$FUNCNAME ($$/$BASHPID):";
	local public_str name pname pre drv nocheck device_uri id;
	local strs cmdstr errstr cups_driver_dir uris prog strs
	local pfn desc_dir i pstr iport drop dbs error
	nxlog "$lp starting with args \"$@\""
	# Due to a too quick session start, port does not have time to initialize
	sleep 0.2s

	[ -z "$defaultrrinter" ] && defaultprinter=$defaultPrinter # for nxclient

 	# normalize
	username=$(cp_conv $username); password=$(cp_conv $password)
	share=$(cp_conv $share); computername=$(cp_conv $computername)
	export CUPS_SERVER=$CUPS_DEFAULT_SOCK

	if [ "$type" = "smb" ]; then
		[ -r $NXSESSION_DIRECTORY/scripts/smbport ] && \
			smbport=$(< $NXSESSION_DIRECTORY/scripts/smbport)
		[ -z "$smbport" ] && smbport=139 # should not happen
		[ "$smbport" = "445" ] && smbproto="cifs" || smbproto="smb"
		device_uri="nxsmb://$username:$password@127.0.0.1:$port/$smbproto/$share"
		name="$share";
		nxlog "$lp set name = $name; smbport=$smbport; device_uri=$device_uri"
	else
		printer=$(cp_conv $printer)
		device_uri="ipp://$username:$password@127.0.0.1:$port/printers/$printer"
		name="$printer"
		nxlog "$lp set name = $name; device_uri=$device_uri"
	fi

	#JJK: I like to also allow 'guest' so you can do things like print
	#JJK: testpages from the CUPS web interface. Note this is required
	#JJK: even for the original user to print test pages
	#JJK:	public="-u allow:$USER"
	public_str="-u allow:$USER,guest,root"
	[ "$public" == "1" ] && public_str=""
	# dimbor: We use system cupsd
	# Name of windows share or ipp-printer may be set to name
	# of driver.ppd from $NX_ETC_DIR/ppd/ (without ".ppd").
	# For ipp if driver not found we try it to download like
	# oriiginal behaviour (need installed curl).
	# In case of ENABLE_FOOMATIC="1" share/printer name may set to
	# [@]<printer id>[#<N>][__<driver_num>][-nocheck]
	# @: if sharename started with char "@", force setup to anyone
	# share name driver "HP-LaserJet_4M-Postscript.ppd"
	# http://www.nixp.ru/articles/win_printing_in_linux (hello to DjSpike)
	# <printer id>: significant part of drver's uri.
	# <N>: number of printer instance
	# "__": char "_" twice
	# <driver_num>: number from drver's uri.
	# Driver-uri is first field of output '/usr/lib/cups/driver/* list'
	# -nocheck: do not check remote smb-share by rpclient (to W7 Home clients)
	pre=""; [ "${name:0:1}" = "@" ] && { pre="1"; name=${name:1}; }
	nocheck=""; stringinstring "-nocheck" "$name" && {
		 nocheck="1"; name=${name/-nocheck/}; }
	drv=""; stringinstring "__" "$name" && {
		drv=${name#*__}; name=${name%__*}; }
	nn=""; stringinstring "#" "$name" && { nn=${name#*#}; name=${name%#*}; }
	pname="$USER""_""$name""$nn" # user's printer name
	[ -n "$pre" ] && { id="HP-LaserJet_4M-Postscript"; drv="0"; }
	model="$NX_ETC_DIR/ppd/$id.ppd"
	nxlog "$lp set pname = \"$pname\", try to install \"$model\" - N=$nn, drv=$drv, pname=$pname."
	[ "$type" = "smb" ] || [ -r "$model" ] || {
		# try to download "left-nx" ppd (original scheme), needs to use
		# wrapper for nxprint on client side
		# TODO: Rewrite
		[ "$(check_remote_printer "ipp" "fake_param" $port)" = "0" ] && {
			nxlog "$lp Remote CUPS not found!"; return 1; }
		errstr=$(curl --proxy "" --digest -o "$model" \
			"http://$username:$password@127.0.0.1:$port/ppd/${name}_nxdl.ppd" 2>&1)
		cmdstr="curl --proxy \"\" --digest -o $model http://$username:******@127.0.0.1:$port/ppd/${name}_nxdl.ppd"
		[ -r "$model" -a -n "$(head -n1 "$model" 2>/dev/null | grep "*PPD-Adobe")" ] && {
			nxlog "$lp $model download SUCCESSFUL."
		} || {
			nxlog "$lp $model is NOT a PPD-file! Contents: \"$(cat $model 2>/dev/null)\""
			nxlog "$lp cmd: $cmdstr"
			nxlog "$lp $errstr"
			rm -f "$model"
		}
	}
	if [ ! -r "$model" ]; then
		# TODO: Rewrite
		[ "$ENABLE_FOOMATIC" != "0" ] &&  { # search ppd-file in cups
			cups_driver_dir="/usr/lib/cups/driver"; uris=""
			for prog in $cups_driver_dir/*; do
				[ -x $prog ] || continue
				stringinstring "gutenprint" "$prog" && mn="$id"|| mn="$id.ppd"
				strs=$($prog list 2>/dev/null | grep "$mn")
				[ -z "$strs" ] && continue
				strs=$(echo "$strs" | awk -F'"' '{ printf("%s\n",$2)}') #'
				uris="$uris""$strs"
			done
			[ -n "$HASDRV" ] && uris=$(echo "$uris" | awk -F'/' \
				'{nd=substr($1,index($1,":")+1); if (nd ~ '$drv') {printf("%s\n",$0)}}')
			drv_uri=$(echo "$uris" | head -n1)
			[ -n "$drv_uri" ] && {
				nxlog "$lp Try to get \"$model\" from URI \"$drv_uri\""
				prog="$cups_driver_dir/$(echo "$drv_uri" |  awk -F':' '{ printf("%s",$1)}')" #'
				cmdstr="$prog cat $drv_uri"
				$cmdstr > $model
			} || {
				nxlog "$lp Driver for \"$name\" not found in CUPS. STOP installing."
				return 1
			}
		}
	fi
	pfn="@p@$pname" # filename of flag and description files
	desc_dir="$nx_dir/shares_priv" # directory with connection parameters to use sessions together
	[ -d "$desc_dir" ] || { mkdir "$desc_dir" && chmod 700 "$desc_dir"; }
	[ "$type" = "smb" ] && {
		for (( i=30; $i; --i )); do
			nxlog "$lp wait for smb-port $((30-i))"
			[ -f "$NXSESSION_DIRECTORY/scripts/mport" ] && break
			sleep 1
		done
	} || share=$printer
	# check existing printers
	pstr=$(LC_ALL=C /usr/bin/lpstat -v "$pname" 2>/dev/null)
	if [ -n "$pstr" ]; then # printer present
		iport=$(rematchfn ':([[:digit:]]+)/' "$pstr") #'
		[ "$iport" -gt 0 2>/dev/null ] && drop=0 || { drop=1; dbs="wrong port"; }
		[ -n "$nocheck" ] && { drop=1; dbs="don't check remote printer"; }
		if [ "$drop" = "0" ]; then
			[ "$(check_remote_printer $type $name $iport $username $password)" = "0" ] && \
				{ drop=1; dbs="not accessible"; }
		fi
		[ "$drop" = "0" ] && [ "$type" = "ipp" -o "$iport" = "$port" ] && \
			{ drop=1; dbs="for reinstall"; }
		if [ "$drop" = "1" ]; then
			nxlog "$lp delete printer \"$pname\" (port:$iport) - $dbs"
			/usr/bin/sudo /usr/sbin/lpadmin -x "$pname"
		else
			nxlog "$lp printer \"$pname\" already exist at port:$iport - stop adding, mark only"
			echo $password > "$NXSESSION_DIRECTORY/scripts/$pfn"; chmod 600 "$NXSESSION_DIRECTORY/scripts/$pfn"
			return 0
		fi
	fi
	[ "$(check_remote_printer $type $name $port $username $password)" = "0" ] && {
		nxlog "$lp \"$name\" (mport:$port) NOT ACCESSIBLE stop adding."
		return 1;
	}
	echo $password > "$NXSESSION_DIRECTORY/scripts/$pfn"; chmod 600 "$NXSESSION_DIRECTORY/scripts/$pfn" # set share present flag
	if [ -r "$model" ] ; then
		[ ! -e "$desc_dir/$pfn" ] && touch "$desc_dir/$pfn" \
			&& chmod 600 "$desc_dir/$pfn" # create "top-secret" description file
		echo "$model&$device_uri&$public_str&$defaultprinter" > "$desc_dir/$pfn" # confidential access data
		cmdstr="/usr/bin/sudo /usr/sbin/lpadmin -p $pname -P $model -v $device_uri -E"
	else
		nxlog "$lp $model driver not found! Printer $name not installed."
		return 1
	fi
	nxlog "$lp invoke $cmdstr"
	error="$($cmdstr 2>&1)"
	if [ $? -eq 0 ] ; then
		nxlog "$lp printer \"$pname\" installed"
		[ -n "$public_str" ] && { /usr/bin/sudo /usr/sbin/lpadmin -p $pname $public_str;
			[ $? -ne 0 ] && nxlog "$lp FAILED to set options \"$public_str\" for printer \"$pname\""
		}
		[ "$defaultprinter" = "1" ] && {
			/usr/bin/sudo /usr/sbin/lpadmin -d "$pname";
			[ $? -ne 0 ] && nxlog "$lp FAILED to set default printer \"$pname\""
		}
	else nxlog "$lp FAILED to install printer \"$pname\": $error"
	fi
}


declare -g delim="NX>" CMDLINE="" nx_dir nxuser_logfile;

#
# -----------------------------------------------------------------------------
# Startup of nxnode
# -----------------------------------------------------------------------------
#
[ -n "$2" ] && delim="NX-$2>"
echo "$delim 1000 NXNODE - Version $NX_VERSION $NX_LICENSE"

if [ "$USER" = "nx" ]; then
	nx_dir="/var/lib/nxserver/home" # ???
	nxuser_logfile="/var/log/nx/nxnode.log"
else
	nx_dir="$USER_FAKE_HOME/.nx"
	nxuser_logfile="$nx_dir/nxnode.log"
	mkdir -p "$nx_dir"
fi

if ! stringinstring "$1" "--check|--setkey|--agent"; then
	read CMDLINE;
	set_vars_from_ampstr "$CMDLINE" "" "recode"
	if [ -z "$session_id" ]; then
		echo "NX> 500 Error: Fatal - Missing parameter session id." 1>&2
		exit 1
	fi
	declare -g sess_id="$SERVER_NAME-$display-$session_id"
	declare -g NXSESSION_DIRECTORY="$nx_dir/C-$sess_id"
	nxuser_logfile="$nx_dir/nxnode-$sess_id.log"
	nxlog "$0 ($$): run nxnode with PARAMS:\"$@\"; CMDLINE='$CMDLINE'"
else
	nxlog "$0 ($$): run nxnode with \"$@\""
fi

case "$1" in
	--startsession)
		startsession
	;;
	--resumesession)
		startsession "restore"
	;;
	--applicationsession)
		startsession "application"
	;;
	--terminate)
		cmd_node_terminate
	;;
	--suspend)
		cmd_node_suspend
	;;
	--smbmount)
		cmd_node_smbmount
	;;
	--addprinter)
		cmd_node_addprinter
	;;
	--check)
		echo "NX> 716 finished"
	;;
	--agent)
		echo "NX> 716 Starting NX Agent ..."
		shift
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		PATH="$PATH:$PATH_BIN" $COMMAND_NXAGENT \
			-name "NX Agent Test - Args: $@" $@
		echo "NX> 716 NX Agent exited with status: $?"
	;;
	--setkey)
		mkdir -m 700 -p $HOME/.ssh
		if ! grep -q "$(cat $NX_ETC_DIR/users.id_dsa.pub)" $HOME/.ssh/$SSH_AUTHORIZED_KEYS 2>/dev/null; then
			cat $NX_ETC_DIR/users.id_dsa.pub >> $HOME/.ssh/$SSH_AUTHORIZED_KEYS
			chmod 600 $HOME/.ssh/$SSH_AUTHORIZED_KEYS
			echo "NX> 716 Public key added to: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
		else
			echo "NX> 716 Public key is already present in: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
		fi
	;;
	*)
		echo "NX> 500 Error: Command not found"
	;;
esac

echo "$delim 1001 Bye."
