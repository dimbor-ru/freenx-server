#!/bin/bash

# Free implementation of nxserver components
#
# nxnode does accept (for now):
#
#	--startsession
#	--terminate
#	--smbmount
#
# Copyright (c) 2004 by Fabian Franz.
#           (c) 2008-19 by Dmitry Borisov <i@dimbor.ru>
#
# License: GNU GPL, version 2
#
# SVN: $Id: nxnode 613 2008-09-01 20:42:31Z fabianx $
#
# 21.06.2004: - Full reconnection support

# Read the config file
. $(PATH=$(cd $(dirname $0) && pwd):$PATH which nxloadconfig) --userconf

#JJK: Added	following 'if' stanza as a kluge since the following variables
#JJK: need to be set in cmd_node_smbmount node_umount_smb
#JJK: but they are currently set only in startsession which is called
#JJK: separately from nxserver via ssh so environment variables
#JJK: aren't preserved.
if [[ "$SAMBA_MOUNT_SHARE_PROTOCOL" = "cifs" || \
		( "$SAMBA_MOUNT_SHARE_PROTOCOL" = "both" && \
		`which "$COMMAND_SMBMOUNT_CIFS"` && `which "$COMMAND_SMBUMOUNT_CIFS"` ) \
			]] > /dev/null 2>&1; then
	COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS
	COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
	SAMBA_MOUNT_SHARE_PROTOCOL="cifs"
fi

#
# -----------------------------------------------------------------------------
# Startup of nxnode
# -----------------------------------------------------------------------------
#
DELIM="NX>"
[ -n "$2" ] && DELIM="NX-$2>"

echo "$DELIM 1000 NXNODE - Version $NX_VERSION $NX_LICENSE"

if [ "$1" != "--check" -a "$1" != "--setkey" -a "$1" != "--agent" \
		-a "$1" != "--slave" ]; then
	read CMDLINE; CMDLINE="a=b&$CMDLINE"
fi
#
# -----------------------------------------------------------------------------
# Various helper functions
# -----------------------------------------------------------------------------
#
stringinstring() { case "$2" in *$1*) return 0 ;; esac; return 1; }

getparam() {
	pat=".*&$1=([^&]*)";	str="&$CMDLINE"
	[[ "$str" =~ $pat ]]; local r=${BASH_REMATCH[1]}
	echo -e "${r//\%/\\x}"; [ "$BASH_REMATCH" != "" ]
}

cutfn() {
#args: line delim field_num_start_at_0
	local IFS="$2"; local a=($1);
	#echo "${a[($3)]}" # negative values works on all systems?
	echo "${a[@]:($3):1}"
}

rematchfn(){
#args: (pattern) <text> [match_num=0] [reversive]
# if match_num == "all" returns all found matches delimited by newlines
	local pat="$1"; local n; [ -z "$3" -o "$3" = "all" ] && n=0 || n="$3"
	local OIFS=$IFS local IFS=$'\n'; local a=($2); IFS=$OIFS
	local ntl=${#a[@]}; local nr=0; local r=()
	if [ -z "$4" ]; then
		for ((i=0;i<$ntl;i++)) {
			[[ "${a[$i]}" =~ $pat ]] || continue
			((nr++)); r+=(${BASH_REMATCH[1]})
			[ "$nr" = "$n" ] && break
		}
	else
		for ((i=$ntl;i>=0;i--)) {
			[[ "${a[$i]}" =~ $pat ]] || continue
			((nr++)); r+=(${BASH_REMATCH[1]})
			[ "$nr" = "$n" ] && break
		}
	fi
	if [ "$3" = "all" ]; then
		local res=""; local r;
		for r in ${r[@]}; do res+="${res:+$'\n'}$r"; done
		echo "$res"
	else echo "${r[($n)]}"
	fi
	[ "$nr" != "0" ]
}

ip4_pattern='[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+'

find_app() { set -- $*; which $1 2>/dev/null; }

getparam_sessionid() {
	sessionid=$(getparam sessionid)
	[ -n "$sessionid" ] || sessionid=$(getparam session_id)
	if [ -z "$sessionid" ]; then
		echo "NX> 500 Error: Fatal - Missing parameter session id." 1>&2
		exit 1
	fi
	echo $sessionid
}

echo_secure() {
	if [ "$NX_LOG_SECURE" = "0" ]; then echo "$@ "
	else echo "${@//&password=*&/&password=****&} "
	fi
}

nxlog() {
	[ "$NX_LOG_LEVEL" -lt 6 ] && return 0
	echo_secure "$(date "+%X"): $@" >> "$NX_USER_LOG_FILE"
}

if [ "$USER" = "nx" ]; then NX_USER_LOG_FILE="/var/log/nx/nxnode.log"
else
	NX_USER_LOG_FILE="$USER_FAKE_HOME/.nx/nxnode.log"
	mkdir -p "$USER_FAKE_HOME/.nx"
fi

if [ -n "$CMDLINE" ]; then
	if [ "$USER" != "nx" ]; then
		ssid4log=$(getparam uniqueid)
		[ -z "$ssid4log" ] && ssid4log=$(getparam session_id)
		[ -z "$ssid4log" ] && ssid4log=$(getparam sess_id)
		[ -z "$ssid4log" ] && ssid4log=$(getparam sessionid)
		ssid4log=${ssid4log##*-}
		[ -n "$ssid4log" ] && \
			NX_USER_LOG_FILE="$USER_FAKE_HOME/.nx/nxnode-$ssid4log.log"
	fi
	nxlog "$0 ($$): run nxnode with PARAMS:\"$@\"; CMDLINE:\"$CMDLINE\""
else
	nxlog "$0 ($$): run nxnode with \"$@\""
fi

#
# -----------------------------------------------------------------------------
# Node functions module
# -----------------------------------------------------------------------------
#

norm_param() {
# arg: string
# dimbor: normalize string from hex (thnx 2Civil at unixforum.org) and convert
# charset if needed
	#nxlog "$FUNCNAME ($$): starting with args \"$@\""
	res=${1/+/ }
	#which iconv 1>/dev/null 2>&1; RC=$?
	#[ -n "$WIN_CP_CONVERT_CHAIN" -a $RC -ne 0 ] && {
	#	nxlog "$FUNCNAME ($$): iconv not found, codepages converting is disabled."
	#	echo $res; return
	#}
	for cp_pair in $WIN_CP_CONVERT_CHAIN ; do
		cp_from=$(cutfn "$cp_pair" '>' 0)
		[ -n "$cp_from" ] || cp_from="UTF-8"
		cp_to=$(cutfn "$cp_pair" '>' 1)
		[ -n "$cp_to" ] || cp_to="UTF-8"
		res=$(echo "$res" | iconv -f $cp_from -t $cp_to)
		#nxlog "$FUNCNAME ($$): converting $cp_from > $cp_to == \"$res\""
	done
	#nxlog "$FUNCNAME ($$): return res === \"$res\""
	echo $res
}

# dimbor: functions to control user's shares and printers in mode "per user"
# instead of "per session".

get_mport2sessdir() {
# args: session dir type="smb"|"ipp""
# ret: cups listening port or samba mount port
	type=$2
	smbport=$(cat $1/scripts/mport 2>/dev/null) # check smb mount port
	cport=$(cat $1/session 2>/dev/null);
	cport=$(rematchfn "Listening to CUPS.+'(.+)'" "$cport" 0 "rev") #'
	mport=""
	if [ "$type" != "smb" -a -n "$cport" ]; then mport=$cport; type="ipp";
	elif [ "$type" != "ipp" -a  -n "$smbport" ]; then
		mport=$smbport; type="smb";
	fi
	mport=${mport##*:}
	nxlog "$FUNCNAME ($$): sessdir \"$1\"; mport == $mport \"$type\""
	echo $mport
}

get_sessdir4res() {
# args: port - session's smb/ipp mount port OR filename of printer/share
# (flag-file) fl_current - if set then includes in search current session-dir
# if share is nx-controlled and nxagent from his session are leave,
# then returns name of session dir (except dir of own sesson)
# functuion used with $ENABLE_SHARE_MULTIMOUNT=1 or
# $ENABLE_CUPS_SERVER_MODE=1 modes only
	nxlog "$FUNCNAME ($$): starting with args \"$@\"; sess_id == \"$sess_id\""
	[ "$1" -gt 0 2>/dev/null ] && digarg=1 || digarg=0
	AGENT_PIDS=$(ps -wo pid= -C "nxagent")
	for sessdir in $USER_FAKE_HOME/.nx/C-* ; do
		[ -z "$2" -a "$sessdir" == "$USER_FAKE_HOME/.nx/C-$sess_id" ] && \
			continue
		NODE_AGENT_PID=$(cat "$sessdir/pids/agent" 2>/dev/null)
		[ -z "$NODE_AGENT_PID" ] && continue
		stringinstring "$NODE_AGENT_PID" "$AGENT_PIDS" || continue
		#nxlog "$FUNCNAME ($$): browse sessdir \"$sessdir\" for filename = \"$sessdir/scripts/$1\", digarg=$digarg"
		if [ "$digarg" = "1" ]; then
			curport=$(get_mport2sessdir "$sessdir")
			[ "$curport" = "$1" ] && {
				nxlog "$FUNCNAME ($$): found sessdir $sessdir for mport = $1"
			echo "$sessdir"; return;
			}
		else
			[ -f "$sessdir/scripts/$1" ] && {
				nxlog "$FUNCNAME ($$): found sessdir $sessdir for filename = $1"
				echo "$sessdir"; return;
			}
		fi
	done
	nxlog "$FUNCNAME ($$): target sessdir not found"
}

check_remote_printer() {
# args: type - "smb" or "ipp"
# short sharename/printername
# port - nx controlled mount port
# name - user name
# pass - password (optional)
# if shared printer accessible, returns 1, else - 0
	nxlog "$FUNCNAME ($$): starting with args \"$@\""
	if [ "$1" = "ipp" ]; then # checking ipp printer port only
	res=0
	for (( i=10; $i; --i )); do
		nxlog "$FUNCNAME ($$): wait for ipp-port 127.0.0.1:$3 - $((10-i))"
		$COMMAND_NETCAT -znvw 1 127.0.0.1 $3 2> /dev/null > /dev/null
		[ $? -eq 0 ] && { res=1; break; }
		sleep 1
	done
	nxlog "$FUNCNAME ($$): end with res = $res"
	echo $res; return 0;
	fi
	[ "$(cutfn "$2" "-" "-1")" = "nocheck" ] && {
		res=1
		nxlog "$FUNCNAME ($$): special sharename \"$2\" - stop checking, end with res = $res"
		echo $res; return 0;
	}
	NXREDIR_LIBRARY="$PATH_LIB/freenx-server/libnxredir.so.0"
	[ -n "$5" ] && upass="$4%$5" || upass="$4 -N"
	[ "$SAMBA_MOUNT_SHARE_PROTOCOL" = "cifs" ] && dport=445 || dport=139
	CMDSTR="/usr/bin/rpcclient -U '$upass' -c 'openprinter $2' -p $dport -I 127.0.0.1 127.0.0.1 2>&1"
	nxlog "$FUNCNAME ($$): invoke command \"$CMDSTR\""
	res=""; numa="0"; ret="0"
	while [ "$ret" = "0" ]; do
		# addprinter and addmount try to use one mport at the same time,
		# we need to endure ;)
		(( numa++ ))
		res=$(NXSAMBA_PORT=$3 LD_PRELOAD=$NXREDIR_LIBRARY eval $CMDSTR)
		nxlog "$FUNCNAME ($$): on attempt $numa says \"$res\""
		[ -n "$(rematchfn '(successfully)' "$res")" ] && { ret="1"; continue; }
		[ "$numa" -gt 4 ] && ret="1" && res="timeout"
	done
	[ -n "$(rematchfn '(successfully)' "$res")" ] && res=1 || res=0
	nxlog "$FUNCNAME ($$): end with res = $res"
	echo $res
}

check_local_pa_tunnel() {
# params:	tunnel ip:port
#		resample rate
#		amount of channels
# return:	pid of pa process
# This starts user's local pulseaudio server if not running and tune its own
# modules - (re)create tunneled sink and source to remote pa
	pactl_bin=$(find_app "pactl")
	[ -z "$pactl_bin" ] && {
		nxlog "$FUNCNAME ($$): pactl tool not found. Pulseaudio may be not installed."
		echo ""; return 1;
	}
	pactl_bin="env LANG=C $pactl_bin"
	unset PULSE_SERVER; unset PULSE_SINK; unset PULSE_SOURCE
	# automatic start user's pa is here (pa starting with default system settings)
	errstr=$($pactl_bin info 2>&1)
	[ -n "$(rematchfn '(failure)' "$errstr")" ] && {
		nxlog "$FUNCNAME ($$): Local PA is not reachable ($errstr)."
		echo ""; return 1;
	}
	retpid=$(ps -wo pid= -C "pulseaudio")
	[ -n "$retpid" ] && nxlog "$FUNCNAME ($$): Found PA:$retpid"
	lpa_mods=$($pactl_bin list short 2>/dev/null)
	tunn_opts="server=$1"
	tunn_exists=$(rematchfn "($tunn_opts)" "$lpa_mods") #"
	[ -n "$tunn_exists" ] && {
		nxlog "$FUNCNAME ($$): Right modules already exists: $tunn_exists"
		echo $retpid; return 0;
	}
	mname="module-always-sink" # automatic null-sinks will be disabled
	rmids=$(rematchfn "^([[:digit:]]+)[[:space:]]+$mname" "$lpa_mods") #"
	# any sinks and sources will be unloaded too
	rmids+="${rmids:+ }$(rematchfn "^([[:digit:]]+).+sink_name" "$lpa_mods")" #"
	rmids+="${rmids:+ }$(rematchfn "^([[:digit:]]+).+source_name" "$lpa_mods")" #"
	[ -n "$rmids" ] && {
		errids=""; errstr=""
		for i in $rmids; do
			errstr2=$($pactl_bin unload-module $i 2>&1)
			[ $? -ne 0 ] && { errids="$errids $i"; errstr="$errstr; $errstr2"; }
		done
	}
	[ -n "$errids" ] && {
		nxlog "$FUNCNAME ($$): Removing PA modules error. ids=\"$errids\"; \"$errstr\" "
	}
	mname_tunn_sink="module-tunnel-sink"; mname_tunn_source="module-tunnel-source"
	rpa_info=$($pactl_bin -s $1 info 2>/dev/null)
	[ -z "$rpa_info" ] && {
		nxlog "$FUNCNAME ($$): Couldn't get defaults from REMOTE pulseaudio $1."
		echo ""; return 1;
	}
	[ -n "$2" ] && {
		tunn_opts="$tunn_opts rate=$2"
		[ -n "$3" ] && {
			tunn_opts="$tunn_opts channels=$3"
			[ "$3" == "1" ] && tunn_opts="$tunn_opts channel_map=mono"
		}
	}
	success=""
	def_rsink=$(rematchfn "Default Sink:[[:space:]]+(.+)" "$rpa_info") #"
	if [ -z "$def_rsink" -o "$def_rsink" == "(null)" ]; then
		nxlog "$FUNCNAME ($$): Couldn't get default sink from REMOTE pulseaudio $1."
	else # load module-tunnel-sink
		rsi_args="sink_name=tcl_out sink=$def_rsink $tunn_opts"
		errstr=$($pactl_bin load-module $mname_tunn_sink $rsi_args 2>&1)
		[ $? -ne 0 ] && {
			nxlog "$FUNCNAME ($$): Loading module $mname_tunn_sink error (\"$rsi_args\"); \"$errstr\""
		} || {
			success="1"
			nxlog "$FUNCNAME ($$): Successfully loadded module $mname_tunn_sink  (\"$rsi_args\")."
		}
	fi
	def_rsource=$(rematchfn "Default Source:[[:space:]]+(.+)" "$rpa_info") #"
	if [ -z "$def_rsource" -o "$def_rsource" == "(null)" -o \
			"$def_rsource" == "$def_rsink.monitor" ]; then
		nxlog "$FUNCNAME ($$): Couldn't get default source from REMOTE pulseaudio $1."
	else # load module-tunnel-source
		rso_args="source_name=tcl_in source=$def_rsource $tunn_opts"
		errstr=$($pactl_bin load-module $mname_tunn_source $rso_args 2>&1)
		[ $? -ne 0 ] && {
			nxlog "$FUNCNAME ($$): Loading module $mname_tunn_source error (\"$rso_args\"); \"$errstr\""
		} || {
			success="1"
			nxlog "$FUNCNAME ($$): Successfully loadded module $mname_tunn_source  (\"$rso_args\")."
		}
	fi
	[ -n "$success" ] && echo $retpid || echo ""
}

reconnect_pa() {
	papid=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/pa_pid" 2>/dev/null)
	[ -z "$papid" ] && return
	mmport=""; papars="";
	AGENT_PIDS=$(ps -wo pid= -C "nxagent")
	for sessdir in $USER_FAKE_HOME/.nx/C-*; do # start port search
		[ "$sessdir" == "$USER_FAKE_HOME/.nx/C-$sess_id" ] && continue
		NODE_AGENT_PID=$(cat "$sessdir/pids/agent" 2>/dev/null)
		[ -z "$NODE_AGENT_PID" ] && continue
		stringinstring $NODE_AGENT_PID "$AGENT_PIDS" || continue
		mmport=$(cat "$sessdir/scripts/mmport" 2>/dev/null)
		[ -n "$mmport" ] && break
	done
	if [ -n "$mmport" ]; then # try reconnect
		papars=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/params.pa" 2>/dev/null)
		rate=$(cutfn "$papars" ":" 0)
		channels=$(cutfn "$papars" ":" 1)
		[ -z "$(check_local_pa_tunnel 127.0.0.1:$mmport $rate $channels)" ] && {
			nxlog "$FUNCNAME ($$): Couldn't reconnect PA tunnel to port $mmport."
		}
	else # kill local PA
		kill $papid 2>/dev/null
	fi
}

# node_terminate_agent <session id>
node_terminate_agent() {
	nxlog "$FUNCNAME ($$): starting"
	NODE_AGENT_PID=$(cat "$USER_FAKE_HOME/.nx/C-$1/pids/agent" 2>/dev/null)
	[ -n "$NODE_AGENT_PID" ] && { nxlog "$FUNCNAME ($$): killing NODE_AGENT_PID"
		kill $NODE_AGENT_PID 2>/dev/null;
		sleep 0.3s
	}
	kill -0 $NODE_AGENT_PID && {
		nxlog "$FUNCNAME ($$): killing NODE_AGENT_PID. Try #2"
		kill -9 $NODE_AGENT_PID 2>/dev/null
	}
	nxlog "$FUNCNAME ($$): end"
}

# node_terminate_session <session id>
#	Used local vars: $virtualdesktop, $rootless
#	Used config vars: $COMMAND_XAUTH, $SESSION_LOG_CLEAN
node_terminate_session() {
	#
	# Cleanup session
	#
	nxlog "$FUNCNAME ($$): starting"
	[ -d "$USER_FAKE_HOME/.nx/C-$1/" ] || {\
		nxlog "$FUNCNAME ($$): Session directory not found."
		return;
	}
	[ -e "$USER_FAKE_HOME/.nx/C-$1/terminating" ] && {\
		nxlog "$FUNCNAME ($$): Terminating still in progress. Bye."
		return;
	}
	touch "$USER_FAKE_HOME/.nx/C-$1/terminating"

	nxlog "$FUNCNAME ($$): Start terminating session \"$1\" with status \"$2\""

	# Kill nxagent
	NODE_AGENT_PID=$(cat "$USER_FAKE_HOME/.nx/C-$1/pids/agent" 2>/dev/null)

	# JJK: Kill running services
	# FF: Seems this is needed also here ...
	# dimbor: ... but have to be a little more tender ;)
	nxlog "$FUNCNAME ($$): call node_stop_services"
	node_stop_services
	if [ -n "$NODE_AGENT_PID" ]; then
		nxlog "$FUNCNAME ($$): start killing of nxagent"
		kill $NODE_AGENT_PID 2>/dev/null
		wait $NODE_AGENT_PID 2>/dev/null
		kill -0 $NODE_AGENT_PID ||
			nxlog "$FUNCNAME ($$): nxagent ($NODE_AGENT_PID) is dead now"
	fi

	# Kill tail process
	NODE_TAIL_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail" 2>/dev/null)
	[ -n "$NODE_TAIL_PID" ] && { nxlog "$FUNCNAME ($$): kill tail process"
		kill $NODE_TAIL_PID 2>/dev/null;
	}

	# Remove display information
	nxlog "$FUNCNAME ($$): Remove display information"
	NODE_DISPLAY=$(cutfn "$1" "-" -2)
	rm -f /tmp/.X$NODE_DISPLAY-lock; rm -f /tmp/.X11-unix/X$NODE_DISPLAY

	# Remove magic cookie information
	nxlog "$FUNCNAME ($$): Remove magic cookie information"
	$COMMAND_XAUTH -v source "$USER_FAKE_HOME/.nx/C-$1/scripts/authority" >/dev/null 2>&1

	# Preserve or remove session information
	nxlog "$FUNCNAME ($$): Preserve or remove session information"
	if [ "$SESSION_LOG_CLEAN" = "1" ]; then
		nxlog "$FUNCNAME ($$): Clean session information."
		rm -rf "$USER_FAKE_HOME/.nx/C-$1/"
		rm -f  "$USER_FAKE_HOME/.nx/nxnode-$1.log"
		rm -f  "$USER_FAKE_HOME/.nx/nxnode.log"
	fi
	if [ "$SESSION_LOG_CLEAN" = "0" -a "$2" = "failed" ] ; then
		nxlog "$FUNCNAME ($$): Session failed. Rename session directory from \"$USER_FAKE_HOME/.nx/C-$1/\" to \"$USER_FAKE_HOME/.nx/F-C-$1\""
		mv "$USER_FAKE_HOME/.nx/C-$1/" "$USER_FAKE_HOME/.nx/F-C-$1"
		rm -f "$USER_FAKE_HOME/.nx/F-C-$1/terminating"
	elif [ "$SESSION_LOG_CLEAN" = "0" -a "$2" != "failed" ] ; then
		nxlog "$FUNCNAME ($$): Session terminated. Rename session directory from \"$USER_FAKE_HOME/.nx/C-$1/\" to \"$USER_FAKE_HOME/.nx/T-C-$1\""
		mv "$USER_FAKE_HOME/.nx/C-$1/" "$USER_FAKE_HOME/.nx/T-C-$1"
		rm -f "$USER_FAKE_HOME/.nx/T-C-$1/terminating"
	fi
	nxlog "$FUNCNAME ($$): end"
}


# node_fail_restore_session <session id>
# TODO: Kill still running tail -f process.
node_fail_restore_session() {
	nxlog "$FUNCNAME ($$): starting"
	echo "NX> 1004 Error: Could not resume session. nxagent process could not be found."
	NODE_TAIL_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail" 2>/dev/null)
	[ -n "$NODE_TAIL_PID" ] && kill $NODE_TAIL_PID
	[ -n "$NODE_TAIL_PID" ] && echo "NX 1004> kill $NODE_TAIL_PID"
	nxlog "$FUNCNAME ($$): call 'node_terminate_session \"$1\" \"failed\"'"
	node_terminate_session "$1" "failed"
	nxlog "$FUNCNAME ($$): end. Next is 'exit 1'"
	exit 1
}


# node_suspend_session <session id>
node_suspend_session() {
	nxlog "$FUNCNAME ($$): starting"
	NODE_AGENT_PID=$(cat "$USER_FAKE_HOME/.nx/C-$1/pids/agent" 2>/dev/null)
	if [ -n "$NODE_AGENT_PID" ]; then
		nxlog "$FUNCNAME ($$): NODE_AGENT_PID=\"$NODE_AGENT_PID\". Killing..."
		kill -0 $NODE_AGENT_PID || {
			nxlog "$FUNCNAME ($$): end (0)"
			return 1;
		}
		kill -HUP $NODE_AGENT_PID && {
			nxlog "$FUNCNAME ($$): end (HUP)"
			return 0;
		}
	else
		nxlog "$FUNCNAME ($$): NODE_AGENT_PID is empty"
		nxlog "$FUNCNAME ($$): end"
	fi
	return 1
}


# node_find_application <type>
#	Used config vars: $COMMAND_START_KDE, $COMMAND_START_GNOME,
#			  $COMMAND_START_CDE, $COMMAND_XTERM, $USER_X_STARTUP_SCRIPT,
#			  $DEFAULT_X_SESSION
node_find_application() {
	nxlog "$FUNCNAME ($$): starting with args \"$@\""
	NODE_STARTX=""
	case $1 in
		shadow|windows|vnc)
			:
		;;
		unix-kde)
			NODE_STARTX=$COMMAND_START_KDE
			[ "$KDE4_ENABLE" = "1" -a -n "$COMMAND_START_KDE" ] && \
				NODE_STARTX=$COMMAND_START_KDE4
		;;
		unix-gnome)
			NODE_STARTX=$COMMAND_START_GNOME
		;;
		unix-cde)
			NODE_STARTX=$COMMAND_START_CDE
		;;
		windows-helper)
			application="$PATH_BIN/nxdesktop_helper"
			NODE_STARTX=$application
		;;
		unix-application|vnc-helper)
			[ "$application" = "xterm" ] && application=$COMMAND_XTERM
			NODE_STARTX=$application
		;;
		unix-console)
			NODE_STARTX=$COMMAND_XTERM
		;;
		unix-default|*)
			if [ -x "$HOME/$USER_X_STARTUP_SCRIPT" ]; then
				NODE_STARTX="$HOME/$USER_X_STARTUP_SCRIPT"
			elif which "$DEFAULT_X_SESSION" >/dev/null 2>&1; then
				NODE_STARTX="$DEFAULT_X_SESSION"
			else NODE_STARTX=$COMMAND_XTERM
			fi
		;;
	esac

	# dimbor: another personalyzed way to ACLS control and replace X-application
	[ -d "$NX_ACL_DIR" -a -x "$PATH_BIN/nxacl.app" ] && {
		nxlog "$FUNCNAME ($$): !!! call nxacl.app with source NODE_STARTX=\"$NODE_STARTX\""
		NODE_STARTX=$($PATH_BIN/nxacl.app "$NODE_STARTX" "$CMDLINE")
	}

	nxlog "$FUNCNAME ($$): return NODE_STARTX=\"$NODE_STARTX\""
	echo "$NODE_STARTX"
	nxlog "$FUNCNAME ($$): end"
}

get_pa_sound_mode() {
# params:	port of pa server
#		ipaddr
	[ -z "$2" ] && {
		nxlog "$FUNCNAME ($$): Client's IP-address is not defined."
		echo ""; return 1;
	}
	stringinstring "open" "$($COMMAND_NETCAT -nvz -w 1 $2 $1 2>&1)" || {
		nxlog "$FUNCNAME ($$): Client's pulseaudio at $2:$1 is not reachable."
		echo ""; return 1;
	}
	pactl_bin=$(find_app "pactl")
	[ -z "$pactl_bin" ] && {
		nxlog "$FUNCNAME ($$): pactl tool not found. Pulseaudio may be not installed."
		echo ""; return 1;
	}
	pactl_bin="env LANG=C $pactl_bin -s $2:$1"
	nxlog "$FUNCNAME ($$): $pactl_bin list short"
	cl_pa_mods=$($pactl_bin list short)
	#nxlog "$FUNCNAME ($$): $cl_pa_mods"
	stringinstring "ts_receiver" "$cl_pa_mods" && \
		stringinstring "ts_sender" "$cl_pa_mods" && {
		nxlog "$FUNCNAME ($$): Specials sink and source at $2:$1 are found."
		echo "special"; return 0;
	}
	nxlog "$FUNCNAME ($$): Defaults sink and source at $2:$1 be used."
	echo "default"; return 0;
}

# node_start_applications
#	Used local vars: $type, $application, $sess_id, $mediahelper,
#				 $virtualdesktop, $rootless, $display
#	Used config vars: <several>
node_start_applications() {
	nxlog "$FUNCNAME ($$): starting"
	# close input and output file descriptors
	exec 0<&-
	exec 1>&-
	exec 2>&-

	# Prepare application startup
	export DISPLAY=:$display
	if [ "$ENABLE_SOURCE_PROFILE" = "1" ]; then
		nxlog "$FUNCNAME ($$): source profile"
		. /etc/profile
	fi
	if [ "$ENABLE_SOURCE_BASH_PROFILE" = "1" ]; then
		nxlog "$FUNCNAME ($$): source bash profile"
		[ -f ~/.bash_profile ] && . ~/.bash_profile
		[ -f /etc/bashrc ] && . /etc/bashrc
	fi

	nxlog "$FUNCNAME ($$): DISPLAY is $display"
	cntr=$AGENT_STARTUP_TIMEOUT
	if [ -n "$(which xdpyinfo 2>/dev/null)" ]; then
		while [ -z "$(xdpyinfo  2>/dev/null | head)" ]; do
			let "cntr -= 1"
			[ $cntr -lt 0 ] && break
			sleep 0.3s
			nxlog "$FUNCNAME ($$): Sleep while get a valid DISPLAY ($cntr)"
		done
	else
		nxlog "$FUNCNAME ($$): xdpyinfo not found. Waiting for DISPLAY is not possible!"
	fi

	#numlockx
	if [ "$NUMLOCKX_STATUS" != "system" ]; then
		nxlog "$FUNCNAME ($$): Run \"$NUMLOCKX $NUMLOCKX_STATUS\""
		"$NUMLOCKX" "$NUMLOCKX_STATUS"
	fi

	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/apps/"
	# Which application do we start?
	NODE_APPLICATION=$(node_find_application "$type")
	# For rdesktop/VNC, there is no application to start
	if [ -n "$NODE_APPLICATION" ]; then
		nxlog "$FUNCNAME ($$): Got NODE_APPLICATION is \"$NODE_APPLICATION\""
	else
		nxlog "$FUNCNAME ($$): NODE_APPLICATION is empty"
		return
	fi

	# Check if we want to use a mediahelper
	mmode="$(cutfn "$mediahelper" "-" 0)"
	rate="$(cutfn "$mediahelper" "-" 1)"
	channels="$(cutfn "$mediahelper" "-" 2)"
	mmport="$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mmport" 2>/dev/null)"
	if [ "$mmode" == "pa" -a -n "$mmport" ]; then
		pa_remote="127.0.0.1:$mmport"
		pa_pid="$(check_local_pa_tunnel $pa_remote $rate $channels)"
		if [ -n "$pa_pid" ]; then
			nxlog "$FUNCNAME ($$): Local pulseaudio is started ($pa_pid). Sound mode set to tunneled."
			echo $pa_pid > "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/pa_pid"
			params=$rate
			[ -n "$channels" ] && params="$params:$channels"
			[ -n "$params" ] && echo "$params" > "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/params.pa"
		else
			nxlog "$FUNCNAME ($$): Local pulseaudio NOT STARTED. Set PULSE_SERVER=127.0.0.1:$mmport"
			export PULSE_SERVER="127.0.0.1:$mmport"
		fi
	elif [ "$ENABLE_DIRECT_NATIVE_PA_CHECK" = "1" ] ; then
		native_sound_mode="$(get_pa_sound_mode 4713 $NXUSERIP)"
		if [ -n "$native_sound_mode" ]; then
			nxlog "$FUNCNAME ($$): Sound mode set to direct $native_sound_mode"
			export PULSE_SERVER="$NXUSERIP:4713"
			if [ "$native_sound_mode" = "special" ]; then
				export PULSE_SINK="ts_receiver"
				export PULSE_SOURCE="ts_sender.monitor"
			fi
			PADSP_BIN_PRELOAD="$(find_app "padsp")"
			[ -n "$PADSP_BIN_PRELOAD" ] && {
			NODE_APPLICATION="$PADSP_BIN_PRELOAD $NODE_APPLICATION"
			} || nxlog "$FUNCNAME ($$): padsp script not found. Sound may be disabled."
		fi
	elif [ "$mediahelper" = "esd" ]; then
		# Set Espeaker variable
		let ESPEAKER=$display+7000
		export ESPEAKER="127.0.0.1:$ESPEAKER"
		# Do not spawn new ESD daemons
		export ESD_NO_SPAWN="yes"
		# Check for config file directive
		if [ "$ENABLE_ESD_PRELOAD" = "1" -a \
				-x "$(find_app $ESD_BIN_PRELOAD)" ]; then
			nxlog "$FUNCNAME ($$): Preload \"$ESD_BIN_PRELOAD\""
			NODE_APPLICATION="$ESD_BIN_PRELOAD $NODE_APPLICATION"
			nxlog "$FUNCNAME ($$): NODE_APPLICATION is \"$NODE_APPLICATION\""
			echo "Info: NXNODE - Using $ESD_BIN_PRELOAD wrapper script." >> "$USER_FAKE_HOME/.nx/C-$sess_id/session"
		fi
	elif [ "$mediahelper" = "artsd" ]; then
		# Overwrite users mcoprc
		echo -n "GlobalComm=Arts::X11GlobalComm" > $HOME/.mcoprc
		if [ "$ENABLE_ARTSD_PRELOAD" = "1" -a \
				-x "$(find_app $ARTSD_BIN_PRELOAD)" ]; then
			NODE_APPLICATION="$ARTSD_BIN_PRELOAD $NODE_APPLICATION"
			echo "Info: NXNODE - Using $ARTSD_BIN_PRELOAD wrapper script." >> "$USER_FAKE_HOME/.nx/C-$sess_id/session"
		fi
	fi

	[ "$ENABLE_CUPS_SERVER_MODE" = "1" ] && {
		CUPS_SERVER_SOCKET=$(LC_ALL=C /usr/bin/lpstat -H 2>/dev/null)
		[ -r $CUPS_SERVER_SOCKET ] || CUPS_SERVER_SOCKET=""
	} || CUPS_SERVER_SOCKET="$USER_FAKE_HOME/.nx/C-$sess_id/cups/cups.sock"
	[ "$ENABLE_CUPS_SERVER_EXPORT" = "1" -a -n "$CUPS_SERVER_SOCKET" ] && {
		[ "$cups" = "1" -o "$samba" = "1" ] && {
			nxlog "$FUNCNAME ($$): export CUPS_SERVER=$CUPS_SERVER_SOCKET"
			export CUPS_SERVER="$CUPS_SERVER_SOCKET"
		}
	}
	if [ "$ENABLE_SAMBA_PRELOAD" = "1" -a -x "$PATH_BIN/nxredir" ]; then
		let NXSAMBA_PORT=$display+3000
		export NXSAMBA_PORT
		nxlog "$FUNCNAME ($$): Preload SAMBA using nxredir. NXSAMBA_PORT is \"$NXSAMBA_PORT\""
		NODE_APPLICATION="$PATH_BIN/nxredir $NODE_APPLICATION"
		echo "Info: NXNODE - Using nxredir wrapper script to forward SMB ports 139 and 445 to port $NXSAMBA_PORT." >> "$USER_FAKE_HOME/.nx/C-$sess_id/session"
	fi


	# Do we need to PRELOAD any libraries?
	[ "$virtualdesktop" = "0" -a "$rootless" != "1" ] && export LD_PRELOAD="$APPLICATION_LIBRARY_PRELOAD:$LD_PRELOAD"

	# Should we start a window manager?
	if [ "$virtualdesktop" = "1" -a "$type" = "unix-application" -a \
			"$DEFAULT_X_WM" != "" -a -x "$(find_app $DEFAULT_X_WM)" ]; then
		nxlog "$FUNCNAME ($$): start a window manager - \"DISPLAY=:$display $DEFAULT_X_WM\""
		DISPLAY=:$display $DEFAULT_X_WM >>"$USER_FAKE_HOME/.nx/C-$sess_id/session" 2>&1 &
		NODE_WM_PID=$!
		nxlog "$FUNCNAME ($$): NODE_WM_PID=\"$NODE_WM_PID\""
	fi

	# Use Xsession to execute the Desktop session
	case $type in
		unix-gnome)
			export STARTUP="$NODE_APPLICATION"
			if [ "$login_method" = "GUEST" ]; then
				NODE_APPLICATION=$COMMAND_GUEST_X_SESSION
			elif [ "$BOOTSTRAP_X_SESSION" = "1" ]; then
				NODE_APPLICATION=$COMMAND_GDM_X_SESSION
			fi
		;;
		unix-kde|unix-cde)
			export STARTUP="$NODE_APPLICATION"
			if [ "$login_method" = "GUEST" ]; then
				NODE_APPLICATION=$COMMAND_GUEST_X_SESSION
			elif [ "$BOOTSTRAP_X_SESSION" = "1" ]; then
				NODE_APPLICATION=$DEFAULT_X_SESSION
			fi
		;;
	esac

	SECOND_APP=""; NX_SAPP_PIDS0=""
	[ $ENABLE_ROOTLESS_TERMINATE_SESSION = "1" -a "$rootless" = "1" ] && {
		NAPP=$(cutfn "$NODE_APPLICATION" " " 0)
		NAPP=$(cutfn "$NAPP" "/" -1)
		SECOND_APP=$(rematchfn "$NAPP:(.+)" "${APP_WAIT_MAP//;/$'\n'}") #"
		[ -n "$SECOND_APP" ] && {
			NX_SAPP_PIDS0=$(ps -wo pid= -C $(cutfn "$SECOND_APP" "/" -1))
			nxlog "$FUNCNAME ($$): PID of $SECOND_APP will be waiting too. Initial: \"$NX_SAPP_PIDS0\""
		}
	}

	# Startup the application
	nxlog "$FUNCNAME ($$): Starting NODE_APPLICATION with /etc/nxserver/Xsession"
	DISPLAY=:$display /etc/nxserver/Xsession $NODE_APPLICATION >> \
		"$USER_FAKE_HOME/.nx/C-$sess_id/session" 2>&1 &
	NODE_APP_PID=$!
	nxlog "$FUNCNAME ($$): Start successful. NODE_APP_PID=$NODE_APP_PID"

	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
	echo "$NODE_APP_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/apps/$NODE_APP_PID"
	nxlog "$FUNCNAME ($$): Waiting for NODE_APP_PID"
	wait $NODE_APP_PID
	nxlog "$FUNCNAME ($$): NODE_APP_PID finished"

	# Kill or wait for the started window manager
	[ -n "$NODE_WM_PID" ] && {
		nxlog "$FUNCNAME ($$): NODE_WM_PID is not empty"
		# kill the WM after application is finished?
		[ "$KILL_DEFAULT_X_WM" = "1" ] && { nxlog "$FUNCNAME ($$): killing $NODE_WM_PID"
			kill $NODE_WM_PID 2>/dev/null; }
		# or just wait until it finishes?
		[ "$KILL_DEFAULT_X_WM" = "1" ] || { nxlog "$FUNCNAME ($$): wait for $NODE_WM_PID is dead"
			wait $NODE_WM_PID; }
	}
	nxlog "$FUNCNAME ($$): Clean pids/apps/$NODE_APP_PID"
	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/apps/$NODE_APP_PID"

	sleep "$NODE_APP_WAIT_TIMEOUT"s

	[ $ENABLE_ROOTLESS_TERMINATE_SESSION = "1" -a "$rootless" = "1"  ] && {
		if [ -n "$SECOND_APP" ] ; then
			NX_SAPP_PIDS="";
			NX_SAPP_PIDS1=$(ps -wo pid= -C $(cutfn "$SECOND_APP" "/" -1))
			while read SPID; do
				stringinstring "$SPID" "$NX_SAPP_PIDS0" && continue
				NX_SAPP_PIDS="$NX_SAPP_PIDS${NX_SAPP_PIDS:+$' '}$SPID"
			done <<< "$NX_SAPP_PIDS1"
			nxlog "$FUNCNAME ($$): Waiting for $SECOND_APP PID(S) \"$NX_SAPP_PIDS\""
			while [ -n "$(ps -o pid= -p $NX_SAPP_PIDS 2>/dev/null)" ]; do
				sleep 1s
			done
			nxlog "$FUNCNAME ($$): PID(S) \"$NX_SAPP_PIDS\" finished"
			node_terminate_session "$sess_id"
		else  node_terminate_session "$sess_id"
		fi
	}

	# Do not terminate agent in case of rootless agent mode.
	# The agent times out after a while by itself anyway.
	if [ "$virtualdesktop" = "1" -o "$rootless" != "1" ] ; then
		nxlog "$FUNCNAME ($$): Call node_terminate_agent for non-rootless or virtualdesktop session type"
		nxlog "$FUNCNAME ($$): Call 'node_terminate_agent \"$sess_id\"'"
		node_terminate_session "$sess_id"
	fi
	nxlog "$FUNCNAME ($$): end"
}


# node_persistent_session
# Is the user allowed to run a persistent session?
node_agent_persistent_session() {
	P="-nopersistent"
	# Guest sessions are always nonpersistent
	if [ "$login_method" = "GUEST" ]; then
		echo "$P"; return
	fi
	OLD_IFS=$IFS; IFS=","
	if [ "$ENABLE_PERSISTENT_SESSION" = "all" ]; then P="-persistent"
	else
		for USERNAME in $ENABLE_PERSISTENT_SESSION; do
			[ "${USERNAME:0:1}" != "@" ] && [ "$USER" = "$USERNAME" ] && \
				P="-persistent" && break;
			[ "${USERNAME:0:1}" = "@" ] && \
				[ -z $(groups "$USER" | egrep "^${USERNAME:1}:") ] && \
					P="-persistent" && break;
		done
	fi
	for USERNAME in $DISABLE_PERSISTENT_SESSION; do
		[ "${USERNAME:0:1}" != "@" ] && [ "$USER" = "$USERNAME" ] && \
			P="-nopersistent" && break;
		[ "${USERNAME:0:1}" = "@" ] && \
			[ -z $(groups "$USER" | egrep "^${USERNAME:1}:") ] && \
				P="-nopersistent" && break;
	done
	IFS=$OLD_IFS
	echo "$P"
}

# node_start_agent
node_start_agent() {
	# Ok, now we do some wicked fd magic.
	#
	# first part:
	#
	# nxagent's fd #2 -> fd #3

	# second part:
	#
	# fd #1 -> #4
	# fd #3 -> #1
	# tee | node_start_monitor

	# third part
	# fd #4 -> #1

	# => all output of nxagent goes to tee | node_start_monitor, while
	#    leaving all other output flow through like normally.

	# preparations
	nxlog "$FUNCNAME ($$): starting"
	exec 3>&2
	exec 4>&1

	{

	{

	# Setup environment
	if [ "$ENABLE_SOURCE_PROFILE" = "1" ]; then
		nxlog "$FUNCNAME ($$): source profile"
		. /etc/profile
	fi
	if [ "$ENABLE_SOURCE_BASH_PROFILE" = "1" ]; then
		nxlog "$FUNCNAME ($$): source bash profile"
		[ -f ~/.bash_profile ] && . ~/.bash_profile
		[ -f /etc/bashrc ] && . /etc/bashrc
	fi

	export DISPLAY="nx/nx,options=$USER_FAKE_HOME/.nx/C-$sess_id/options:$display"
	export XAUTHORITY="$USER_FAKE_HOME/.nx/C-$sess_id/authority"
	export HOME="$USER_FAKE_HOME"
	export NX_CLIENT="$PATH_BIN/nxdialog"

	# Setup optional parameters for nxagent
	# keyboard
	K=""
	# backwards compatibility
	[ -n "$keyboard" ] && K="-keyboard $keyboard"
	[ -n "$kbtype" ] && K="-kbtype $kbtype"

	# backingstore
	B=""
	if [ -n "$backingstore" -a "$ENABLE_1_5_0_BACKEND" = "1" ]; then
		[ "$backingstore" != 1 ] && B="-bs $backingstore"
		[ "$backingstore" = 1 ] && B="+bs"
	fi

	# geometry
	G=""
	[ -n "$geometry" ] && G="-geometry $geometry"

	# type of session
	R="-D"; [ "$rootless" = "1" ] && R="-R"

	# Setup fullscreen parameters
	vncfullscreen=""
	[ "$geometry" = "fullscreen" -a "$type" = "vnc" ] && \
		vncfullscreen="-fullscreen" && G=""
	[ "$geometry" = "fullscreen" -a "$type" = "windows" ] && \
		G="-geometry $(rematchfn '^([[:digit:]]+x[[:digit:]]+)' $screeninfo)"

	# Start the wanted nxagent
	if [ "$type" = "windows" ]; then
		nxlog "$FUNCNAME ($$): Type \"windows\""
		# nxdesktop session (Windows RDP)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup optional parameters
		U=""; P=""; D=""
		[ -n "$agent_user" ] && U="-u $agent_user"
		[ -n "$agent_password" ] && P="-p -"
		[ -n "$agent_domain" ] && D="-d $agent_domain"
		# Start the agent
		echo "$agent_password" | $PATH_BIN/nxdesktop \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$USER_FAKE_HOME/.nx/C-$sess_id/options" \
			$K $G $U $P $D $agent_server $AGENT_EXTRA_OPTIONS_RDP 2>&3 &

	elif [ "$type" = "vnc" ]; then
		nxlog "$FUNCNAME ($$): Type \"vnc\""
		# nxviewer session (VNC RFB)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup password
		mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/"
		echo "$agent_password" | $PATH_BIN/nxpasswd \
			"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd" doit
		# Start x11vnc
		if [ -n "$shadowdisplay" ]; then
			(
				viewonly=""
				[ "$ENABLE_INTERACTIVE_SESSION_SHADOWING" != "1" ] && \
					viewonly="-viewonly"
				DISPLAY="$shadowhost:$shadowdisplay" x11vnc -localhost \
					$viewonly -timeout 120 -rfbauth \
					"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd" \
					>"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.vnc_port" 2>&3 &
			)
			sleep 2
			agent_port=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.vnc_port")
			agent_port=$(rematchfn '^PORT=[[:space:]]*([[:digit:]]+)' $agent_port) #'
			[ -z "agent_port" ] && agent_port="0"
			# note the :: is not a mistake, but rather a hint for nxviewer
			# to use this as a port and not interpret it as a display.
			agent_server="127.0.0.1::$agent_port"
			rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.vnc_port"
		fi
		# Start the agent
		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw \
			-passwd "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/.passwd" \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $vncfullscreen \
			$G $K $agent_server $AGENT_EXTRA_OPTIONS_RFB 2>&3 &
	elif [ "$R" = "-R" -a "$rootless" != "1" ]; 	then
		# nxproxy single application mode session
		nxlog "$FUNCNAME ($$): Start nxproxy for single application session mode"
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$PROXY_LIBRARY_PATH:$LD_LIBRARY_PATH"
		nxlog "$FUNCNAME ($$): Start nxproxy by command: '$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS'"
		$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS 2>&3 &
	else
		nxlog "$FUNCNAME ($$): NXAgent session type"
		# nxagent session (X11)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup optional parameters
		P=$(node_agent_persistent_session)
		FP=""; [ -n "$AGENT_FONT_SERVER" ] && FP="-fp $AGENT_FONT_SERVER"
		if [ "$type" = "shadow" ]; then
			nxlog "$FUNCNAME ($$): Type \"shadow\". Add some args to nxagent"
			R="-S -shadow $shadowhost:$shadowdisplay -shadowmode $ENABLE_INTERACTIVE_SESSION_SHADOWING"
			P="-nopersistent"
		fi
		# Start the agent
#		nxlog "$FUNCNAME ($$): env start `env`"
#		nxlog "$FUNCNAME ($$): env end"
		nxlog "$FUNCNAME ($$): Start nxagent by command: '$COMMAND_NXAGENT $P $R -name \"NX - $user@$SERVER_NAME:$display - $session (GPL Edition)\" -option \"$USER_FAKE_HOME/.nx/C-$sess_id/options\" $B $FP $AGENT_EXTRA_OPTIONS_X :$display'"
		#PATH="$PATH_BIN:$PATH" $COMMAND_NXAGENT $P $R -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $K $G $B $FP $AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
		PATH="$PATH_BIN:$PATH" $COMMAND_NXAGENT $P $R \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$USER_FAKE_HOME/.nx/C-$sess_id/options" $B $FP \
			$AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
	fi

	# Wait for the agent
	NODE_AGENT_PID=$!
	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
	echo "$NODE_AGENT_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/agent"
	nxlog "$FUNCNAME ($$): Wait for NODE_AGENT_PID ($NODE_AGENT_PID)"
	wait $NODE_AGENT_PID

	NODE_AGENT_EXIT_STATUS=$?
	nxlog "$FUNCNAME ($$): NODE_AGENT_EXIT_STATUS = \"$NODE_AGENT_EXIT_STATUS\""
	NODE_FAILED=""
	if [ $NODE_AGENT_EXIT_STATUS -ne 0 ]; then
		echo "NX> 1004 Error: NX Agent exited with exit status 1. To troubleshoot set SESSION_LOG_CLEAN=0 in node.conf and investigate \"$USER_FAKE_HOME/.nx/F-C-$sess_id/session\". You might also want to try: ssh -X myserver; $PATH_BIN/nxnode --agent to test the basic functionality. Session log follows:"
		cat "$USER_FAKE_HOME/.nx/C-$sess_id/session" 1>&2
		NODE_FAILED="failed"
		nxlog "$FUNCNAME ($$): NODE_FAILED = \"$NODE_FAILED\""
	fi
	nxlog "$FUNCNAME ($$): close session"
	echo "NX> 1006 Session status: closed"

	# Cleanup session information
	nxlog "$FUNCNAME ($$): cleanup session information '$sess_id'"
	nxlog "$FUNCNAME ($$): remove agent pidfile -- '$USER_FAKE_HOME/.nx/C-$sess_id/pids/agent'"
	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/agent"
	nxlog "$FUNCNAME ($$): call 'node_terminate_session \"$sess_id\" \"$NODE_FAILED\"'"
	node_terminate_session "$sess_id" "$NODE_FAILED"

	# remove possible leftovers of nxagent
	nxlog "$FUNCNAME ($$):remove /tmp/.X$display-lock"
	rm -f /tmp/.X$display-lock
	nxlog "$FUNCNAME ($$): remove /tmp/.X11-unix/X$display"
	rm -f /tmp/.X11-unix/X$display

	} 3>&1 1>&4 | tee "$USER_FAKE_HOME/.nx/C-$sess_id/session" | \
		node_start_monitor; } 4>&1
}

try_remount_printers() {
# args: none
# if found another running session with same smb/ipp-printers,
# try to remount from current, else - umount
	sessdir="$USER_FAKE_HOME/.nx/C-$sess_id"
	scr_dir="$sessdir/scripts"
	[ ! -d "$sessdir" ] && { nxlog "$FUNCNAME ($$): Session dir NOT FOUND! Calling twice? Why?"
		return 1; }
	nxlog "$FUNCNAME ($$): starting."
	for spname in $scr_dir/@p@* ; do
		[ "$spname" = "*" ] && { nxlog "$FUNCNAME ($$): No printers, stop."
			return 1;
		}
		PNAME=$(cutfn "$spname" "/" -1); PNAME=${PNAME/@p@/}
		nxlog "$FUNCNAME ($$): process printer \"$PNAME\", search in system cups."
		prstr=$(LC_ALL=C /usr/bin/lpstat -v "$PNAME" 2>/dev/null)
		[ -z "$prstr" ] && { nxlog "$FUNCNAME ($$): printer \"$PNAME\" NOT FOUND in system cups"
			continue;
		}
		[ -n "$(rematchfn '(ipp)://' "$prstr")" ] && type="ipp" || type="smb"
		mport=$(get_mport2sessdir "$sessdir" "$type")
		[ -z "$(rematchfn ':('$mport')/' "$prstr")" ] && { nxlog "$FUNCNAME ($$): printer \"$PNAME\" has mport rather than $mport, skiping."
			continue; }
		# printer already present at own mport
		nxlog "$FUNCNAME ($$): printer \"$PNAME\" (port:$mport) found - deleting"
		/usr/bin/sudo /usr/sbin/lpadmin -x "$PNAME"
		new_dir=$(get_sessdir4res "@p@$PNAME")
		[ -z "$new_dir" ] && { nxlog "$FUNCNAME ($$): no running sessions found for printer \"$PNAME\", stop remounting"
			continue;
		}
		new_port=$(get_mport2sessdir "$new_dir" "$type")
		desc_fn="$USER_FAKE_HOME/.nx/shares_priv/@p@$PNAME"
		[ -r "$desc_fn" ] || { nxlog "$FUNCNAME ($$): description file \"$desc_fn\" for printer \"$PNAME\" NOT ACCESSIBLE, stop remounting"
			continue; }
		descstr=$(cat "$desc_fn" 2>/dev/null)
		DEVICE_URI=$(cutfn "$descstr" "&" 1)
		DEVICE_URI=${DEVICE_URI/:$mport/:$new_port}
		share=$(cutfn "$DEVICE_URI" "/" -1)
		upass=$(cutfn "$(cutfn "$DEVICE_URI" "/" 2)" "@" 0) #"
		username="$(cutfn "$upass" ":" 0)"
		password="$(cutfn "$upass" ":" 1)"
		#[ "$type" = "ipp" ] && {
		#	newpass=$(cat "$new_dir/scripts/@p@$PNAME" 2>/dev/null)
		#	[ ! -z "$newpass" ] && { nxlog "$FUNCNAME ($$): new password for printer \"$PNAME\" ARE LOST, stop remounting"
		#	continue;
		#	}
		#	DEVICE_URI=${DEVICE_URI/:$password/:$newpass}
		#	password="$newpass"
		#}
		[ "$(check_remote_printer $type $share $new_port $username $password)" \
				= "0" ] && { nxlog "$FUNCNAME ($$): smb/cifs-share \"$share\" for printer \"$PNAME\" NOT ACCESSIBLE, stop remounting"
			continue;
		}
		MODEL=$(cutfn "$descstr" "&" 0)
		defaultPrinter=$(cutfn "$descstr" "&" 3)
		if [ -r "$MODEL" ]; then # ppd only
			CMDSTR="/usr/bin/sudo /usr/sbin/lpadmin -p $PNAME -P $MODEL -v $DEVICE_URI -E"
		else # foomatic
			ID="$MODEL"; DRV=$(cutfn "$descstr" "&" 4)
			CMDSTR="/usr/bin/sudo /usr/bin/foomatic-configure -s cups -n $PNAME -p $ID -d $DRV -c $DEVICE_URI -q"
		fi
		nxlog "$FUNCNAME ($$): invoke $CMDSTR"
		$CMDSTR
		if [ $? -eq 0 ]; then
			nxlog "$FUNCNAME ($$): printer \"$PNAME\" installed"
			[ "$type" = "ipp" ] && {
				descstr=${descstr/:$mport/:$new_port}
				echo "$descstr" > "$desc_fn"
			}
			PUBLIC=$(cutfn "$descstr" "&" 2)
			[ -n "$PUBLIC" ] && { /usr/bin/sudo /usr/sbin/lpadmin -p $PNAME $PUBLIC;
				[ $? -ne 0 ] && nxlog "$FUNCNAME ($$): FAILED to set options \"$PUBLIC\" for printer \"$PNAME\""
			}
			[ "$defaultPrinter" = "1" ] && {
				/usr/bin/sudo /usr/sbin/lpadmin -d "$PNAME";
				[ $? -ne 0 ] && nxlog "$FUNCNAME ($$): FAILED to set default printer \"$PNAME\""
			}
		else
			nxlog "$FUNCNAME ($$): FAILED to reinstall printer \"$PNAME\""
		fi
	done
	nxlog "$FUNCNAME ($$): end."
}

# node_cupsd_stop
# Used local vars: $sess_id
node_cupsd_stop() {
# dimbor: if system cupsd is used, we try to remove/remount printers
	if [ "$ENABLE_CUPS_SERVER_MODE" = "1" ]; then
		nxlog "$FUNCNAME ($$): starting with  ENABLE_CUPS_SERVER_MODE = 1, call try_remount_printers()"
		try_remount_printers
		nxlog "$FUNCNAME ($$): end"
		return
	fi

	# original behaviour
	# Cleanup userspace cups daemon
	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] || return
	NODE_CUPSD_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd")
	# Check for a running userspace cupsd, look if its still active
	# and kill it if so
	( [ -n "$NODE_CUPSD_PID" ] && kill -0 $NODE_CUPSD_PID && kill $NODE_CUPSD_PID && sleep 2 && kill -0 $NODE_CUPSD_PID && kill -9 $NODE_CUPSD_PID ) 2>/dev/null
	# delete pid file
	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
	# remove all printers
	echo >"$USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf"
	[ -z "$KDE_PRINTRC" ] || sed "s|^Host=$USER_FAKE_HOME/.nx/C-$sess_id/cups/cups.sock||" -i "$KDE_PRINTRC"
}

# node_cupsd_setup
# Used local vars: $sess_id, $display
node_cupsd_setup() {
	let NODE_CUPSD_PORT=$display+9000 # offset 9000 for userspace cupsd's
	export NODE_CUPSD_PORT
	export NODE_CUPSD_SOCKET="$USER_FAKE_HOME/.nx/C-$sess_id/cups/cups.sock"
	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] && return
	touch "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/certs" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/ppd" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cache"
	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/cups/log" #JJK cups log file home
#JJK: Modifications to cupsd.conf
#JJK:   - Added SystemGroup line in order to add $USER to SystemGroup
#JJK:   - Moved all the log files to log/<log>
#JJK:   - Set AccessLog to: log/access_log (was /dev/null)
#JJK:   - Added listening on $NODE_CUPSD_PORT
#JJK:			 Listen localhost: $NODE_CUPSD_PORT
#JJK:   - Removed following line because directive is specific to Debian
#JJK:       PidFile $USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd
#JJK:   -  Access restrictions borrowed from /etc/cups/cupsd.conf
#JJK:   -  Default policy borrowed from /etc/cups/cupsd.conf but modified
#JJK:        to allow Add, Delete, and Default printer without (password)
#JJK:        authentication
#JJK:   - Note for more detailed logging set: LogLevel debug

CUPSPidFileString="PidFile $USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
if [ "$CUPS_PidFile" == "0" ] ; then
	CUPSPidFileString=""
fi

cat <<EOF > $USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf
SystemGroup sys root $USER
AccessLog log/access_log
ErrorLog log/error_log
PageLog log/page_log
LogLevel $CUPSLogLevel
TempDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp
RequestRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool
ServerRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/
StateDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/
CacheDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/cache

Listen localhost:$NODE_CUPSD_PORT
Listen $NODE_CUPSD_SOCKET
Browsing Off
ServerName localhost
$CUPSPidFileString

#JJK:  Restrict access to the server...
<Location />
Order Deny,Allow
Deny From All
Allow from 127.0.0.1
</Location>

#JJK: Restrict access to the admin pages...
<Location /admin>
  Encryption Required
  Order allow,deny
  Allow localhost
</Location>

#JJK: Restrict access to configuration files...
<Location /admin/conf>
  AuthType Basic
  Require user @SYSTEM
  Order allow,deny
  Allow localhost
</Location>

# Allow everything for anonymous, because we are protected through UNIX socket
#JJK: Since allowing access via $NODE_CUPSD_PORT, need to add protection
<Policy default>
  #JJK: Job-related operations must be done by the owner or an adminstrator...
  <Limit Send-Document Send-URI Hold-Job Release-Job Restart-Job Purge-Jobs Set-Job-Attributes Create-Job-Subscription Renew-Subscription Cancel-Subscription Get-Notifications Reprocess-Job Cancel-Current-Job Suspend-Current-Job Resume-Job CUPS-Move-Job>
	Require user @OWNER @SYSTEM
	Order deny,allow
  </Limit>

  #JJK:All administration operations require an adminstrator to authenticate...
  <Limit Pause-Printer Resume-Printer Set-Printer-Attributes Enable-Printer Disable-Printer Pause-Printer-After-Current-Job Hold-New-Jobs Release-Held-New-Jobs Deactivate-Printer Activate-Printer Restart-Printer Shutdown-Printer Startup-Printer Promote-Job Schedule-Job-After CUPS-Add-Class CUPS-Delete-Class CUPS-Accept-Jobs CUPS-Reject-Jobs>
	AuthType Basic
	Require user @SYSTEM
	Order deny,allow
  </Limit>

  #JJK: Except need to allow these for nxnode to work
  <Limit CUPS-Add-Printer CUPS-Delete-Printer CUPS-Set-Default>
	Order deny,allow
  </Limit>

  # Only the owner or an administrator can cancel or authenticate a job...
  <Limit Cancel-Job CUPS-Authenticate-Job>
	Require user @OWNER @SYSTEM
	Order deny,allow
  </Limit>

  <Limit All>
	AuthType None
	Order deny,allow
  </Limit>
</Policy>
EOF

	touch "$USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/classes.conf"

	#JJK: Also copy over pstoraster.convs
	cp -af "$CUPS_ETC"/mime.* "$CUPS_ETC"/pstoraster.convs "$USER_FAKE_HOME/.nx/C-$sess_id/cups/"

	# start cupsd
#JJK: Note the directive PidFile in the original cupsd.conf intended for
#JJK: recording the pid is a Debianism. Instead, we will use the non-daemon
#JJK: form of cupsd and capture the pid directly
#JJK:	$COMMAND_CUPSD -c "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf" &>/dev/null </dev/null
	$COMMAND_CUPSD -F -c "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf" &>/dev/null </dev/null &
	NODE_CUPSD_PID=$!
	echo $NODE_CUPSD_PID >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"

	# setup KDE
	if [ "$ENABLE_KDE_CUPS" = "1" -a -e "$KDE_PRINTRC" ]; then
		if egrep -q "^Host=" "$KDE_PRINTRC"; then
			[ "$ENABLE_KDE_CUPS_DYNAMIC" = "1" ] && sed -i -e 's|^Host=.*|Host=\$('"$PATH_BIN/nxcups-gethost"')|g' "$KDE_PRINTRC"
			[ "$ENABLE_KDE_CUPS_DYNAMIC" != "1" ] && sed -i -e 's|^Host=.*|Host='"$NODE_CUPSD_SOCKET"'|g' "$KDE_PRINTRC"
		else
			echo "[CUPS]" >> "$KDE_PRINTRC"
			[ "$ENABLE_KDE_CUPS_DYNAMIC" = "1" ] && echo "Host[\$ie]=\$($PATH_BIN/nxcups-gethost)" >> "$KDE_PRINTRC"
			[ "$ENABLE_KDE_CUPS_DYNAMIC" != "1" ] && echo "Host=$NODE_CUPSD_SOCKET" >> "$KDE_PRINTRC"
		fi
	fi
}

# node_cupsd_reload
# Used local vars: $sess_id
node_cupsd_reload() {
	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] || return
	NODE_CUPSD_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd")
	[ -n "$NODE_CUPSD_PID" ] && \
		kill -0 $NODE_CUPSD_PID && kill -HUP $NODE_CUPSD_PID
}

node_cupsd_get_socket() {
	# dimbor: for use system cupsd
	[ "$ENABLE_CUPS_SERVER_MODE" = "1" ] && { \
		echo "$CUPS_DEFAULT_SOCK"; return;
	}
	node_cupsd_setup
	echo $NODE_CUPSD_SOCKET
}

create_mountpoint() {
# creates directory and checks its attrs
#params: dir owner group
	[ ! -e "$1" ] && {
		errstr=$(mkdir -p "$1" 2>&1)
		[ $? -ne 0 ] && {
			echo "Unable to create \"$1\". Error: \"$errstr\""; return 1
		} || echo "\"$1\" successfully created."
	} || echo "\"$1\" already exist."
	DUSER=$(stat -c %U "$1"); DGROUP=$(stat -c %G "$1")
	[ "$DUSER" != "$2" -o "$DGROUP" != "$3" ] && {
		logstr="\"$1\" ($DUSER:$DGROUP). Attempt to change owners to $2:$3 - "
		errstr=$(chown "$2:$3" "$1" 2>&1)
		[	 $? -ne 0 ] && {
			echo "$logstr - FAILED! Error: \"$errstr\""; return 1
		} || echo "$logstr - successfully completed."
	}
	DACR=$(stat -c %a "$1")
	[ "$DACR" != "770" ] && {
		logstr="\"$1\" ($DACR). Attempt to change access rights to 0770 - "
		errstr=$(chmod 0770 "$1" 2>&1)
		[ $? -ne 0 ] && {
			echo "$logstr - FAILED! Error: \"$errstr\""; return 1
		} || echo "$logstr - successfully completed."
	}
	return 0
}

usermount_enable() {
# check if available starting mode of mount/umount.cifs
	ret=1; logstr0="$FUNCNAME ($$):"
	ostr=$(stat -c %a "$COMMAND_SMBMOUNT" 2>&1); RC=$?
	[ $RC -ne 0 ] && { nxlog "$logstr0 $ostr"
		ret="0"; }
	[ "$ret" != "0" ] && [ "$ostr" != "4711" -a "$ostr" != "4755" ] && { ret="0"
		nxlog "$logstr0 Permissions of  $COMMAND_SMBMOUNT ($ostr) != 4711 or 4755. Mounting in user-mode is disabled."
	}
	[ "$ret" != "0" -a $RC -eq 0 ] && {
		ostr=$($COMMAND_SMBMOUNT 2>&1)
		stringinstring "setuid root program disabled" "$ostr" && { \
			nxlog "$logstr0 $ostr"
			ret="0";
		}
	}
	ostr=$(stat -c %a "$COMMAND_SMBUMOUNT" 2>&1); RC2=$?
	[ $RC2 -ne 0 ] && { nxlog "$logstr0 $ostr"
		ret="0"; RC=$RC2; }
	[ "$ret" != "0" ] && [ "$ostr" != "4711" -a "$ostr" != "4755" ] && { ret="0"
		nxlog "$logstr0 Permissions of  $COMMAND_SMBUMOUNT ($ostr) != 4711 or 4755. Umounting in user-mode is disabled."
	}
	echo $ret; return $RC
}

sudomount_enable() {
# checks available starting mode with sudo of mount/umount.cifs
	ret=1; logstr0="$FUNCNAME ($$):"
	ostr=$(/usr/bin/sudo -l 2>&1); RC=$?
	if [ $RC -ne 0 ]; then
		nxlog "$logstr0 $ostr"; ret=0
	else
		[ -z "$(rematchfn "NOPASSWD.+($COMMAND_SMBMOUNT)" "$ostr")" ] && { #"
			ret=0
			nxlog "$logstr0 Mounting with sudo is disabled. To enable, you must to change etc/sudo.d/nxserver or etc/sudoers file."
		}
		[ -z "$(rematchfn "NOPASSWD.+($COMMAND_SMBUMOUNT)" "$ostr")" ] && { #"
			ret=0
			nxlog "$logstr0 Umounting with sudo is disabled. To enable, you must to change etc/sudo.d/nxserver or etc/sudoers file."
		}
	fi
	echo $ret; return $RC
}

try_mount_smb() {
# params: sharename(1), mountpoint(2), smb-username(3), port(4),
# ex-options/uid,gid/(5), smb-password(6)
	RC=1; nxlog "$FUNCNAME ($$): Starting: TRY_USER=$TRY_USER, TRY_SUDO=$TRY_SUDO"
	[ -n "$SMB_MOUNT_OPTIONS" -a "${SMB_MOUNT_OPTIONS:0:1}" != "," ] && \
		SMB_MOUNT_OPTIONS=",$SMB_MOUNT_OPTIONS"
	SMB_OPTS="username=$3,"
	[ -n "$6" ] && SMB_OPTS="$SMB_OPTS""password=$6," || \
		SMB_OPTS="$SMB_OPTS""password=,"
	SMB_OPTS="$SMB_OPTS""ip=127.0.0.1,port=$4$SMB_MOUNT_OPTIONS"
	[ $TRY_USER -ne 0 ] && {
		MNTSTR="$COMMAND_SMBMOUNT $1 $2 -o $SMB_OPTS"
		nxlog "$FUNCNAME ($$): invoke $MNTSTR 2>&1"
		error=$($MNTSTR 2>&1); RC=$?
		[ $RC -ne 0 ] && nxlog "$FUNCNAME ($$): Mount error: \"$error\""
	}
	[ $TRY_SUDO -ne 0 -a $RC -ne 0 ] && {
		MNTSTR="/usr/bin/sudo $COMMAND_SMBMOUNT $1 $2 -o $5$SMB_OPTS"
		nxlog "$FUNCNAME ($$): invoke $MNTSTR 2>&1"
		error=$($MNTSTR 2>&1); RC=$?
		[ $RC -ne 0 ] && nxlog "$FUNCNAME ($$): Mount error: \"$error\""
	}
	[ $RC -eq 0 ] && nxlog "$FUNCNAME ($$): Finished successfully."
	return $RC
}

try_umount_smb() {
# param: mountpoint
	amnt=3; cn=0; logstr0="$FUNCNAME ($$):"; RC=0
	nxlog "$logstr0 Starting arg \"$1\". TRY_USER=$TRY_USER, TRY_SUDO=$TRY_SUDO, remain $amnt attempts."
	for (( i=$amnt; $i; --i )); do
		if stringinstring "$1" "$(mount)"; then
			[ $i -lt $((amnt/2)) ] && { FFL="-f"; logstr1="$logstr0 force (-f)";
			} || { FFL=""; logstr1="$logstr0"; }
			RC=1; (( cn++ ))
			[ $TRY_USER -ne 0 ] && {
				logstr2="$logstr1"" umount attempt #$cn \"$1\" in user-mode"
				ostr=$($COMMAND_SMBUMOUNT $FFL "$1" 2>&1); RC=$?
				[ $RC -eq 0 ] && { nxlog "$logstr2 completed succesfully."
					break;} || nxlog "$logstr2 FAILED. Error: \"$ostr\""
			}
			[ $TRY_SUDO -ne 0 -a $RC -ne 0 ] && {
				logstr2="$logstr1"" umount attempt #$cn \"$1\" with sudo"
				ostr=$(/usr/bin/sudo $COMMAND_SMBUMOUNT $FFL "$1" 2>&1); RC=$?
				[ $RC -eq 0 ] && { nxlog "$logstr2 completed succesfully."
					break; } || nxlog "$logstr2 FAILED. Error: \"$ostr\""
			}
		else
			nxlog "$logstr0 Mountpoint \"$1\" not mounted"
			return 0;
		fi
		sleep 2s
	done
	[ $RC -eq 0 ] && nxlog "$FUNCNAME ($$): Finished successfully."
	return $RC
}

node_umount_smb() {
	nxlog "$FUNCNAME ($$): starting with ENABLE_SHARE_MULTIMOUNT == $ENABLE_SHARE_MULTIMOUNT"
	smbport=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport" 2>/dev/null)
	TRY_USER=1; TRY_SUDO=0;
	[ "$smbport" = "445" ] && {
		COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS; COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
		TRY_USER=$(usermount_enable)
		TRY_SUDO=$(sudomount_enable)
		[ $TRY_USER -eq 0 -a $TRY_SUDO -eq 0 ] && {
			nxlog "$FUNCNAME ($$): Any methods of (u)mounting are not available. Stop umounting."
			return 1;
		}
	}
	#dimbor: if sessions with same shares found, we try to remount them
	if [ "$ENABLE_SHARE_MULTIMOUNT" = "1" ]; then
		scr_dir="$USER_FAKE_HOME/.nx/C-$sess_id/scripts"
		mport=$(cat "$scr_dir/mport" 2>/dev/null)
		mpoints=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint" 2>/dev/null)
		[ -z "$mpoints" ] && {
			nxlog "$FUNCNAME ($$): No shares controlled by session found. Stop remounting."
			return;
		}
		for ssname in $scr_dir/@s@*; do
			SNAME=$(cutfn "$ssname" "/" -1); SNAME=${SNAME/@s@/}
			desc_fn="$USER_FAKE_HOME/.nx/shares_priv/@s@$SNAME"
			[ ! -r "$desc_fn" ] && {
				nxlog "$FUNCNAME ($$): description file \"$desc_fn\" for share \"$SNAME\" NOT ACCESSIBLE, stop remounting it"
				continue;
			}
			descstr=$(cat "$desc_fn"); mpoint=$(cutfn "$descstr" "&" 1)
			stringinstring "$mpoint" "$mpoints" || {
				nxlog "$FUNCNAME ($$): share \"$SNAME\" at \"$mpoint\" is not controlled by session. Stop remounting."
				continue;
			}
			try_umount_smb "$mpoint"; RC=$? # umount here
			[ $RC -ne 0 ] && {
				nxlog "$FUNCNAME ($$): mountpoint \"$mpoint\" failed to unmount."
				continue;
			}
			new_dir=$(get_sessdir4res "@s@$SNAME")
			[ -z "$new_dir" ] && {
				nxlog "$FUNCNAME ($$): no running sessions found for share \"$SNAME\", stop remounting"
				rmdir "$mpoint" >/dev/null 2>/dev/null; continue;
			}
			new_port=$(cat "$new_dir/scripts/mport" 2>/dev/null)
			fsname=$(cutfn "$descstr" "&" 0)
			username=$(cutfn "$descstr" "&" 2)
			password=$(cutfn "$descstr" "&" 3)
			IDS_OPTS=$(cutfn "$descstr" "&" 4)
			try_mount_smb "$fsname" "$mpoint" "$username" $new_port "$IDS_OPTS" "$password"
			RC=$?
			[ $RC -eq 0 ] && {
				nxlog "$FUNCNAME ($$): share \"$fsname\" remount to \"$mpoint\""
				echo "$mpoint" >> "$new_dir/scripts/mpoint"
			} || {
				nxlog "$FUNCNAME ($$): share \"$fsname\" failed to remount: $error"
				rmdir "$mpoint" >/dev/null 2>/dev/null
			}
		done
		nxlog "$FUNCNAME ($$): end"
		return
	fi

	if [ -e "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint" ]; then
		nxlog "$FUNCNAME ($$): File scripts/mpoint present. Continue umounting..."
	else
		nxlog "$FUNCNAME ($$): File scripts/mpoint not present. Abort umounting..."
		return 1
	fi
	cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint" | while read mpoint
	do
		try_umount_smb "$mpoint"; RC=$? # umount here
		[ $RC -ne 0 ] && {
			nxlog "$FUNCNAME ($$): mountpoint \"$mpoint\" failed to unmount."
			continue;
		}
		nxlog "$FUNCNAME ($$): Remove mountpoint \"$mpoint\""
		rmdir "$mpoint" >/dev/null 2>/dev/null #JJK:Remove mount point if empty
	done
	nxlog "$FUNCNAME ($$): end"
}

node_stop_services() {
	nxlog "$FUNCNAME ($$): starting"
	nxlog "$FUNCNAME ($$): call node_umount_smb"
	node_umount_smb
	nxlog "$FUNCNAME ($$): call node_cupsd_stop"
	node_cupsd_stop
	nxlog "$FUNCNAME ($$): call reconnect_pa"
	reconnect_pa
	nxlog "$FUNCNAME ($$): end"
}

node_emergency_exit() {
	nxlog "$FUNCNAME ($$): starting"
	# umount shares & stop printers
	nxlog "$FUNCNAME ($$): call node_stop_services"
	node_stop_services

	# kill the session
	nxlog "$FUNCNAME ($$): call 'node_terminate_session \"$sess_id\" \"failed\"'"
	node_terminate_session "$sess_id" "failed"

	echo "NX> 1004 Error: Emergency exit due to kill signal."
	nxlog "$FUNCNAME ($$): end"
}

# node_start_monitor <start|restore> <Running|Suspended>
# Monitoring the nxagent: Its also kind of a "state-machine"
#                         as it has to keep track of different
#                         connection states and react differently.
node_start_monitor() {
	nxlog "$FUNCNAME ($$): starting"
	NODE_TAIL_PID=""
	NODE_SUSPEND_STATUS="$2"

	while read line; do
		# Catch tail pid
		if stringinstring "Info: tail -f running with pid" "$line"; then
			NODE_TAIL_PID=$(cutfn "$line" "'" 1)
			echo "$NODE_TAIL_PID" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail"
		elif stringinstring "Info: Listening * SMB connections on port" "$line"; then
			# Catch NXAGENT SMB Port (sometimes the port differs from what we got from nxserver)
			SMBMOUNT_PORT=$(cutfn "$line" "'" 1)
			SMBMOUNT_PORT=${SMBMOUNT_PORT##*:}
			echo "$SMBMOUNT_PORT" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mport"
		elif stringinstring "Info: Listening * multimedia connections on port" "$line"; then
			# Catch NXAGENT Multimedia Port
			MEDIA_PORT=$(cutfn "$line" "'" 1)
			MEDIA_PORT=${MEDIA_PORT##*:}
			echo "$MEDIA_PORT" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mmport"
		elif stringinstring "Session: Starting session at" "$line"; then
		# Session messages
			echo "NX> 1009 Session status: starting"
		elif stringinstring "Session: Suspending session at" "$line"; then
			echo "NX> 1009 Session status: suspending"
		elif stringinstring "Session: Terminating session at" "$line"; then
			echo "NX> 1009 Session status: terminating"
		elif stringinstring "Session: Resuming session at" "$line"; then
			echo "NX> 1009 Session status: resuming"
		elif stringinstring "Session: Session suspended at" "$line"; then
			# Session suspend
			echo "NX> 1005 Session status: suspended"
			# umount shares & stop printers
			if [ "$NODE_SUSPEND_STATUS" = "Running" ]; then
				nxlog "$FUNCNAME ($$): call 'node_suspend_session \"$sess_id\"'"
				node_suspend_session "$sess_id"
				NODE_SUSPEND_STATUS=""
			else
				nxlog "$FUNCNAME ($$): call node_stop_services"
				node_stop_services
			fi
		elif stringinstring "Info: Watchdog running with pid" "$line"; then
			# Watchdog termination
			NODE_WATCHDOG_PID=$(cutfn "$line" "'" 1)
		elif stringinstring "Info: Waiting the watchdog process to complete." "$line"; then
			# Kill the watchdog
			kill $NODE_WATCHDOG_PID 2>/dev/null
		elif stringinstring "Info: Waiting for connection from" "$line"; then
			# Session is running
			# dimbor: with nx-libs 3.5.99 node_monitor catch of startsession
			# restore too fast
			sleep 0.5s
			echo "NX> 710 Session status: running"
			echo "NX> 1002 Commit"
			echo "NX> 1006 Session status: running"
		elif stringinstring "Session: Session resumed at" "$line"; then
			# Reconnection success!
			echo "NX> 718 Session restore succeded"
			if [ "$1" = "restore" ]; then
				kill $NODE_TAIL_PID
				break
			fi
		elif stringinstring "Session: Display failure detected at" "$line"; then
			# Reconnection failure
			if [ "$1" = "restore" ]; then
				echo "NX> 596 Error: Session $1 failed. Reason was: $line"
				kill $NODE_TAIL_PID
				break
			fi
		fi
	done

	trap "" EXIT

	[ "$1" != "restore" -a "$rootless" != "1" ] && {
		nxlog "$FUNCNAME ($$): call node_stop_services at ending"
		node_stop_services;
	}
	# close all open file descriptors
	exec 0<&-
	exec 1>&-
	exec 2>&-
	nxlog "$FUNCNAME ($$): end"
	exit 0
}

#
# -----------------------------------------------------------------------------
# startsession - Start a new session.
# -----------------------------------------------------------------------------
#
startsession() {
# user=knoppix&userip=192.168.1.66&uniqueid=6A8269CC467264EAEF6349D062689755&display=1000&session=lappi%5ffull&type=unix%2dkde&cache=8M&images=32M&cookie=84765070afee043cf83f85d21130145f&link=lan&render=1&backingstore=when_requested&imagecompressionmethod=0&geometry=fullscreen&keyboard=fr&media=0&samba=1&agent_server=&agent_user=&agent_password=
	user=$(getparam user)
	userip=$(getparam userip)
	uniqueid=$(getparam uniqueid)
	display=$(getparam display)
	session=$(getparam session)
	type=$(getparam type)
	application=$(getparam application)
	windows_app=$(getparam application)
	cache=$(getparam cache)
	images=$(getparam images)
	cookie=$(getparam cookie)
	link=$(getparam link)
	virtualdesktop=$(getparam virtualdesktop)
	render=$(getparam render)
	backingstore=$(getparam backingstore)
	imagecompressionmethod=$(getparam imagecompressionmethod)
	imagecompressionlevel=$(getparam imagecompressionlevel)
	geometry=$(getparam geometry)
	keyboard=$(getparam keyboard)
	kbtype=$(getparam kbtype)
	media=$(getparam media)
	mediahelper=$(getparam mediahelper)
	sync=$(getparam sync)
	samba=$(getparam samba)
	cups=$(getparam cups)
	agent_server=$(getparam agent_server)
	agent_user=$(getparam agent_user)
	agent_password=$(getparam agent_password)
	agent_domain=$(getparam agent_domain)
	screeninfo=$(getparam screeninfo)
	nodelay=$(getparam nodelay)
	sess_id="$SERVER_NAME-$display-$uniqueid"
	NXSESSION_DIRECTORY="$USER_FAKE_HOME/.nx/C-$sess_id"

	nxlog "$FUNCNAME ($$): starting with args \"$@\""
	[ "$PROXY_TCP_NODELAY" = "0" ] && nodelay=0

	# 1.5.0 options
	rdpcolors=$(getparam rdpcolors)
	rdpcache=$(getparam rdpcache)
	http=$(getparam http)

	# dimbor: additional extra-channels, patched nxcomp both
	# on server and client are required
	extra1=$(getparam extra1)
	extra2=$(getparam extra2)
	extra3=$(getparam extra3)

	# nxclient > 1.5.0-106 variables
	resize=$(getparam resize)
	keybd=$(getparam keybd)

	# backwards compatibility for keybd parameter
	[ -z "$keybd" ] && keybd=$(getparam aux)
	aux=$(getparam aux)
	kbload=$(getparam kbload)
	keymap=$(getparam keymap)

	rootless=0
	# Its still the clients decision
	[ "$ENABLE_ROOTLESS_MODE" = "1" ] &&  rootless=$(getparam rootless)

	# Rootless fix from 2x nxserver 1.5.0
	realtype=$type
	[ "$type" = "unix-application" -o "$type" = "unix-default" ] && realtype="unix-desktop"
	[ "$type" = "unix-gnome" ] && realtype="gnome"
	[ "$type" = "unix-kde" ] && realtype="kde"

	# NX 2.1.0 file-sharing port options
	client=$(getparam client)
	smbport=""
	if [ "$samba" = "1" ]; then
		# We know from protocol traces that client=linux,winnt,macosx are valid values.
		# I hope with smbclientproto=smb on default and smbclientproto=cifs on all valid
		# values we get support for all those systems.
		smbproto="$SAMBA_MOUNT_SHARE_PROTOCOL"
		if [ "$smbproto" = "both" ]; then
			smbproto="smbfs"
			[ "$client" = "linux" ] && smbproto="cifs"
			[ "$client" = "winnt" ] && smbproto="cifs"
			[ "$client" = "macosx" ] && smbproto="cifs"
			# FIXME: This is a rather wild guess
			[ "$client" = "win9x" ] && smbproto="smbfs"
		fi
		if [ "$smbproto" = "cifs" ]; then
			smbport=445
			COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS
			COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
		elif [ "$smbproto" = "none" ]; then
			# we set this to true so that the
			# SMB mount does not give an error message.
			COMMAND_SMBMOUNT=/bin/true; COMMAND_SMBUMOUNT=/bin/true
			smbport=139    #JJK: still may want to do printer sharing...
		else # smbfs
			smbport=139
		fi
	fi

	# FreeNX specific variables
	clientproto=$(getparam clientproto)
	status=$(getparam status)
	host=$(getparam host)

	# New NX 3.0 shadow mode related variables
	shadowusername=$(getparam shadowusername)
	shadowcookie=$(getparam shadowcookie)
	shadowdisplay=$(getparam shadowdisplay)
	shadowhost=$(getparam shadowhost)

	# Authentication method needed by guest mode.
	login_method=$(getparam login_method)

	# export the agent_* options for the helper scripts
	if [ "$(getparam freenx_export_agents)" = "1" ]; then
		export agent_user
		export agent_password
		export agent_server
		export agent_domain
		export windows_app
		agent_keyboard=""
		[ "$ENABLE_EXTERNAL_NXDESKTOP_KEYBOARD" = "1" ] && \
			agent_keyboard=$(cutfn "$keyboard" '/' 1)
		export agent_keyboard
		export NXSESSION_DIRECTORY
		export AGENT_EXTRA_OPTIONS_RFB
		export AGENT_EXTRA_OPTIONS_RDP
		export COMMAND_RDESKTOP
		export COMMAND_VNCVIEWER
		export COMMAND_VNCPASSWD
		export COMMAND_X11VNC
		export PATH_BIN
		export shadowdisplay
		export shadowhost
		export shadowuser
		export shadowcookie
		export ENABLE_SESSION_SHADOWING_AUTHORIZATION
		export ENABLE_INTERACTIVE_SESSION_SHADOWING
		# We do not want to suspend such a session
		# as RDP/RFB are both suspendable as well
		ENABLE_PERSISTENT_SESSION=""
	fi

	fullscreen=$(getparam fullscreen)
	[ "$geometry" = "fullscreen" ] && fullscreen="1"
	[ "$EXPORT_USERIP" = "1" ] && export NXUSERIP="$userip"
	ssl_tunnel=$(getparam encryption)
	[ -z "$ssl_tunnel" ] && ssl_tunnel=0
	if [ "$ssl_tunnel" = "1" ]; then
		# we need to use the IP of the "calling" server now
		# FIXME: cut and sed rm
		#userip=$(echo $SSH_CLIENT $SSH2_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
		#nxlog "$FUNCNAME ($$): ${userip@A}"
		userip=""
		# If host is the same, use 127.0.0.1, else fallback to default
		[ -z "$userip" -a "$host" = "127.0.0.1" ] && userip="127.0.0.1"
		[ -z "$userip" ] && userip="*"
	fi
	# We need our own external IP
	proxyip="$EXTERNAL_PROXY_IP"
	if [ -z "$proxyip" -a -n "$host" ]; then
		[ "$host" = "127.0.0.1" ] && host=$(hostname)
		# FIXME: on modern systems ping resolves lo addr also
		proxyip=$(rematchfn "PING .+\(($ip4_pattern)\)" "$(ping -c1 "$host")") #"
	fi
	[ -z "$proxyip" ] && proxyip="127.0.0.1"

	# ok, lets make the session dir first:
	sess_id="$SERVER_NAME-$display-$uniqueid"
	[ "$EXPORT_SESSIONID" = "1" ] && export NXSESSIONID="$sess_id"
	OLD_UMASK=$(umask); umask 0022; mkdir -p $USER_FAKE_HOME
	umask 0077; mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id"; umask $OLD_UMASK

	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
	PACK=""
	[ -z "$imagecompressionlevel" ] && imagecompressionlevel="9"
	[ "$imagecompressionmethod" = "0" ] && PACK="pack=nopack,"
	[ "$imagecompressionmethod" = "1" ] && PACK="pack=16m-jpeg-$imagecompressionlevel,"
	[ "$imagecompressionmethod" = "2" ] && PACK="pack=16m-png-9,"

	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
	proxy_cookie=${proxy_cookie%% *}
	# all newer clients support fake cookie authentication
	if [ "$clientproto" != "1.4.0" ]; then
		# enable fake cookie authentication
		cookie=$proxy_cookie
	fi

	# write options file
	[ -z "$samba" ] && samba=0
	[ -z "$media" ] && media=0
	[ -z "$nodelay" ] && nodelay=1
	clipboard="$ENABLE_CLIPBOARD"
	menu="$ENABLE_PULLDOWN_MENU"
	CACHE="cache=$cache,"
	[ -z "$cache" ] && CACHE=""
	IMAGES="images=$images,"
	[ -z "$images" ] && IMAGES=""
	ACCEPT="accept=$userip,"
	[ "$userip" = "*" ] && ACCEPT=""

	if [ "$1" = "application" ]; then
		# This needs to be set, else nxagent is terminated
		rootless="1"; virtualdesktop="0"
		nxlog "$FUNCNAME ($$): call 'node_start_applications'"
		node_start_applications &
		echo "NX> 596 Application $application started successfully."
		return
	fi

	OLD_UMASK=$(umask); umask 0077
	nxlog "$FUNCNAME ($$): generate \"$USER_FAKE_HOME/.nx/C-$sess_id/options\""
	cat << EOF > "$USER_FAKE_HOME/.nx/C-$sess_id/options"
nx/nx,${keyboard:+keyboard=$keyboard,}${kbtype:+kbtype=$kbtype,}${kbload:+kbload=$kbload,}${keymap:+keymap=$keymap,}${geometry:+geometry=$geometry,}${client:+client=$client,}${resize:+resize=$resize,}${CACHE}${IMAGES}${PACK}link=$link,nodelay=$nodelay,type=$realtype${clipboard:+,clipboard=$clipboard}${composite:+composite=$composite},cleanup=10,product=LFE/None/LFEN/None,shmem=1,${backingstore:+backingstore=$backingstore,}shpix=1,${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media${sync:+,sync=$sync}${cups:+,cups=$cups}${keybd:+,keybd=$keybd}${aux:+,aux=$aux}${http:+,http=$http}${extra1:+,extra1=$extra1}${extra2:+,extra2=$extra2}${extra3:+,extra3=$extra3}${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}${fullscreen:+,fullscreen=1}${menu:+,menu=$menu}:$display
EOF
	umask $OLD_UMASK

	#samba=$samba,
	#cache=$cache,images=$images,pack=nopack,link=$link,type=$type,cleanup=0,accept=$userip,cookie=$proxy_cookie,id=$sess_id
	#samba=$samba,media=$media,render=$render:$display

	# write xauth script file
	nxlog "$FUNCNAME ($$): write xauth script file"
	$COMMAND_XAUTH >/dev/null 2>&1 <<EOF
add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
add :$display MIT-MAGIC-COOKIE-1 $cookie
exit
EOF

	$COMMAND_XAUTH -f "$USER_FAKE_HOME/.nx/C-$sess_id/authority" >/dev/null 2>&1 <<EOF
add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
add :$display MIT-MAGIC-COOKIE-1 $cookie
exit
EOF

	mkdir -m700 "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/" 2>/dev/null || chmod 700 "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/"

cat << EOF >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/authority"
remove localhost:$display
remove :$display
exit
EOF

	export SHADOW_XAUTHORITY="$USER_FAKE_HOME/.nx/C-$sess_id/authority"

	# If we have a shadow cookie, we add it to xauth session authority file as well
	if [ -n "$shadowcookie" ]; then
		nxlog "$FUNCNAME ($$): If we have a shadow cookie, we add it to xauth session authority file as well"
		$COMMAND_XAUTH -f "$SHADOW_XAUTHORITY" add "$shadowhost:$shadowdisplay" MIT-MAGIC-COOKIE-1 "$shadowcookie"
	elif [ -n "$shadowdisplay" ]; then
		# we need to merge in the normal .Xauthority file
		nxlog "$FUNCNAME ($$): we need to merge in the normal .Xauthority file"
		$COMMAND_XAUTH -f "$SHADOW_XAUTHORITY" merge "$HOME/.Xauthority"
	fi

	if [ "$1" = "restore" ]; then
		nxlog "$FUNCNAME ($$): restore session"
		echo > "$USER_FAKE_HOME/.nx/C-$sess_id/session"
		sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '"$USER_FAKE_HOME"'/.nx/C-'"$sess_id"'/session' | node_start_monitor "$1" "$status" &
		MONITOR_PID=$!
		export MONITOR_PID
		mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
		echo "$MONITOR_PID" > "$USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor"
		nxlog "$FUNCNAME ($$): call 'node_suspend_session \"$sess_id\"'"
		node_suspend_session "$sess_id" || { echo "Info: Reconnection failed: NX Agent process could not be found." >>"$USER_FAKE_HOME/.nx/C-$sess_id/session"; node_fail_restore_session "$sess_id"; }
	else
		nxlog "$FUNCNAME ($$): call 'node_start_agent'"
		node_start_agent &
		for (( i=60; $i; --i )); do
			sleep 0.1s
			if [ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/agent" ]; then
				nxlog "$FUNCNAME ($$): wait for nxagent pid - $((60-i+1)) decs"
				break
			fi
		done
		nxlog "$FUNCNAME ($$): call 'node_start_applications'"
		node_start_applications &
	fi

	if which "$NODE_AUTOSTART" >/dev/null 2>&1; then
		# go into background immediately
		NXSESSIONID="$sess_id" DISPLAY=:$display "$NODE_AUTOSTART" "$1" >/dev/null 2>&1 &
		# dont't wait for this child!
		disown $!
	fi

	cat << EOF
NX> 700 Session id: $sess_id
NX> 705 Session display: $display
NX> 703 Session type: $type
NX> 701 Proxy cookie: $proxy_cookie
NX> 702 Proxy IP: $proxyip
NX> 706 Agent cookie: $cookie
NX> 704 Session cache: $type
NX> 707 SSL tunneling: $ssl_tunnel
EOF

	# File-sharing port options
	if [ "$samba" = "1" -a -n "$smbport" ]; then
		echo "NX> 709 File-sharing port: $smbport"
		echo "$smbport" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport"
	fi

	# collection ...
	# NX> 1004 Error:
	#Session 'Knoppix-1000-40EFB9F64FA55C64C41C72CA39EBD720' has failed after reaching usable state. Session directory '/home/knoppix/.nx/F-C-Knoppix-1000-40EFB9F64FA55C64C41C72CA39EBD720' will be not deleted to allow for further investigation.

	if [ -n "$MONITOR_PID" ]; then
		wait "$MONITOR_PID"
		rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/monitor"
		rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail"
	fi
	wait # for all children
	nxlog "$FUNCNAME ($$): end"
}

#
# -----------------------------------------------------------------------------
# cmd_node functions - changes lots of small variables
# -----------------------------------------------------------------------------
#
cmd_node_terminate() {
	sessionid=$(getparam_sessionid)
	echo "$DELIM 716 Terminating session $sessionid on user request."
	sdir=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid)
	display=$(cutfn "$sdir" "-" -2)
	sess_id="$SERVER_NAME-$display-$sessionid"
	node_terminate_session "$sess_id"
}

cmd_node_suspend() {
	sessionid=$(getparam_sessionid)
	echo "$DELIM 716 Suspending session $sessionid on user request."
	sdir=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid)
	display=$(cutfn "$sdir" "-" -2)
	sess_id="$SERVER_NAME-$display-$sessionid"
	node_suspend_session "$sess_id"
}

cmd_node_smbmount() {
	sessionid=$(getparam_sessionid)
	sdir=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid)
	display=$(cutfn "$sdir" "-" -2)
	sess_id="$SERVER_NAME-$display-$sessionid" # dimbor: for called functions
	sess_dir="$USER_FAKE_HOME/.nx/C-$sess_id"
	nxlog "$FUNCNAME ($$): starting with sessionid = $sessionid"
	port=$(getparam port)
	username=$(getparam username)
	password=$(getparam password)
	share=$(getparam share)
	computername=127.0.0.1 # http://bugs.etersoft.ru/show_bug.cgi?id=8841
	dir=$(getparam dir); dir=${dir/'$(SHARES)'/MyShares}
	username=$(norm_param $username)
	password=$(norm_param $password)
	share=$(norm_param $share)
	dir=$(norm_param $dir)
	[ -n "$(rematchfn "(MyShares)" "$dir")" ] && dir="$HOME/$dir" #"
	# dimbor: checking mountpoint
	EGROUP=$(id -gn "$USER"); RC=$?
	outstr="$(create_mountpoint "$dir" "$USER" "$EGROUP")"
	[ -n "$outstr" ] && nxlog "$FUNCNAME ($$): create_mountpoint says: \"$outstr\""
	[ $RC -ne 0 ] && { nxlog "$FUNCNAME ($$): Stop mounting."; return 1; }
	smbport=""; smbport=$(cat "$sess_dir/scripts/smbport" 2>/dev/null)
	IDS_OPTS="uid=$USER,gid=$EGROUP,"; TRY_USER=1; TRY_SUDO=0;
	# this function run dedicated. We must define smbproto and COMMAND_SMBMOUNT here, not in startsession.
	if [ "$smbport" = "445" ]; then
		COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS; COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
		TRY_USER=$(usermount_enable); TRY_SUDO=$(sudomount_enable)
		[ $TRY_USER -eq 0 -a $TRY_SUDO -eq 0 ] && {
			nxlog "$FUNCNAME ($$): Any methods of (u)mounting are not available. Stop mounting."
			return 1;
		}
	elif [ "x$smbport" = "x" ]; then COMMAND_SMBMOUNT=/bin/true
	else smbport=139 # smbfs
	fi

	#do not mount twice
	local mnts=$(rematchfn "(.+)[[:space:]].+$dir" "$(mount)") #"
	if [ -n "$mnts" ]; then
			nxlog "$FUNCNAME ($$): share $mnts already mounted on $dir"
		if [ "$ENABLE_SHARE_MULTIMOUNT" = "1" ]; then
			if [ -z "$(get_sessdir4res "@s@$share")" ]; then
				nxlog "$FUNCNAME ($$): Try to force umount dead mountpoint \"$dir\""
				try_umount_smb "$dir"; RC=$?
				[ $RC -ne 0 ] && {
					nxlog "$FUNCNAME ($$): Umounting FAILED! Stop mounting."
					return 1;
				}
			else
				touch "$sess_dir/scripts/@s@$share"; return;
			fi
		else
			echo "$dir" >> "$sess_dir/scripts/mpoint"
			return
		fi
	fi
	# wait up to 30 sec until nxagent has opened the listener port
	# for samba connections
	for (( i=30; $i; --i )); do
		[ -f "$sess_dir/scripts/mport" ] && break
		sleep 1
	done
	# sometimes the samba port we get from nxserver is not the right one,
	# so let's get it from nxagent
	realport=$(cat "$sess_dir/scripts/mport")
	[ -n "$realport" ] && port=$realport
	try_mount_smb "//$computername/$share" "$dir" "$username" $port "$IDS_OPTS" "$password"
	RC=$?
	if [ $RC -eq 0 ]; then
		if [ "$ENABLE_SHARE_MULTIMOUNT" = "1" ]; then
			nxlog "$FUNCNAME ($$): share \"//$computername/$share\" mount on \"$dir\""
			SFN="@s@$share"
			touch "$sess_dir/scripts/$SFN"
			desc_dir="$USER_FAKE_HOME/.nx/shares_priv" # directory with connection parameters to use sessions together
			[ -d "$desc_dir" ] || {
				mkdir "$desc_dir" && chmod 700 "$desc_dir";
			}
			[ ! -e "$desc_dir/$SFN" ] && touch "$desc_dir/$SFN" && \
				chmod 600 "$desc_dir/$SFN" # create "top-secret" description file
			echo "//$computername/$share&$dir&$username&$password&$IDS_OPTS" > "$desc_dir/$SFN"
		else # not multimount case
			nxlog "$FUNCNAME ($$): share \"//$computername/$share\" mount on \"$dir\""
			$PATH_BIN/nxdialog -dialog ok -caption "NXServer Message" \
				-message "Info: Share: '//$computername/$share' mounted on: '$dir'" \
				-display :$display &
		fi
		echo "$dir" >> "$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mpoint"
	else
		nxlog "$FUNCNAME ($$): Share //$computername/$share mount FAILED."
		rmdir "$dir" >/dev/null 2>/dev/null #JJK: Remove mount point if empty
		[ "$ENABLE_SHARE_MULTIMOUNT" = "1" ] || $PATH_BIN/nxdialog -dialog ok \
			-caption "NXServer Message" \
			-message "Info: Share: '//$computername/$share' failed to mount." \
			-display :$display &
	fi
}

cmd_node_addprinter() {
	nxlog "$FUNCNAME ($$): starting"
	sessionid=$(getparam_sessionid)
	type=$(getparam type)
	port=$(getparam port)
	username=$(getparam username)
	password=$(getparam password)
	share=$(getparam share)
	printer=$(getparam printer)
	computername=$(getparam computername)
	public=$(getparam public)
	model=$(getparam model)
	defaultPrinter=$(getparam defaultPrinter)
	[ -z "$defaultPrinter" ] && defaultPrinter=$(getparam defaultprinter) # for opennx
	sdir=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid)
	display=$(cutfn "$sdir" "-" -2)
	sess_id="$SERVER_NAME-$display-$sessionid"
	# normalize
	username=$(norm_param $username)
	password=$(norm_param $password)
	share=$(norm_param $share)
	computername=$(norm_param $computername)
	# this will also setup the userspace cupsd
	export CUPS_SERVER=$(node_cupsd_get_socket)

	if [ "$type" = "smb" ]; then
		if [ -x "$CUPS_BACKEND/nxsmb" ]; then
			smbport=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport" 2>/dev/null)
			[ -z "$smbport" ] && smbport=139 # should not happen
			if [ "$smbport" = "445" ]; then smbproto="cifs"
			else smbproto="smb"
			fi
			DEVICE_URI="nxsmb://$username:$password@127.0.0.1:$port/$smbproto/$share"
		else
			DEVICE_URI="smb://$username:$password@127.0.0.1:$port/$share"
		fi
		NAME="$share"; ENABLE_CUPS_SEAMLESS="0"
		nxlog "$FUNCNAME ($$): set NAME = $NAME; smbport=$smbport; DEVICE_URI=$DEVICE_URI"
	else
		printer=$(norm_param $printer)
		DEVICE_URI="ipp://$username:$password@127.0.0.1:$port/printers/$printer"
		NAME="$printer"
		nxlog "$FUNCNAME ($$): set NAME = $NAME; DEVICE_URI=$DEVICE_URI"
	fi

	#JJK: I like to also allow 'guest' so you can do things like print
	#JJK: testpages from the CUPS web interface. Note this is required
	#JJK: even for the original user to print test pages
	#JJK:	PUBLIC="-u allow:$USER"
	PUBLIC="-u allow:$USER,guest,root"
	[ "$public" == "1" ] && PUBLIC=""
	export PATH_BIN
	USER_PPD_DIR="$USER_FAKE_HOME/.nx/config/ppd"
	mkdir -p "$USER_PPD_DIR"
	nxlog "$FUNCNAME ($$): run with ENABLE_CUPS_SERVER_MODE=$ENABLE_CUPS_SERVER_MODE"
	# dimbor: We use system cupsd
	if [ "$ENABLE_CUPS_SERVER_MODE" = "1" ]; then
		# dimbor: Name of windows share or ipp-printer may be set to name
		# of driver.ppd from $NX_ETC_DIR/ppd/ (without ".ppd").
		# For ipp if driver not found we try it to download like
		# oriiginal behaviour (need installed curl).
		# In case of ENABLE_FOOMATIC="1" share/printer name may set to
		# [@]<printer id>[#<N>][__<driver_num>][-nocheck]
		# @: if sharename started with char "@", force setup to anyone
		# share name driver "HP-LaserJet_4M-Postscript.ppd"
		# http://www.nixp.ru/articles/win_printing_in_linux (hello to DjSpike)
		# <printer id>: significant part of drver's uri.
		# <N>: number of printer instance
		# "__": char "_" twice
		# <driver_num>: number from drver's uri.
		# Driver-uri is first field of output '/usr/lib/cups/driver/* list'
		# -nocheck: do not check remote smb-share by rpclient (to W7 Home clients)
		PRE=""; [ "${NAME:0:1}" = "@" ] && { PRE="1"; NAME=${NAME:1}; }
		nocheck=""; stringinstring "-nocheck" "$NAME" && {
			 nocheck="1"; NAME=${NAME/-nocheck/}; }
		DRV=""; stringinstring "__" "$NAME" && {
			DRV=${NAME#*__}; NAME=${NAME%__*}; }
		NN=""; stringinstring "#" "$NAME" && {
			NN=${NAME#*#}; NAME=${NAME%#*}; }
		PNAME="$USER""_""$NAME""$NN" # user's printer name
		[ -n "$PRE" ] && { ID="HP-LaserJet_4M-Postscript"; DRV="0"; }
		MODEL="$NX_ETC_DIR/ppd/$ID.ppd"
		nxlog "$FUNCNAME ($$): set PNAME = \"$PNAME\", try to install \"$MODEL\" - N=$NN, DRV=$DRV, PNAME=$PNAME."
		[ "$type" = "smb" ] || [ -r "$MODEL" ] || {
			# try to download "left-nx" ppd (original scheme), needs to use
			# wrapper for nxprint on client side
			# TODO: Rewrite
			[ "$(check_remote_printer "ipp" "fake_param" $port)" = "0" ] && {
				nxlog "$FUNCNAME ($$): Remote CUPS not found!"
				return 1
			}
			errstr=$(curl --proxy "" --digest -o "$MODEL" \
				"http://$username:$password@127.0.0.1:$port/ppd/${NAME}_nxdl.ppd" 2>&1)
			cmdstr="curl --proxy \"\" --digest -o $MODEL http://$username:******@127.0.0.1:$port/ppd/${NAME}_nxdl.ppd"
			[ -r "$MODEL" -a -n "$(head -n1 "$MODEL" 2>/dev/null | grep "*PPD-Adobe")" ] && {
				nxlog "$FUNCNAME ($$): $MODEL download SUCCESSFUL."
			} || {
				nxlog "$FUNCNAME ($$): $MODEL is NOT a PPD-file! Contents: \"$(cat $MODEL 2>/dev/null)\""
				nxlog "$FUNCNAME ($$): cmd: $cmdstr"
				nxlog "$FUNCNAME ($$): $errstr"
				rm -f "$MODEL"
			}
		}
		if [ ! -r "$MODEL" ]; then
			# TODO: Rewrite
			[ "$ENABLE_FOOMATIC" != "0" ] &&  { # search ppd-file in cups
				cups_driver_dir="/usr/lib/cups/driver"; uris=""
				for prog in $cups_driver_dir/*; do
					[ -x $prog ] || continue
					stringinstring "gutenprint" "$prog" && \
						mn="$ID"|| mn="$ID.ppd"
					strs=$($prog list 2>/dev/null | grep "$mn")
					[ -z "$strs" ] && continue
					strs=$(echo "$strs" | \
						awk -F'"' '{ printf("%s\n",$2)}')
					uris="$uris""$strs"
				done
				[ -n "$HASDRV" ] && uris=$(echo "$uris" | awk -F'/' \
					'{nd=substr($1,index($1,":")+1); if (nd ~ '$DRV') {printf("%s\n",$0)}}')
				drv_uri=$(echo "$uris" | head -n1)
				[ -n "$drv_uri" ] && {
					nxlog "$FUNCNAME ($$): Try to get \"$MODEL\" from URI \"$drv_uri\""
					prog="$cups_driver_dir/$(echo "$drv_uri" |  awk -F':' '{ printf("%s",$1)}')" #'
					cmdstr="$prog cat $drv_uri"
					$cmdstr > $MODEL
				} || {
					nxlog "$FUNCNAME ($$): Driver for \"$NAME\" not found in CUPS. STOP installing."
					return 1
				}
			}
		fi
		PFN="@p@$PNAME" # filename of flag and description files
		sess_dir="$USER_FAKE_HOME/.nx/C-$sess_id"
		desc_dir="$USER_FAKE_HOME/.nx/shares_priv" # directory with connection parameters to use sessions together
		[ -d "$desc_dir" ] || { mkdir "$desc_dir" && chmod 700 "$desc_dir"; }
		[ "$type" = "smb" ] && {
			for (( i=30; $i; --i )); do
				nxlog "$FUNCNAME ($$): wait for smb-port $((30-i))"
				[ -f "$sess_dir/scripts/mport" ] && break
				sleep 1
			done
		} || share=$printer
		# check existing printers
		pstr=$(LC_ALL=C /usr/bin/lpstat -v "$PNAME" 2>/dev/null)
		if [ -n "$pstr" ]; then # printer present
			iport=$(rematchfn ':([[:digit:]]+)/' "$pstr") #'
			[ "$iport" -gt 0 2>/dev/null ] && drop=0 || { drop=1; dbs="wrong port"; }
			[ -n "$nocheck" ] && { drop=1; dbs="don't check remote printer"; }
			if [ "$drop" = "0" ]; then
				[ "$(check_remote_printer $type $NAME $iport $username $password)" = "0" ] && \
					{ drop=1; dbs="not accessible"; }
			fi
			[ "$drop" = "0" ] && [ "$type" = "ipp" -o "$iport" = "$port" ] && \
				{ drop=1; dbs="for reinstall"; }
			if [ "$drop" = "1" ]; then
				nxlog "$FUNCNAME ($$): delete printer \"$PNAME\" (port:$iport) - $dbs"
				/usr/bin/sudo /usr/sbin/lpadmin -x "$PNAME"
			else
				nxlog "$FUNCNAME ($$): printer \"$PNAME\" already exist at port:$iport - stop adding, mark only"
				echo $password > "$sess_dir/scripts/$PFN"; chmod 600 "$sess_dir/scripts/$PFN"
				return 0
			fi
		fi
		[ "$(check_remote_printer $type $NAME $port $username $password)" = "0" ] && {
			nxlog "$FUNCNAME ($$): \"$NAME\" (mport:$port) NOT ACCESSIBLE stop adding."
			return 1;
		}
		echo $password > "$sess_dir/scripts/$PFN"; chmod 600 "$sess_dir/scripts/$PFN" # set share present flag
		if [ -r "$MODEL" ] ; then
			[ ! -e "$desc_dir/$PFN" ] && touch "$desc_dir/$PFN" \
				&& chmod 600 "$desc_dir/$PFN" # create "top-secret" description file
			echo "$MODEL&$DEVICE_URI&$PUBLIC&$defaultPrinter" > "$desc_dir/$PFN" # confidential access data
			CMDSTR="/usr/bin/sudo /usr/sbin/lpadmin -p $PNAME -P $MODEL -v $DEVICE_URI -E"
		else
			nxlog "$FUNCNAME ($$): $MODEL driver not found! Printer $NAME not installed."
			return 1
		fi
		nxlog "$FUNCNAME ($$): invoke $CMDSTR"
		error="$($CMDSTR 2>&1)"
		if [ $? -eq 0 ] ; then
			nxlog "$FUNCNAME ($$): printer \"$PNAME\" installed"
			[ -n "$PUBLIC" ] && { /usr/bin/sudo /usr/sbin/lpadmin -p $PNAME $PUBLIC;
				[ $? -ne 0 ] && nxlog "$FUNCNAME ($$): FAILED to set options \"$PUBLIC\" for printer \"$PNAME\""
			}
			[ "$defaultPrinter" = "1" ] && {
				/usr/bin/sudo /usr/sbin/lpadmin -d "$PNAME";
				[ $? -ne 0 ] && nxlog "$FUNCNAME ($$): FAILED to set default printer \"$PNAME\""
			}
		else
			nxlog "$FUNCNAME ($$): FAILED to install printer \"$PNAME\": $error"
		fi
	else # original behaviour
		mkdir -p "$USER_FAKE_HOME/.nx/config/ppd/"
		if [ "$ENABLE_CUPS_SEAMLESS" != "1" ]; then
			#JJK: Export the following variables for use by nxdialog/nxprint
			#JJK: Note they are also exported in nxdialog but doesn't help there
			export ENABLE_FOOMATIC COMMAND_FOOMATIC PPD_DIR
			MODEL=$($PATH_BIN/nxdialog -printer "$NAME" -display :$display)
			[ -z "$MODEL" -o "$MODEL" = "cancel: aborted" ] && return
		else
			sleep $CUPS_SEAMLESS_DELAY
			MODEL="download_cached"
		fi

		if [ "$MODEL" = "download_new" -o "$MODEL" = "download_cached" ]; then
			if [ "$MODEL" = "download_new" -o ! -r "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" ]; then
				curl --proxy "" --digest -o "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" "http://$username:$password@127.0.0.1:$port/ppd/${printer}_nxdl.ppd" >>"$USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log" 2>&1
				RC=$?
				[ $RC -eq 0 -a "$ENABLE_CUPS_SEAMLESS" != "1" ] && $PATH_BIN/nxdialog --message "Download successful." -display :$display
				[ $RC -ne 0 -a "$ENABLE_CUPS_SEAMLESS" != "1" ] && $PATH_BIN/nxdialog --message "Download failed. Log is: $USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log" -display :$display
			fi
			MODEL="$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd"
		fi
		if [ ! -r "$MODEL" ]; then
			# Foomatic and co
			/usr/sbin/lpadmin -p "$NAME" -E -v "$DEVICE_URI" -m "$MODEL" $PUBLIC
		else
			/usr/sbin/lpadmin -p "$NAME" -E -v "$DEVICE_URI" -P "$MODEL" $PUBLIC
		fi

		[ "$defaultPrinter" = "1" ] && /usr/sbin/lpadmin -d "$NAME"
	fi # end of original
}

nxnode_func() {
case "$1" in
	--startsession)
		startsession
	;;
	--resumesession)
		startsession "restore"
	;;
	--applicationsession)
		startsession "application"
	;;
	--terminate)
		cmd_node_terminate
	;;
	--suspend)
		cmd_node_suspend
	;;
	--smbmount)
		cmd_node_smbmount
	;;
	--addprinter)
			cmd_node_addprinter
	;;
	--check)
		echo "NX> 716 finished"
	;;
	--agent)
		echo "NX> 716 Starting NX Agent ..."
		shift
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		PATH="$PATH:$PATH_BIN" $COMMAND_NXAGENT \
			-name "NX Agent Test - Args: $@" $@
		echo "NX> 716 NX Agent exited with status: $?"
	;;
	--setkey)
		mkdir -m 700 -p $HOME/.ssh
		if ! grep -q "$(cat $NX_ETC_DIR/users.id_dsa.pub)" $HOME/.ssh/$SSH_AUTHORIZED_KEYS 2>/dev/null; then
			cat $NX_ETC_DIR/users.id_dsa.pub >> $HOME/.ssh/$SSH_AUTHORIZED_KEYS
			chmod 600 $HOME/.ssh/$SSH_AUTHORIZED_KEYS
			echo "NX> 716 Public key added to: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
		else
			echo "NX> 716 Public key is already present in: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
		fi
	;;
	*)
		echo "NX> 500 Error: Command not found"
	;;
esac

}


if [ "$1" = "--slave" ]; then
	# New slave mode accepts more than 1 command at a time
	echo "NX> 716 Slave mode started successfully."
	NODE_SESSION=""
	while read CMD; do
		[ "$CMD" = "--quit" ] && break
		if [ "$CMD" != "--check" -a "$CMD" != "--setkey" \
				-a "$CMD" != "--agent" ]; then
			read CMDLINE; CMDLINE="a=b&$CMDLINE"
		fi
		if [ "$CMD" = "--startsession" -o "$CMD" = "--resumesession" ]; then
			export SLAVE_PID="$$"
			( echo "$CMDLINE" | "$0" "$CMD"; kill "$SLAVE_PID"; ) &
			NODE_SESSION="$!"
		else
			DELIM=""
			[ -n "$NODE_SESSION" ] && DELIM="$NODE_SESSION->$CMD"
			( echo "$CMDLINE" | "$0" "$CMD" "$DELIM"; ) &
		fi
	done
else
	nxnode_func "$@"
fi

echo "$DELIM 1001 Bye."
