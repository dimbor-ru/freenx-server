#!/bin/bash

# Free implementation of nxserver components
# Copyright (c) 2004 by Fabian Franz.
#           (c) 2008-19 by Dmitry Borisov <i@dimbor.ru>
# License: GNU GPL, version 2

# Read the config file
# dimbor: it's temporary
. /usr/bin/nxloadconfig --userconf

. $SHARED_CONFS/nxfuncs

# config variables in use:
# SAMBA_MOUNT_SHARE_PROTOCOL COMMAND_SMBMOUNT COMMAND_SMBUMOUNT
# COMMAND_NETCAT
# NX_VERSION NX_LICENSE NX_LOG_SECURE NX_LOG_LEVEL USER_FAKE_HOME

# use env vars: USER

declare -g delim CMDLINE


#JJK: Added	following 'if' stanza as a kluge since the following variables
#JJK: need to be set in cmd_node_smbmount node_umount_smb
#JJK: but they are currently set only in startsession which is called
#JJK: separately from nxserver via ssh so environment variables
#JJK: aren't preserved.
if stringinstring "$SAMBA_MOUNT_SHARE_PROTOCOL" "cifs|both" && \
	[ -n "$COMMAND_SMBMOUNT_CIFS" -a -n "$COMMAND_SMBUMOUNT_CIFS" ]; then
	COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS
	COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
	SAMBA_MOUNT_SHARE_PROTOCOL="cifs"
fi

#
# -----------------------------------------------------------------------------
# Startup of nxnode
# -----------------------------------------------------------------------------
#
delim="NX>";[ -n "$2" ] && delim="NX-$2>"
echo "$delim 1000 NXNODE - Version $NX_VERSION $NX_LICENSE"
if ! stringinstring "$1" "--check|--setkey|--agent"; then
	read CMDLINE; CMDLINE="a=b&$CMDLINE"
fi
#
# -----------------------------------------------------------------------------
# Various helper functions
# -----------------------------------------------------------------------------
#
getparam_sessionid() {
	sessionid=$(getparam sessionid)
	[ -n "$sessionid" ] || sessionid=$(getparam session_id)
	if [ -z "$sessionid" ]; then
		echo "NX> 500 Error: Fatal - Missing parameter session id." 1>&2
		exit 1
	fi
	echo $sessionid
}

echo_secure() {
	if [ "$NX_LOG_SECURE" = "0" ]; then echo "$@"
	else echo "${@//&password=*&/&password=****&}"
	fi
}

nxlog() {
	[ "$NX_LOG_LEVEL" -lt 6 ] && return 0
	echo_secure "$(date "+%T.%3N"): $@" >> "$nxuser_logfile"
}

if [ "$USER" = "nx" ]; then nxuser_logfile="/var/log/nx/nxnode.log"
else
	nxuser_logfile="$USER_FAKE_HOME/.nx/nxnode.log"
	mkdir -p "$USER_FAKE_HOME/.nx"
fi

if [ -n "$CMDLINE" ]; then
	if [ "$USER" != "nx" ]; then
		ssid4log=$(getparam uniqueid)
		[ -z "$ssid4log" ] && ssid4log=$(getparam session_id)
		[ -z "$ssid4log" ] && ssid4log=$(getparam sess_id)
		[ -z "$ssid4log" ] && ssid4log=$(getparam sessionid)
		ssid4log=${ssid4log##*-}
		[ -n "$ssid4log" ] && \
			nxuser_logfile="$USER_FAKE_HOME/.nx/nxnode-$ssid4log.log"
	fi
	nxlog "$0 ($$): run nxnode with PARAMS:\"$@\"; CMDLINE='$CMDLINE'"
else
	nxlog "$0 ($$): run nxnode with \"$@\""
fi

#
# -----------------------------------------------------------------------------
# Node functions module
# -----------------------------------------------------------------------------
#

norm_param() {
# arg: string
# dimbor: normalize string from hex (thnx 2Civil at unixforum.org) and convert
# charset if needed
	#nxlog "$FUNCNAME ($$): starting with args \"$@\""
	local res=${1/+/ } cp_pair cp_from cp_to;
	for cp_pair in $WIN_CP_CONVERT_CHAIN ; do
		cp_from=$(cutfn "$cp_pair" '>' 0); [ -n "$cp_from" ] || cp_from="UTF-8"
		cp_to=$(cutfn "$cp_pair" '>' 1); [ -n "$cp_to" ] || cp_to="UTF-8"
		res=$(echo "$res" | iconv -f $cp_from -t $cp_to)
		#nxlog "$FUNCNAME ($$): converting $cp_from > $cp_to == \"$res\""
	done
	#nxlog "$FUNCNAME ($$): return res='$res'"
	echo "$res"
}

# dimbor: functions to control user's shares and printers in mode "per user"
# instead of "per session".

get_mport2sessdir() {
# args: session dir type="smb"|"ipp""
# ret: cups listening port or samba mount port
	local type=$2 mport="" smbport cport;
	[ -r "$1/scripts/mport" ] && 	smbport=$(< $1/scripts/mport)
	[ -r "$1/session" ] && cport=$(< $1/session);
	cport=$(rematchfn "Listening to CUPS.+'(.+)'" "$cport" 0 "rev") #'
	if [ "$type" != "smb" -a -n "$cport" ]; then mport=$cport; type="ipp";
	elif [ "$type" != "ipp" -a  -n "$smbport" ]; then
		mport=$smbport; type="smb";
	fi
	mport=${mport##*:}
	nxlog "$FUNCNAME ($$): sessdir \"$1\"; mport='$mport' type='$type'"
	echo $mport
}

get_sessdir4res() {
# args: port - session's smb/ipp mount port OR filename of printer/share
# (flag-file) fl_current - if set then includes in search current session-dir
# if share is nx-controlled and nxagent from his session are leave,
# then returns name of session dir (except dir of own sesson)
# functuion used with $ENABLE_SHARE_MULTIMOUNT=1 or
# $ENABLE_CUPS_SERVER_MODE=1 modes only
	nxlog "$FUNCNAME ($$): starting with args \"$@\"; sess_id='$sess_id'"
	local digarg agent_pids sessdir node_agent_pid curport;
	[ "$1" -gt 0 2>/dev/null ] && digarg=1 || digarg=0
	agent_pids=$(ps -wo pid= -C "nxagent")
	for sessdir in $USER_FAKE_HOME/.nx/C-* ; do
		[ -z "$2" -a "$sessdir" == "$USER_FAKE_HOME/.nx/C-$sess_id" ] && continue
		node_agent_pid=""
		[ -r "$sessdir/pids/agent" ] && node_agent_pid=$(< $sessdir/pids/agent)
		[ -z "$node_agent_pid" ] && continue
		stringinstring "$node_agent_pid" "$agent_pids" || continue
		#nxlog "$FUNCNAME ($$): browse sessdir \"$sessdir\" for filename = \"$sessdir/scripts/$1\", digarg=$digarg"
		if [ "$digarg" = "1" ]; then
			curport=$(get_mport2sessdir "$sessdir")
			[ "$curport" = "$1" ] && {
				nxlog "$FUNCNAME ($$): found sessdir='$sessdir' for mport = $1"
				echo "$sessdir"; return;
			}
		else
			[ -f "$sessdir/scripts/$1" ] && {
				nxlog "$FUNCNAME ($$): found sessdir='$sessdir' for filename = $1"
				echo "$sessdir"; return;
			}
		fi
	done
	nxlog "$FUNCNAME ($$): target sessdir not found"
}

check_remote_printer() {
# args: type - "smb" or "ipp"
# short sharename/printername
# port - nx controlled mount port
# name - user name
# pass - password (optional)
# if shared printer accessible, returns 1, else - 0
	nxlog "$FUNCNAME ($$): starting with args \"$@\""
	local res i nxredir_lib cmdstr numa upass ret dport;
	if [ "$1" = "ipp" ]; then # checking ipp printer port only
		res=0;
		for (( i=10; $i; --i )); do
			nxlog "$FUNCNAME ($$): wait for ipp-port 127.0.0.1:$3 - $((10-i))"
			$COMMAND_NETCAT -znvw 1 127.0.0.1 $3 2> /dev/null > /dev/null
			[ $? -eq 0 ] && { res=1; break; }
			sleep 1
		done
		nxlog "$FUNCNAME ($$): end with res = $res"
		echo $res; return 0;
	fi
	[ "$(cutfn "$2" "-" "-1")" = "nocheck" ] && {
		res=1
		nxlog "$FUNCNAME ($$): special sharename \"$2\" - stop checking, end with res='$res'"
		echo $res; return 0;
	}
	nxredir_lib="$PATH_LIB/freenx-server/libnxredir.so.0"
	[ -n "$5" ] && upass="$4%$5" || upass="$4 -N"
	[ "$SAMBA_MOUNT_SHARE_PROTOCOL" = "cifs" ] && dport=445 || dport=139
	cmdstr="/usr/bin/rpcclient -U '$upass' -c 'openprinter $2' \
-p $dport -I 127.0.0.1 127.0.0.1 2>&1"
	nxlog "$FUNCNAME ($$): invoke command \"$cmdstr\""
	res=""; numa="0"; ret="0"
	while [ "$ret" = "0" ]; do
		# addprinter and addmount try to use one mport at the same time,
		# we need to endure ;)
		(( numa++ ))
		res=$(NXSAMBA_PORT=$3 LD_PRELOAD=$nxredir_lib eval $cmdstr)
		nxlog "$FUNCNAME ($$): on attempt $numa says \"$res\""
		[ -n "$(rematchfn '(successfully)' "$res")" ] && { ret="1"; continue; }
		[ "$numa" -gt 4 ] && ret="1" && res="timeout"
	done
	[ -n "$(rematchfn '(successfully)' "$res")" ] && res=1 || res=0
	nxlog "$FUNCNAME ($$): end with res = $res"
	echo $res
}

check_local_pa_tunnel() {
# params:	tunnel ip:port
#		resample rate
#		amount of channels
# return:	pid of pa process
# This starts user's local pulseaudio server if not running and tune its own
# modules - (re)create tunneled sink and source to remote pa
	local errstr retpid lpa_mods tunn_opts tunn_exists mname rmids rpa_info;
	local errids="" errstr="" errstr2="" mname_tunn_sink mname_tunn_source;
	local success="" def_rsink def_rsource rsi_args rso_args
	local pactl_bin="env LANG=C /usr/bin/pactl"
	unset PULSE_SERVER; unset PULSE_SINK; unset PULSE_SOURCE
	# automatic start user's pa is here (pa starting with default system settings)
	errstr=$($pactl_bin info 2>&1)
	[ -n "$(rematchfn '(failure)' "$errstr")" ] && {
		nxlog "$FUNCNAME ($$): Local PA is not reachable ($errstr)."
		echo ""; return 1;
	}
	retpid=$(ps -wo pid= -C "pulseaudio")
	[ -n "$retpid" ] && nxlog "$FUNCNAME ($$): Found PA:$retpid"
	lpa_mods=$($pactl_bin list short 2>/dev/null)
	tunn_opts="server=$1"
	tunn_exists=$(rematchfn "($tunn_opts)" "$lpa_mods") #"
	[ -n "$tunn_exists" ] && {
		nxlog "$FUNCNAME ($$): Right modules already exists: $tunn_exists"
		echo $retpid; return 0;
	}
	mname="module-always-sink" # automatic null-sinks will be disabled
	rmids=$(rematchfn "^([[:digit:]]+)[[:space:]]+$mname" "$lpa_mods") #"
	# any sinks and sources will be unloaded too
	rmids+="${rmids:+ }$(rematchfn "^([[:digit:]]+).+sink_name" "$lpa_mods")" #"
	rmids+="${rmids:+ }$(rematchfn "^([[:digit:]]+).+source_name" "$lpa_mods")" #"
	[ -n "$rmids" ] && {
		for i in $rmids; do
			errstr2=$($pactl_bin unload-module $i 2>&1)
			[ $? -ne 0 ] && { errids+=" $i"; errstr+="; $errstr2"; }
		done
	}
	[ -n "$errids" ] && {
		nxlog "$FUNCNAME ($$): Removing PA modules error. errids='$errids'; errsrr='$errstr' "
	}
	mname_tunn_sink="module-tunnel-sink"; mname_tunn_source="module-tunnel-source";
	rpa_info=$($pactl_bin -s $1 info 2>/dev/null)
	[ -z "$rpa_info" ] && {
		nxlog "$FUNCNAME ($$): Couldn't get defaults from REMOTE pulseaudio $1."
		echo ""; return 1;
	}
	[ -n "$2" ] && {
		tunn_opts+=" rate=$2"
		[ -n "$3" ] && {
			tunn_opts+=" channels=$3"
			[ "$3" == "1" ] && tunn_opts+=" channel_map=mono"
		}
	}
	def_rsink=$(rematchfn "Default Sink:[[:space:]]+(.+)" "$rpa_info") #"
	if [ -z "$def_rsink" -o "$def_rsink" == "(null)" ]; then
		nxlog "$FUNCNAME ($$): Couldn't get default sink from REMOTE pulseaudio $1."
	else # load module-tunnel-sink
		rsi_args="sink_name=tcl_out sink=$def_rsink $tunn_opts"
		errstr=$($pactl_bin load-module $mname_tunn_sink $rsi_args 2>&1)
		[ $? -ne 0 ] && {
			nxlog "$FUNCNAME ($$): Loading module $mname_tunn_sink error (\"$rsi_args\"); \"$errstr\""
		} || {
			success="1"
			nxlog "$FUNCNAME ($$): Successfully loadded module $mname_tunn_sink  (\"$rsi_args\")."
		}
	fi
	def_rsource=$(rematchfn "Default Source:[[:space:]]+(.+)" "$rpa_info") #"
	if [ -z "$def_rsource" -o "$def_rsource" == "(null)" -o \
			"$def_rsource" == "$def_rsink.monitor" ]; then
		nxlog "$FUNCNAME ($$): Couldn't get default source from REMOTE pulseaudio $1."
	else # load module-tunnel-source
		rso_args="source_name=tcl_in source=$def_rsource $tunn_opts"
		errstr=$($pactl_bin load-module $mname_tunn_source $rso_args 2>&1)
		[ $? -ne 0 ] && {
			nxlog "$FUNCNAME ($$): Loading module $mname_tunn_source error (\"$rso_args\"); \"$errstr\""
		} || {
			success="1"
			nxlog "$FUNCNAME ($$): Successfully loadded module $mname_tunn_source  (\"$rso_args\")."
		}
	fi
	[ -n "$success" ] && echo $retpid || echo ""
}

reconnect_pa() {
	local mmport="" papars="" node_agent_pid rate channels papid="" agent_pids;
	local sessdir;
	[ -r "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/pa_pid" ] && \
		papid=$(< $USER_FAKE_HOME/.nx/C-$sess_id/scripts/pa_pid)
	[ -z "$papid" ] && return
	agent_pids=$(ps -wo pid= -C "nxagent")
	for sessdir in $USER_FAKE_HOME/.nx/C-*; do # start port search
		[ "$sessdir" == "$USER_FAKE_HOME/.nx/C-$sess_id" ] && continue
		node_agent_pid=""; [ -r "$sessdir/pids/agent" ] && \
			node_agent_pid=$(< $sessdir/pids/agent)
		[ -z "$node_agent_pid" ] && continue
		stringinstring $node_agent_pid "$agent_pids" || continue
		mmport=""; [ -r "$sessdir/scripts/mmport" ] && \
			mmport=$(< $sessdir/scripts/mmport)
		[ -n "$mmport" ] && break
	done
	if [ -n "$mmport" ]; then # try reconnect
		papars=$(< $USER_FAKE_HOME/.nx/C-$sess_id/scripts/params.pa)
		rate=$(cutfn "$papars" ":" 0)
		channels=$(cutfn "$papars" ":" 1)
		[ -z "$(check_local_pa_tunnel 127.0.0.1:$mmport $rate $channels)" ] && {
			nxlog "$FUNCNAME ($$): Couldn't reconnect PA tunnel to port $mmport."
		}
	else # kill local PA
		kill $papid 2>/dev/null
	fi
}

# node_terminate_agent <session id>
node_terminate_agent() {
	nxlog "$FUNCNAME ($$): starting"
	local node_agent_pid;
	[ -r "$USER_FAKE_HOME/.nx/C-$1/pids/agent" ] && \
		node_agent_pid=$(< $USER_FAKE_HOME/.nx/C-$1/pids/agent)
	[ -n "$node_agent_pid" ] && {
		nxlog "$FUNCNAME ($$): killing node_agent_pid='$node_agent_pid'"
		kill $node_agent_pid 2>/dev/null;
		sleep 0.3s
	}
	kill -0 $node_agent_pid && {
		nxlog "$FUNCNAME ($$): killing node_agent_pid. Try #2"
		kill -9 $node_agent_pid 2>/dev/null
	}
	nxlog "$FUNCNAME ($$): end"
}

# node_terminate_session <session id>
#	Used glob vars: $virtualdesktop, $rootless
#	Used config vars: $COMMAND_XAUTH, $SESSION_LOG_CLEAN
node_terminate_session() {
	local node_agent_pid node_tail_pid="" display sessdir
	nxlog "$FUNCNAME ($$): Start terminating session \"$1\" with status \"$2\""
	sessdir="$USER_FAKE_HOME/.nx/C-$1"
	[ -e "$sessdir/terminating" ] && {\
		nxlog "$FUNCNAME ($$): Terminating still in progress. Bye."
		return;
	}
	[ -d "$sessdir" ] || {\
		nxlog "$FUNCNAME ($$): Session directory not found."
		return;
	}
	touch "$sessdir/terminating"

	# Kill nxagent
	[ -r "$sessdir/pids/agent" ] && \
		node_agent_pid=$(< $sessdir/pids/agent)

	# JJK: Kill running services
	# FF: Seems this is needed also here ...
	# dimbor: ... but have to be a little more tender ;)
	nxlog "$FUNCNAME ($$): call node_stop_services"
	node_stop_services
	if [ -n "$node_agent_pid" ]; then
		nxlog "$FUNCNAME ($$): start killing of nxagent"
		kill $node_agent_pid 2>/dev/null
		wait $node_agent_pid 2>/dev/null
		kill -0 $node_agent_pid ||
			nxlog "$FUNCNAME ($$): nxagent ($node_agent_pid) is dead now"
	fi

	# Kill tail process
	[ -r "$sessdir/pids/tail" ] && {
		node_tail_pid=$(< $sessdir/pids/tail)
		nxlog "$FUNCNAME ($$): kill tail process"
		kill $node_tail_pid 2>/dev/null;
	}

	# Remove display information
	nxlog "$FUNCNAME ($$): Remove display information"
	display=$(cutfn "$1" "-" -2)
	rm -f /tmp/.X$display-lock; rm -f /tmp/.X11-unix/X$display

	# Remove magic cookie information
	nxlog "$FUNCNAME ($$): Remove magic cookie information"
	$COMMAND_XAUTH -v source "$USER_FAKE_HOME/.nx/C-$1/scripts/authority" >/dev/null 2>&1

	# Preserve or remove session information
	nxlog "$FUNCNAME ($$): Preserve or remove session information"
	if [ "$SESSION_LOG_CLEAN" = "1" ]; then
		nxlog "$FUNCNAME ($$): Clean session information."
		rm -rf "$USER_FAKE_HOME/.nx/C-$1/"
		rm -f  "$USER_FAKE_HOME/.nx/nxnode-$1.log"
		rm -f  "$USER_FAKE_HOME/.nx/nxnode.log"
	fi
	if [ "$SESSION_LOG_CLEAN" = "0" -a "$2" = "failed" ] ; then
		nxlog "$FUNCNAME ($$): Session failed. Rename session directory from \"$USER_FAKE_HOME/.nx/C-$1/\" to \"$USER_FAKE_HOME/.nx/F-C-$1\""
		mv "$USER_FAKE_HOME/.nx/C-$1/" "$USER_FAKE_HOME/.nx/F-C-$1"
		rm -f "$USER_FAKE_HOME/.nx/F-C-$1/terminating"
	elif [ "$SESSION_LOG_CLEAN" = "0" -a "$2" != "failed" ] ; then
		nxlog "$FUNCNAME ($$): Session terminated. Rename session directory from \"$USER_FAKE_HOME/.nx/C-$1/\" to \"$USER_FAKE_HOME/.nx/T-C-$1\""
		mv "$USER_FAKE_HOME/.nx/C-$1/" "$USER_FAKE_HOME/.nx/T-C-$1"
		rm -f "$USER_FAKE_HOME/.nx/T-C-$1/terminating"
	fi
	nxlog "$FUNCNAME ($$): end"
}


# node_fail_restore_session <session id>
# TODO: Kill still running tail -f process.
node_fail_restore_session() {
	local node_tail_pid;
	nxlog "$FUNCNAME ($$): starting"
	echo "NX> 1004 Error: Could not resume session. nxagent process could not be found."
	[ -r "$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail" ] && {
		node_tail_pid=$(< $USER_FAKE_HOME/.nx/C-$sess_id/pids/tail)
		nxlog "$FUNCNAME ($$): kill tail process"
		kill $node_tail_pid 2>/dev/null;
		echo "NX 1004> kill $node_tail_pid"
	}
	node_terminate_session "$1" "failed"
	nxlog "$FUNCNAME ($$): end. Next is 'exit 1'"
	exit 1
}


# node_suspend_session <session id>
node_suspend_session() {
	nxlog "$FUNCNAME ($$): starting"
	local node_agent_pid;
	[ -r "$USER_FAKE_HOME/.nx/C-$1/pids/agent" ] && \
		node_agent_pid=$(< $USER_FAKE_HOME/.nx/C-$1/pids/agent)
	if [ -n "$node_agent_pid" ]; then
		nxlog "$FUNCNAME ($$): node_agent_pid='$node_agent_pid' Killing..."
		kill -0 $node_agent_pid || {
			nxlog "$FUNCNAME ($$): end (0)"
			return 1;
		}
		kill -HUP $node_agent_pid && {
			nxlog "$FUNCNAME ($$): end (HUP)"
			return 0;
		}
	else nxlog "$FUNCNAME ($$): node_agent_pid is empty; end"
	fi
	return 1
}


# node_find_application <type>
#	Used config vars: $COMMAND_START_KDE, $COMMAND_START_GNOME,
#			  $COMMAND_START_CDE, $COMMAND_XTERM, $USER_X_STARTUP_SCRIPT,
#			  $DEFAULT_X_SESSION
node_find_application() {
	nxlog "$FUNCNAME ($$): starting with args \"$@\""
	local node_startx=""
	case $1 in
		shadow|windows|vnc)
			:
		;;
		unix-kde)
			node_startx=$COMMAND_START_KDE
			[ "$KDE4_ENABLE" = "1" -a -n "$COMMAND_START_KDE" ] && \
				node_startx=$COMMAND_START_KDE4
		;;
		unix-gnome)
			node_startx=$COMMAND_START_GNOME
		;;
		unix-cde)
			node_startx=$COMMAND_START_CDE
		;;
		windows-helper)
			application="$PATH_BIN/nxdesktop_helper"
			node_startx=$application
		;;
		unix-application|vnc-helper)
			[ "$application" = "xterm" ] && application=$COMMAND_XTERM
			node_startx=$application
		;;
		unix-console)
			node_startx=$COMMAND_XTERM
		;;
		unix-default|*)
			if [ -x "$HOME/$USER_X_STARTUP_SCRIPT" ]; then
				node_startx="$HOME/$USER_X_STARTUP_SCRIPT"
			elif [ -x "$DEFAULT_X_SESSION" ]; then
				node_startx="$DEFAULT_X_SESSION"
			else node_startx=$COMMAND_XTERM
			fi
		;;
	esac

	# dimbor: another personalyzed way to ACLS control and replace X-application
	[ -d "$NX_ACL_DIR" -a -x "$PATH_BIN/nxacl.app" ] && {
		nxlog "$FUNCNAME ($$): !!! call nxacl.app with source node_startx='$node_startx'"
		node_startx=$($PATH_BIN/nxacl.app "$node_startx" "$CMDLINE")
	}

	echo "$node_startx"
	nxlog "$FUNCNAME ($$): return node_startx='$node_startx'"
}

get_pa_sound_mode() {
# params:	port of pa server
#		ipaddr
	local cl_pa_mods
	[ -z "$2" ] && {
		nxlog "$FUNCNAME ($$): Client's IP-address is not defined."
		echo ""; return 1;
	}
	stringinstring "open" "$($COMMAND_NETCAT -nvz -w 1 $2 $1 2>&1)" || {
		nxlog "$FUNCNAME ($$): Client's pulseaudio at $2:$1 is not reachable."
		echo ""; return 1;
	}
	pactl_bin="env LANG=C /usr/bin/pactl -s $2:$1"
	nxlog "$FUNCNAME ($$): $pactl_bin list short"
	cl_pa_mods=$($pactl_bin list short)
	#nxlog "$FUNCNAME ($$): $cl_pa_mods"
	stringinstring "ts_receiver" "$cl_pa_mods" && \
		stringinstring "ts_sender" "$cl_pa_mods" && {
		nxlog "$FUNCNAME ($$): Specials sink and source at $2:$1 are found."
		echo "special"; return 0;
	}
	nxlog "$FUNCNAME ($$): Defaults sink and source at $2:$1 be used."
	echo "default"; return 0;
}

# node_start_applications
#	Used glob vars: $type, $application, $sess_id, $mediahelper,
#				 $virtualdesktop, $rootless, $display
#	Used config vars: <several>
node_start_applications() {
	nxlog "$FUNCNAME ($$): starting"
	local node_app mmode rate channels mmport pa_remote pa_pid params;
	local native_sound_mode second_app="" sapp_pids0="" napp;
	local spid node_app_pid sapp_pids="" sapp_pids1 node_wm_pid;
	# close input and output file descriptors
	exec 0<&-
	exec 1>&-
	exec 2>&-

	# Prepare application startup
	export DISPLAY=:$display
	if [ "$ENABLE_SOURCE_PROFILE" = "1" ]; then
		nxlog "$FUNCNAME ($$): source profile"
		. /etc/profile
	fi
	if [ "$ENABLE_SOURCE_BASH_PROFILE" = "1" ]; then
		nxlog "$FUNCNAME ($$): source bash profile"
		[ -f ~/.bash_profile ] && . ~/.bash_profile
		[ -f /etc/bashrc ] && . /etc/bashrc
	fi

	nxlog "$FUNCNAME ($$): display='$display', waiting for it's ready"
	local cntr=$((AGENT_STARTUP_TIMEOUT*100)); local cntr0=$cntr
	while [ ! -f /tmp/.X$display-lock ]; do
		sleep 0.01s; ((cntr--)); ((cntr<=0)) && break
	done
	nxlog "$FUNCNAME ($$): Stop waiting for DISPLAY $((cntr0-cntr))0 ms"

	#numlockx
	if [ "$NUMLOCKX_STATUS" != "system" ]; then
		nxlog "$FUNCNAME ($$): Run \"$NUMLOCKX $NUMLOCKX_STATUS\""
		"$NUMLOCKX" "$NUMLOCKX_STATUS"
	fi

	mkdir -p "$NXSESSION_DIRECTORY/pids/apps/"
	# Which application do we start?
	node_app=$(node_find_application "$type")
	# For rdesktop/VNC, there is no application to start
	if [ -n "$node_app" ]; then
		nxlog "$FUNCNAME ($$): Got node_app is \"$node_app\""
	else
		nxlog "$FUNCNAME ($$): node_app is empty"
		return
	fi

	# Check if we want to use a mediahelper
	mmode="$(cutfn "$mediahelper" "-" 0)"
	rate="$(cutfn "$mediahelper" "-" 1)"
	channels="$(cutfn "$mediahelper" "-" 2)"
	[ -r "$NXSESSION_DIRECTORY/scripts/mmport" ] && \
		mmport="$(< $NXSESSION_DIRECTORY/scripts/mmport)"
	if [ "$mmode" == "pa" -a -n "$mmport" ]; then
		pa_remote="127.0.0.1:$mmport"
		pa_pid="$(check_local_pa_tunnel $pa_remote $rate $channels)"
		if [ -n "$pa_pid" ]; then
			nxlog "$FUNCNAME ($$): Local pulseaudio is started ($pa_pid). Sound mode set to tunneled."
			echo $pa_pid > "$NXSESSION_DIRECTORY/scripts/pa_pid"
			params=$rate
			[ -n "$channels" ] && params+=":$channels"
			[ -n "$params" ] && echo "$params" > "$NXSESSION_DIRECTORY/scripts/params.pa"
		else
			nxlog "$FUNCNAME ($$): Local pulseaudio NOT STARTED. Set PULSE_SERVER=127.0.0.1:$mmport"
			export PULSE_SERVER="127.0.0.1:$mmport"
		fi
	elif [ "$ENABLE_DIRECT_NATIVE_PA_CHECK" = "1" ] ; then
		native_sound_mode="$(get_pa_sound_mode 4713 $NXUSERIP)"
		if [ -n "$native_sound_mode" ]; then
			nxlog "$FUNCNAME ($$): Sound mode set to direct $native_sound_mode"
			export PULSE_SERVER="$NXUSERIP:4713"
			if [ "$native_sound_mode" = "special" ]; then
				export PULSE_SINK="ts_receiver"
				export PULSE_SOURCE="ts_sender.monitor"
			fi
			node_app="/usr/bin/padsp $node_app"
		fi
	elif [ "$mediahelper" = "esd" ]; then
		# Set Espeaker variable
		let ESPEAKER=$display+7000
		export ESPEAKER="127.0.0.1:$ESPEAKER"
		# Do not spawn new ESD daemons
		export ESD_NO_SPAWN="yes"
		# Check for config file directive
		if [ "$ENABLE_ESD_PRELOAD" = "1" -a \
				-x "$ESD_BIN_PRELOAD" ]; then
			nxlog "$FUNCNAME ($$): Preload \"$ESD_BIN_PRELOAD\""
			node_app="$ESD_BIN_PRELOAD $node_app"
			nxlog "$FUNCNAME ($$): node_app is \"$node_app\""
			echo "Info: NXNODE - Using $ESD_BIN_PRELOAD wrapper script." >> "$NXSESSION_DIRECTORY/session"
		fi
	elif [ "$mediahelper" = "artsd" ]; then
		# Overwrite users mcoprc
		echo -n "GlobalComm=Arts::X11GlobalComm" > $HOME/.mcoprc
		if [ "$ENABLE_ARTSD_PRELOAD" = "1" -a \
				-x "$ARTSD_BIN_PRELOAD" ]; then
			node_app="$ARTSD_BIN_PRELOAD $node_app"
			echo "Info: NXNODE - Using $ARTSD_BIN_PRELOAD wrapper script." >> "$NXSESSION_DIRECTORY/session"
		fi
	fi

	[ "$ENABLE_CUPS_SERVER_MODE" = "1" ] && {
		cups_server_socket=$(LC_ALL=C /usr/bin/lpstat -H 2>/dev/null)
		[ -r $cups_server_socket ] || cups_server_socket=""
	} || cups_server_socket="$NXSESSION_DIRECTORY/cups/cups.sock"
	[ "$ENABLE_CUPS_SERVER_EXPORT" = "1" -a -n "$cups_server_socket" ] && {
		[ "$cups" = "1" -o "$samba" = "1" ] && {
			nxlog "$FUNCNAME ($$): export CUPS_SERVER=$cups_server_socket"
			export CUPS_SERVER="$cups_server_socket"
		}
	}
	if [ "$ENABLE_SAMBA_PRELOAD" = "1" -a -x "$PATH_BIN/nxredir" ]; then
		let NXSAMBA_PORT=$display+3000
		export NXSAMBA_PORT
		nxlog "$FUNCNAME ($$): Preload SAMBA using nxredir. NXSAMBA_PORT is \"$NXSAMBA_PORT\""
		node_app="$PATH_BIN/nxredir $node_app"
		echo "Info: NXNODE - Using nxredir wrapper script to forward SMB ports 139 and 445 to port $NXSAMBA_PORT." >> "$NXSESSION_DIRECTORY/session"
	fi


	# Do we need to PRELOAD any libraries?
	[ "$virtualdesktop" = "0" -a "$rootless" != "1" ] && export LD_PRELOAD="$APPLICATION_LIBRARY_PRELOAD:$LD_PRELOAD"

	# Should we start a window manager?
	if [ "$virtualdesktop" = "1" -a "$type" = "unix-application" -a \
			-x "$DEFAULT_X_WM" ]; then
		nxlog "$FUNCNAME ($$): start a window manager - \"DISPLAY=:$display $DEFAULT_X_WM\""
		DISPLAY=:$display $DEFAULT_X_WM >>"$NXSESSION_DIRECTORY/session" 2>&1 &
		node_wm_pid=$!
		nxlog "$FUNCNAME ($$): node_wm_pid='$node_wm_pid'}"
	fi

	# Use Xsession to execute the Desktop session
	case $type in
		unix-gnome)
			export STARTUP="$node_app"
			if [ "$login_method" = "GUEST" ]; then
				node_app=$COMMAND_GUEST_X_SESSION
			elif [ "$BOOTSTRAP_X_SESSION" = "1" ]; then
				node_app=$COMMAND_GDM_X_SESSION
			fi
		;;
		unix-kde|unix-cde)
			export STARTUP="$node_app"
			if [ "$login_method" = "GUEST" ]; then
				node_app=$COMMAND_GUEST_X_SESSION
			elif [ "$BOOTSTRAP_X_SESSION" = "1" ]; then
				node_app=$DEFAULT_X_SESSION
			fi
		;;
	esac

	[ $ENABLE_ROOTLESS_TERMINATE_SESSION = "1" -a "$rootless" = "1" ] && {
		napp=$(cutfn "$node_app" " " 0); napp=$(cutfn "$napp" "/" -1)
		second_app=$(rematchfn "$napp:(.+)" "${APP_WAIT_MAP//;/$'\n'}") #"
		[ -n "$second_app" ] && {
			sapp_pids0=$(ps -wo pid= -C $(cutfn "$second_app" "/" -1))
			nxlog "$FUNCNAME ($$): PID of $second_app will be waiting too. Initial: \"$sapp_pids0\""
		}
	}

	# Startup the application
	nxlog "$FUNCNAME ($$): Starting node_app with /etc/nxserver/Xsession"
	DISPLAY=:$display /etc/nxserver/Xsession $node_app >> \
		"$NXSESSION_DIRECTORY/session" 2>&1 &
	node_app_pid=$!
	nxlog "$FUNCNAME ($$): Start successful. node_app_pid='$node_app_pid'"

	mkdir -p "$NXSESSION_DIRECTORY/pids/"
	echo "$node_app_pid" >"$NXSESSION_DIRECTORY/pids/apps/$node_app_pid"
	nxlog "$FUNCNAME ($$): Waiting for node_app_pid"
	wait $node_app_pid
	nxlog "$FUNCNAME ($$): node_app_pid finished"

	# Kill or wait for the started window manager
	[ -n "$node_wm_pid" ] && {
		nxlog "$FUNCNAME ($$): node_wm_pid is not empty"
		# kill the WM after application is finished?
		[ "$KILL_DEFAULT_X_WM" = "1" ] && { nxlog "$FUNCNAME ($$): killing $node_wm_pid"
			kill $node_wm_pid 2>/dev/null; }
		# or just wait until it finishes?
		[ "$KILL_DEFAULT_X_WM" = "1" ] || { nxlog "$FUNCNAME ($$): wait for $node_wm_pid is dead"
			wait $node_wm_pid; }
	}
	nxlog "$FUNCNAME ($$): Clean pids/apps/$node_app_pid"
	rm -f "$NXSESSION_DIRECTORY/pids/apps/$node_app_pid"
	sleep "$NODE_APP_WAIT_TIMEOUT"

	[ $ENABLE_ROOTLESS_TERMINATE_SESSION = "1" -a "$rootless" = "1"  ] && {
		if [ -n "$second_app" ] ; then
			sapp_pids1=$(ps -wo pid= -C $(cutfn "$second_app" "/" -1))
			while read spid; do
				stringinstring "$spid" "$sapp_pids0" && continue
				sapp_pids+="${sapp_pids:+$' '}$spid"
			done <<< "$sapp_pids1"
			nxlog "$FUNCNAME ($$): Waiting for $second_app PID(S) \"$sapp_pids\""
			while [ -n "$(ps -o pid= -p $sapp_pids 2>/dev/null)" ]; do
				sleep 1s
			done
			nxlog "$FUNCNAME ($$): PID(S) \"$sapp_pids\" finished"
			node_terminate_session "$sess_id"
		else  node_terminate_session "$sess_id"
		fi
	}

	# Do not terminate agent in case of rootless agent mode.
	# The agent times out after a while by itself anyway.
	if [ "$virtualdesktop" = "1" -o "$rootless" != "1" ] ; then
		nxlog "$FUNCNAME ($$): Call node_terminate_agent for non-rootless or virtualdesktop session type"
		nxlog "$FUNCNAME ($$): Call 'node_terminate_agent \"$sess_id\"'"
		node_terminate_session "$sess_id"
	fi
	nxlog "$FUNCNAME ($$): end"
}


# node_persistent_session
# Is the user allowed to run a persistent session?
node_agent_persistent_session() {
	local username oifs p
	p="-nopersistent"
	# Guest sessions are always nonpersistent
	if [ "$login_method" = "GUEST" ]; then
		echo "$p"; return
	fi
	oifs=$IFS; IFS=","
	if [ "$ENABLE_PERSISTENT_SESSION" = "all" ]; then p="-persistent"
	else
		for username in $ENABLE_PERSISTENT_SESSION; do
			[ "${username:0:1}" != "@" ] && [ "$USER" = "$username" ] && \
				p="-persistent" && break;
			[ "${username:0:1}" = "@" ] && \
				[ -z $(groups "$USER" | egrep "^${username:1}:") ] && \
					p="-persistent" && break;
		done
	fi
	for username in $DISABLE_PERSISTENT_SESSION; do
		[ "${username:0:1}" != "@" ] && [ "$USER" = "$username" ] && \
			p="-nopersistent" && break;
		[ "${username:0:1}" = "@" ] && \
			[ -z $(groups "$USER" | egrep "^${username:1}:") ] && \
				p="-nopersistent" && break;
	done
	IFS=$oifs; echo "$p"
}

# node_start_agent
node_start_agent() {
	# Ok, now we do some wicked fd magic.
	# first part:	nxagent's fd #2 -> fd #3
	# second part:	fd #1 -> #4; fd #3 -> #1; tee | node_start_monitor
	# third part:	fd #4 -> #1
	# => all output of nxagent goes to tee | node_start_monitor, while
	#    leaving all other output flow through like normally.

	# preparations
	local k g b r fp vncfullscreen u p d agent_port viewonly
	local node_agent_exit_status node_failed
	nxlog "$FUNCNAME ($$): starting"
	exec 3>&2; exec 4>&1;

	{

	{

	# Setup environment
	if [ "$ENABLE_SOURCE_PROFILE" = "1" ]; then
		nxlog "$FUNCNAME ($$): source profile"
		. /etc/profile
	fi
	if [ "$ENABLE_SOURCE_BASH_PROFILE" = "1" ]; then
		nxlog "$FUNCNAME ($$): source bash profile"
		[ -f ~/.bash_profile ] && . ~/.bash_profile
		[ -f /etc/bashrc ] && . /etc/bashrc
	fi

	export DISPLAY="nx/nx,options=$NXSESSION_DIRECTORY/options:$display"
	export XAUTHORITY="$NXSESSION_DIRECTORY/authority"
	export HOME="$USER_FAKE_HOME"
	export NX_CLIENT="$PATH_BIN/nxdialog"

	# Setup optional parameters for nxagent
	# keyboard
	k=""
	# backwards compatibility
	[ -n "$keyboard" ] && k="-keyboard $keyboard"
	[ -n "$kbtype" ] && k="-kbtype $kbtype"

	# backingstore
	b=""
	if [ -n "$backingstore" -a "$ENABLE_1_5_0_BACKEND" = "1" ]; then
		[ "$backingstore" != 1 ] && b="-bs $backingstore"
		[ "$backingstore" = 1 ] && b="+bs"
	fi

	# geometry
	g=""
	[ -n "$geometry" ] && g="-geometry $geometry"

	# type of session
	r="-D"; [ "$rootless" = "1" ] && r="-R"

	# Setup fullscreen parameters
	vncfullscreen=""
	[ "$geometry" = "fullscreen" -a "$type" = "vnc" ] && \
		vncfullscreen="-fullscreen" && g=""
	[ "$geometry" = "fullscreen" -a "$type" = "windows" ] && \
		g="-geometry $(rematchfn '^([[:digit:]]+x[[:digit:]]+)' $screeninfo)"

	# Start the wanted nxagent
	if [ "$type" = "windows" ]; then
		nxlog "$FUNCNAME ($$): Type \"windows\""
		# nxdesktop session (Windows RDP)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup optional parameters
		u=""; p=""; d=""
		[ -n "$agent_user" ] && u="-u $agent_user"
		[ -n "$agent_password" ] && p="-p -"
		[ -n "$agent_domain" ] && d="-d $agent_domain"
		# Start the agent
		echo "$agent_password" | $PATH_BIN/nxdesktop \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" \
			$k $g $u $p $d $agent_server $AGENT_EXTRA_OPTIONS_RDP 2>&3 &

	elif [ "$type" = "vnc" ]; then
		nxlog "$FUNCNAME ($$): Type \"vnc\""
		# nxviewer session (VNC RFB)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup password
		mkdir -p "$NXSESSION_DIRECTORY/scripts/"
		echo "$agent_password" | $PATH_BIN/nxpasswd \
			"$NXSESSION_DIRECTORY/scripts/.passwd" doit
		# Start x11vnc
		if [ -n "$shadowdisplay" ]; then
			(
				viewonly=""
				[ "$ENABLE_INTERACTIVE_SESSION_SHADOWING" != "1" ] && \
					viewonly="-viewonly"
				DISPLAY="$shadowhost:$shadowdisplay" x11vnc -localhost \
					$viewonly -timeout 120 -rfbauth \
					"$NXSESSION_DIRECTORY/scripts/.passwd" \
					>"$NXSESSION_DIRECTORY/scripts/.vnc_port" 2>&3 &
			)
			local cntr="40"
			while [ ! -f $NXSESSION_DIRECTORY/scripts/.vnc_port ]; do
				sleep 0.05s; ((cntr--)); ((cntr<=0)) && break
			done
			agent_port=$(< $NXSESSION_DIRECTORY/scripts/.vnc_port)
			agent_port=$(rematchfn '^PORT=[[:space:]]*([[:digit:]]+)' $agent_port) #'
			[ -z "agent_port" ] && agent_port="0"
			# note the :: is not a mistake, but rather a hint for nxviewer
			# to use this as a port and not interpret it as a display.
			agent_server="127.0.0.1::$agent_port"
			rm -f "$NXSESSION_DIRECTORY/scripts/.vnc_port"
		fi
		# Start the agent
		$PATH_BIN/nxviewer -encodings tight hextile copyrect raw \
			-passwd "$NXSESSION_DIRECTORY/scripts/.passwd" \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" $vncfullscreen \
			$g $k $agent_server $AGENT_EXTRA_OPTIONS_RFB 2>&3 &
	elif [ "$r" = "-R" -a "$rootless" != "1" ]; 	then
		# nxproxy single application mode session
		nxlog "$FUNCNAME ($$): Start nxproxy for single application session mode"
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$PROXY_LIBRARY_PATH:$LD_LIBRARY_PATH"
		nxlog "$FUNCNAME ($$): Start nxproxy by command: '$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS'"
		$PATH_BIN/nxproxy -C :$display $PROXY_EXTRA_OPTIONS 2>&3 &
	else
		nxlog "$FUNCNAME ($$): NXAgent session type"
		# nxagent session (X11)
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && \
			export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		# Setup optional parameters
		p=$(node_agent_persistent_session)
		fp=""; [ -n "$AGENT_FONT_SERVER" ] && fp="-fp $AGENT_FONT_SERVER"
		if [ "$type" = "shadow" ]; then
			nxlog "$FUNCNAME ($$): Type \"shadow\". Add some args to nxagent"
			r="-S -shadow $shadowhost:$shadowdisplay -shadowmode $ENABLE_INTERACTIVE_SESSION_SHADOWING"
			p="-nopersistent"
		fi
		# Start the agent
#		nxlog "$FUNCNAME ($$): env start `env`"
#		nxlog "$FUNCNAME ($$): env end"
		nxlog "$FUNCNAME ($$): Start nxagent by command: '$COMMAND_NXAGENT $p $r -name \"NX - $user@$SERVER_NAME:$display - $session (GPL Edition)\" -option \"$NXSESSION_DIRECTORY/options\" $b $fp $AGENT_EXTRA_OPTIONS_X :$display'"
		#PATH="$PATH_BIN:$PATH" $COMMAND_NXAGENT $p $r -name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" -option "$NXSESSION_DIRECTORY/options" $k $g $b $fp $AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
		PATH="$PATH_BIN:$PATH" $COMMAND_NXAGENT $p $r \
			-name "NX - $user@$SERVER_NAME:$display - $session (GPL Edition)" \
			-option "$NXSESSION_DIRECTORY/options" $b $fp \
			$AGENT_EXTRA_OPTIONS_X :$display 2>&3 &
	fi

	# Wait for the agent
	node_agent_pid=$!
	mkdir -p "$NXSESSION_DIRECTORY/pids/"
	echo "$node_agent_pid" >"$NXSESSION_DIRECTORY/pids/agent"
	nxlog "$FUNCNAME ($$): Wait for node_agent_pid='$node_agent_pid'"
	wait $node_agent_pid
	node_agent_exit_status=$?
	nxlog "$FUNCNAME ($$): node_agent_exit_status='$node_agent_exit_status'"
	node_failed=""
	if [ $node_agent_exit_status -ne 0 ]; then
		echo "NX> 1004 Error: NX Agent exited with exit status 1. To troubleshoot set SESSION_LOG_CLEAN=0 in node.conf and investigate \"$USER_FAKE_HOME/.nx/F-C-$sess_id/session\". You might also want to try: ssh -X myserver; $PATH_BIN/nxnode --agent to test the basic functionality. Session log follows:"
		echo "$(< $NXSESSION_DIRECTORY/session)" >&2
		node_failed="failed"
		nxlog "$FUNCNAME ($$): node_failed='$node_failed'"
	fi
	nxlog "$FUNCNAME ($$): close session"
	echo "NX> 1006 Session status: closed"

	# Cleanup session information
	nxlog "$FUNCNAME ($$): cleanup session information '$sess_id'"
	nxlog "$FUNCNAME ($$): remove agent pidfile -- '$NXSESSION_DIRECTORY/pids/agent'"
	rm -f "$NXSESSION_DIRECTORY/pids/agent"
	nxlog "$FUNCNAME ($$): call 'node_terminate_session \"$sess_id\" \"$node_failed\"'"
	node_terminate_session "$sess_id" "$node_failed"

	# remove possible leftovers of nxagent
	nxlog "$FUNCNAME ($$):remove /tmp/.X$display-lock"
	rm -f /tmp/.X$display-lock
	nxlog "$FUNCNAME ($$): remove /tmp/.X11-unix/X$display"
	rm -f /tmp/.X11-unix/X$display

	} 3>&1 1>&4 | tee "$NXSESSION_DIRECTORY/session" | \
		node_start_monitor; } 4>&1
}

try_remount_printers() {
# args: none
# if found another running session with same smb/ipp-printers,
# try to remount from current, else - umount
	nxlog "$FUNCNAME ($$): starting."
	local spname type mport new_port new_dir desc_fn descstr device_uri prstr;
	local share upass username password model defaultPrinter cmdstr id drv pname;
	local sessdir="$USER_FAKE_HOME/.nx/C-$sess_id"
	local scr_dir="$sessdir/scripts"
	[ ! -d "$sessdir" ] && { nxlog "$FUNCNAME ($$): Dir sessdir='$sessdir' NOT FOUND! Calling twice? Why?"
		return 1; }
	for spname in $scr_dir/@p@* ; do
		[ "$spname" = "*" ] && { nxlog "$FUNCNAME ($$): No printers found. end."
			return 1; }
		pname=$(cutfn "$spname" "/" -1); pname=${pname/@p@/}
		nxlog "$FUNCNAME ($$): process printer \"$pname\", search in system cups."
		prstr=$(LC_ALL=C /usr/bin/lpstat -v "$pname" 2>/dev/null)
		[ -z "$prstr" ] && { nxlog "$FUNCNAME ($$): printer \"$pname\" NOT FOUND in system cups"
			continue;
		}
		[ -n "$(rematchfn '(ipp)://' "$prstr")" ] && type="ipp" || type="smb"
		mport=$(get_mport2sessdir "$sessdir" "$type")
		[ -z "$(rematchfn ':('$mport')/' "$prstr")" ] && { nxlog "$FUNCNAME ($$): printer \"$pname\" has mport rather than $mport, skiping."
			continue; }
		# printer already present at own mport
		nxlog "$FUNCNAME ($$): printer \"$pname\" (port:$mport) found - deleting"
		/usr/bin/sudo /usr/sbin/lpadmin -x "$pname"
		new_dir=$(get_sessdir4res "@p@$pname")
		[ -z "$new_dir" ] && { nxlog "$FUNCNAME ($$): no running sessions found for printer \"$pname\", stop remounting"
			continue;
		}
		new_port=$(get_mport2sessdir "$new_dir" "$type")
		desc_fn="$USER_FAKE_HOME/.nx/shares_priv/@p@$pname"
		[ -r "$desc_fn" ] || { nxlog "$FUNCNAME ($$): description file \"$desc_fn\" for printer \"$pname\" NOT ACCESSIBLE, stop remounting"
			continue; }
		descstr=$(< $desc_fn)
		device_uri=$(cutfn "$descstr" "&" 1)
		device_uri=${device_uri/:$mport/:$new_port}
		share=$(cutfn "$device_uri" "/" -1)
		upass=$(cutfn "$(cutfn "$device_uri" "/" 2)" "@" 0) #"
		username="$(cutfn "$upass" ":" 0)"
		password="$(cutfn "$upass" ":" 1)"
		#[ "$type" = "ipp" ] && {
		#	newpass=$(cat "$new_dir/scripts/@p@$pname" 2>/dev/null)
		#	[ ! -z "$newpass" ] && { nxlog "$FUNCNAME ($$): new password for printer \"$pname\" ARE LOST, stop remounting"
		#	continue;
		#	}
		#	device_uri=${device_uri/:$password/:$newpass}
		#	password="$newpass"
		#}
		[ "$(check_remote_printer $type $share $new_port $username $password)" \
				= "0" ] && { nxlog "$FUNCNAME ($$): smb/cifs-share \"$share\" for printer \"$pname\" NOT ACCESSIBLE, stop remounting"
			continue;
		}
		model=$(cutfn "$descstr" "&" 0)
		defaultPrinter=$(cutfn "$descstr" "&" 3)
		if [ -r "$model" ]; then # ppd only
			cmdstr="/usr/bin/sudo /usr/sbin/lpadmin -p $pname -P $model -v $device_uri -E"
		else # foomatic
			id="$model"; drv=$(cutfn "$descstr" "&" 4)
			cmdstr="/usr/bin/sudo /usr/bin/foomatic-configure -s cups -n $pname -p $id -d $drv -c $device_uri -q"
		fi
		nxlog "$FUNCNAME ($$): invoke $cmdstr"
		$cmdstr
		if [ $? -eq 0 ]; then
			nxlog "$FUNCNAME ($$): printer \"$pname\" installed"
			[ "$type" = "ipp" ] && {
				descstr=${descstr/:$mport/:$new_port}
				echo "$descstr" > "$desc_fn"
			}
			public=$(cutfn "$descstr" "&" 2)
			[ -n "$public" ] && { /usr/bin/sudo /usr/sbin/lpadmin -p $pname $public;
				[ $? -ne 0 ] && nxlog "$FUNCNAME ($$): FAILED to set options \"$public\" for printer \"$pname\""
			}
			[ "$defaultPrinter" = "1" ] && {
				/usr/bin/sudo /usr/sbin/lpadmin -d "$pname";
				[ $? -ne 0 ] && nxlog "$FUNCNAME ($$): FAILED to set default printer \"$pname\""
			}
		else
			nxlog "$FUNCNAME ($$): FAILED to reinstall printer \"$pname\""
		fi
	done
	nxlog "$FUNCNAME ($$): end."
}

# node_cupsd_stop
# Used glob vars: $sess_id
node_cupsd_stop() {
# dimbor: if system cupsd is used, we try to remove/remount printers
	if [ "$ENABLE_CUPS_SERVER_MODE" = "1" ]; then
		nxlog "$FUNCNAME ($$): starting with  ENABLE_CUPS_SERVER_MODE = 1, call try_remount_printers()"
		try_remount_printers
		nxlog "$FUNCNAME ($$): end"
		return
	fi

	# original behaviour
	# Cleanup userspace cups daemon
	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] || return
	NODE_CUPSD_PID=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd")
	# Check for a running userspace cupsd, look if its still active
	# and kill it if so
	( [ -n "$NODE_CUPSD_PID" ] && kill -0 $NODE_CUPSD_PID && kill $NODE_CUPSD_PID && sleep 2 && kill -0 $NODE_CUPSD_PID && kill -9 $NODE_CUPSD_PID ) 2>/dev/null
	# delete pid file
	rm -f "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
	# remove all printers
	echo >"$USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf"
	[ -z "$KDE_PRINTRC" ] || sed "s|^Host=$USER_FAKE_HOME/.nx/C-$sess_id/cups/cups.sock||" -i "$KDE_PRINTRC"
}

# node_cupsd_setup
# Used glob vars: $sess_id, $display
node_cupsd_setup() {
	let NODE_CUPSD_PORT=$display+9000 # offset 9000 for userspace cupsd's
	export NODE_CUPSD_PORT
	export NODE_CUPSD_SOCKET="$USER_FAKE_HOME/.nx/C-$sess_id/cups/cups.sock"
	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/pids/"
	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] && return
	touch "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/certs" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/ppd" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cache"
	mkdir -p "$USER_FAKE_HOME/.nx/C-$sess_id/cups/log" #JJK cups log file home
#JJK: Modifications to cupsd.conf
#JJK:   - Added SystemGroup line in order to add $USER to SystemGroup
#JJK:   - Moved all the log files to log/<log>
#JJK:   - Set AccessLog to: log/access_log (was /dev/null)
#JJK:   - Added listening on $NODE_CUPSD_PORT
#JJK:			 Listen localhost: $NODE_CUPSD_PORT
#JJK:   - Removed following line because directive is specific to Debian
#JJK:       PidFile $USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd
#JJK:   -  Access restrictions borrowed from /etc/cups/cupsd.conf
#JJK:   -  Default policy borrowed from /etc/cups/cupsd.conf but modified
#JJK:        to allow Add, Delete, and Default printer without (password)
#JJK:        authentication
#JJK:   - Note for more detailed logging set: LogLevel debug

CUPSPidFileString="PidFile $USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"
if [ "$CUPS_PidFile" == "0" ] ; then
	CUPSPidFileString=""
fi

cat <<EOF > $USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf
SystemGroup sys root $USER
AccessLog log/access_log
ErrorLog log/error_log
PageLog log/page_log
LogLevel $CUPSLogLevel
TempDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool/tmp
RequestRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/spool
ServerRoot $USER_FAKE_HOME/.nx/C-$sess_id/cups/
StateDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/
CacheDir $USER_FAKE_HOME/.nx/C-$sess_id/cups/cache

Listen localhost:$NODE_CUPSD_PORT
Listen $NODE_CUPSD_SOCKET
Browsing Off
ServerName localhost
$CUPSPidFileString

#JJK:  Restrict access to the server...
<Location />
Order Deny,Allow
Deny From All
Allow from 127.0.0.1
</Location>

#JJK: Restrict access to the admin pages...
<Location /admin>
  Encryption Required
  Order allow,deny
  Allow localhost
</Location>

#JJK: Restrict access to configuration files...
<Location /admin/conf>
  AuthType Basic
  Require user @SYSTEM
  Order allow,deny
  Allow localhost
</Location>

# Allow everything for anonymous, because we are protected through UNIX socket
#JJK: Since allowing access via $NODE_CUPSD_PORT, need to add protection
<Policy default>
  #JJK: Job-related operations must be done by the owner or an adminstrator...
  <Limit Send-Document Send-URI Hold-Job Release-Job Restart-Job Purge-Jobs Set-Job-Attributes Create-Job-Subscription Renew-Subscription Cancel-Subscription Get-Notifications Reprocess-Job Cancel-Current-Job Suspend-Current-Job Resume-Job CUPS-Move-Job>
	Require user @OWNER @SYSTEM
	Order deny,allow
  </Limit>

  #JJK:All administration operations require an adminstrator to authenticate...
  <Limit Pause-Printer Resume-Printer Set-Printer-Attributes Enable-Printer Disable-Printer Pause-Printer-After-Current-Job Hold-New-Jobs Release-Held-New-Jobs Deactivate-Printer Activate-Printer Restart-Printer Shutdown-Printer Startup-Printer Promote-Job Schedule-Job-After CUPS-Add-Class CUPS-Delete-Class CUPS-Accept-Jobs CUPS-Reject-Jobs>
	AuthType Basic
	Require user @SYSTEM
	Order deny,allow
  </Limit>

  #JJK: Except need to allow these for nxnode to work
  <Limit CUPS-Add-Printer CUPS-Delete-Printer CUPS-Set-Default>
	Order deny,allow
  </Limit>

  # Only the owner or an administrator can cancel or authenticate a job...
  <Limit Cancel-Job CUPS-Authenticate-Job>
	Require user @OWNER @SYSTEM
	Order deny,allow
  </Limit>

  <Limit All>
	AuthType None
	Order deny,allow
  </Limit>
</Policy>
EOF

	touch "$USER_FAKE_HOME/.nx/C-$sess_id/cups/printers.conf" "$USER_FAKE_HOME/.nx/C-$sess_id/cups/classes.conf"

	#JJK: Also copy over pstoraster.convs
	cp -af "$CUPS_ETC"/mime.* "$CUPS_ETC"/pstoraster.convs "$USER_FAKE_HOME/.nx/C-$sess_id/cups/"

	# start cupsd
#JJK: Note the directive PidFile in the original cupsd.conf intended for
#JJK: recording the pid is a Debianism. Instead, we will use the non-daemon
#JJK: form of cupsd and capture the pid directly
#JJK:	$COMMAND_CUPSD -c "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf" &>/dev/null </dev/null
	$COMMAND_CUPSD -F -c "$USER_FAKE_HOME/.nx/C-$sess_id/cups/cupsd.conf" &>/dev/null </dev/null &
	NODE_CUPSD_PID=$!
	echo $NODE_CUPSD_PID >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd"

	# setup KDE
	if [ "$ENABLE_KDE_CUPS" = "1" -a -e "$KDE_PRINTRC" ]; then
		if egrep -q "^Host=" "$KDE_PRINTRC"; then
			[ "$ENABLE_KDE_CUPS_DYNAMIC" = "1" ] && sed -i -e 's|^Host=.*|Host=\$('"$PATH_BIN/nxcups-gethost"')|g' "$KDE_PRINTRC"
			[ "$ENABLE_KDE_CUPS_DYNAMIC" != "1" ] && sed -i -e 's|^Host=.*|Host='"$NODE_CUPSD_SOCKET"'|g' "$KDE_PRINTRC"
		else
			echo "[CUPS]" >> "$KDE_PRINTRC"
			[ "$ENABLE_KDE_CUPS_DYNAMIC" = "1" ] && echo "Host[\$ie]=\$($PATH_BIN/nxcups-gethost)" >> "$KDE_PRINTRC"
			[ "$ENABLE_KDE_CUPS_DYNAMIC" != "1" ] && echo "Host=$NODE_CUPSD_SOCKET" >> "$KDE_PRINTRC"
		fi
	fi
}

# node_cupsd_reload
# Used glob vars: $sess_id
node_cupsd_reload() {
	local node_cupsd_pid
	[ -e "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd" ] || return
	node_cupsd_pid=$(cat "$USER_FAKE_HOME/.nx/C-$sess_id/pids/cupsd")
	[ -n "$node_cupsd_pid" ] && \
		kill -0 $node_cupsd_pid && kill -HUP $node_cupsd_pid
}

node_cupsd_get_socket() {
	# dimbor: for use system cupsd
	[ "$ENABLE_CUPS_SERVER_MODE" = "1" ] && { \
		echo "$CUPS_DEFAULT_SOCK"; return;
	}
	node_cupsd_setup
	echo $NODE_CUPSD_SOCKET
}

create_mountpoint() {
# creates directory and checks its attrs
#params: dir owner group
	local errstr logstr duser dgroup dacr;
	[ ! -e "$1" ] && {
		errstr=$(mkdir -p "$1" 2>&1)
		[ $? -ne 0 ] && {
			echo "Unable to create \"$1\". Error: \"$errstr\""; return 1
		} || echo "\"$1\" successfully created."
	} || echo "\"$1\" already exist."
	duser=$(stat -c %U "$1"); dgroup=$(stat -c %G "$1")
	[ "$duser" != "$2" -o "$dgroup" != "$3" ] && {
		logstr="\"$1\" ($duser:$dgroup). Attempt to change owners to $2:$3 - "
		errstr=$(chown "$2:$3" "$1" 2>&1)
		[	 $? -ne 0 ] && {
			echo "$logstr - FAILED! Error: \"$errstr\""; return 1
		} || echo "$logstr - successfully completed."
	}
	dacr=$(stat -c %a "$1")
	[ "$dacr" != "770" ] && {
		logstr="\"$1\" ($dacr). Attempt to change access rights to 0770 - "
		errstr=$(chmod 0770 "$1" 2>&1)
		[ $? -ne 0 ] && {
			echo "$logstr - FAILED! Error: \"$errstr\""; return 1
		} || echo "$logstr - successfully completed."
	}
	return 0
}

usermount_enable() {
# check if available starting mode of mount/umount.cifs
	local ret=1 logstr0="$FUNCNAME ($$):" ostr rc
	ostr=$(stat -c %a "$COMMAND_SMBMOUNT" 2>&1); rc=$?
	[ $rc -ne 0 ] && { nxlog "$logstr0 $ostr"; ret="0"; }
	[ "$ret" != "0" ] && [ "$ostr" != "4711" -a "$ostr" != "4755" ] && { ret="0"
		nxlog "$logstr0 Permissions of $COMMAND_SMBMOUNT ($ostr) != 4711 or 4755. Mounting in user-mode is disabled."
	}
	[ "$ret" != "0" -a $rc -eq 0 ] && {
		ostr=$($COMMAND_SMBMOUNT 2>&1)
		stringinstring "setuid root program disabled" "$ostr" && {
			nxlog "$logstr0 $ostr"; ret="0";
		}
	}
	ostr=$(stat -c %a "$COMMAND_SMBUMOUNT" 2>&1); rc2=$?
	[ $rc2 -ne 0 ] && { nxlog "$logstr0 $ostr"
		ret="0"; rc=$rc2; }
	[ "$ret" != "0" ] && [ "$ostr" != "4711" -a "$ostr" != "4755" ] && { ret="0"
		nxlog "$logstr0 Permissions of  $COMMAND_SMBUMOUNT ($ostr) != 4711 or 4755. Umounting in user-mode is disabled."
	}
	echo $ret; return $rc
}

sudomount_enable() {
# checks available starting mode with sudo of mount/umount.cifs
	local ret=1 logstr0="$FUNCNAME ($$):" ostr rc
	ostr=$(/usr/bin/sudo -l 2>&1); rc=$?
	if [ $rc -ne 0 ]; then nxlog "$logstr0 $ostr"; ret=0
	else
		[ -z "$(rematchfn "NOPASSWD.+($COMMAND_SMBMOUNT)" "$ostr")" ] && { #"
			ret=0
			nxlog "$logstr0 Mounting with sudo is disabled. To enable, you must to change etc/sudo.d/nxserver or etc/sudoers file."
		}
		[ -z "$(rematchfn "NOPASSWD.+($COMMAND_SMBUMOUNT)" "$ostr")" ] && { #"
			ret=0
			nxlog "$logstr0 Umounting with sudo is disabled. To enable, you must to change etc/sudo.d/nxserver or etc/sudoers file."
		}
	fi
	echo $ret; return $rc
}

try_mount_smb() {
# params: sharename(1), mountpoint(2), smb-username(3), port(4),
# ex-options/uid,gid/(5), smb-password(6)
	local rc=1 smb_opts error mntstr
	nxlog "$FUNCNAME ($$): Starting: try_user='$try_user', try_sudo='$try_sudo'}"
	[ -n "$SMB_MOUNT_OPTIONS" -a "${SMB_MOUNT_OPTIONS:0:1}" != "," ] && \
		SMB_MOUNT_OPTIONS=",$SMB_MOUNT_OPTIONS"
	smb_opts="username=$3,"
	[ -n "$6" ] && smb_opts="$smb_opts""password=$6," || \
		smb_opts="$smb_opts""password=,"
	smb_opts="$smb_opts""ip=127.0.0.1,port=$4$SMB_MOUNT_OPTIONS"
	[ $try_user -ne 0 ] && {
		mntstr="$COMMAND_SMBMOUNT $1 $2 -o $smb_opts"
		nxlog "$FUNCNAME ($$): invoke $mntstr 2>&1"
		error=$($mntstr 2>&1); rc=$?
		[ $rc -ne 0 ] && nxlog "$FUNCNAME ($$): Mount error: \"$error\""
	}
	[ $try_sudo -ne 0 -a $rc -ne 0 ] && {
		mntstr="/usr/bin/sudo $COMMAND_SMBMOUNT $1 $2 -o $5$smb_opts"
		nxlog "$FUNCNAME ($$): invoke $mntstr 2>&1"
		error=$($mntstr 2>&1); rc=$?
		[ $rc -ne 0 ] && nxlog "$FUNCNAME ($$): Mount error: \"$error\""
	}
	[ $rc -eq 0 ] && nxlog "$FUNCNAME ($$): Finished successfully."
	return $rc
}

try_umount_smb() {
# param: mountpoint
	local amnt=3 cn=0 logstr0="$FUNCNAME ($$):" ostr;
	local logstr1 logstr2 rc=0 i ffl;
	nxlog "$logstr0 Starting arg \"$1\". try_user='$try_user', try_sudo='$try_sudo', remain $amnt attempts."
	for (( i=$amnt; $i; --i )); do
		if stringinstring "$1" "$(mount)"; then
			((i<amnt/2)) && { ffl="-f"; logstr1="$logstr0 force (-f)";
			} || { ffl=""; logstr1="$logstr0"; }
			rc=1; (( cn++ ))
			[ $try_user -ne 0 ] && {
				logstr2="$logstr1"" umount attempt #$cn \"$1\" in user-mode"
				ostr=$($COMMAND_SMBUMOUNT $ffl "$1" 2>&1); rc=$?
				[ $rc -eq 0 ] && { nxlog "$logstr2 completed succesfully."
					break;} || nxlog "$logstr2 FAILED. Error: \"$ostr\""
			}
			[ $try_sudo -ne 0 -a $rc -ne 0 ] && {
				logstr2="$logstr1"" umount attempt #$cn \"$1\" with sudo"
				ostr=$(/usr/bin/sudo $COMMAND_SMBUMOUNT $ffl "$1" 2>&1); rc=$?
				[ $rc -eq 0 ] && { nxlog "$logstr2 completed succesfully."
					break; } || nxlog "$logstr2 FAILED. Error: \"$ostr\""
			}
		else
			nxlog "$logstr0 Mountpoint \"$1\" not mounted"
			return 0;
		fi
		sleep 0.5s
	done
	[ $rc -eq 0 ] && nxlog "$FUNCNAME ($$): Finished successfully."
	return $rc
}

node_umount_smb() {
	nxlog "$FUNCNAME ($$): starting with sess_id='$sess_id'"
	local scr_dir mport mpoints ssname sname desc_fn descstr new_dir new_port rc;
	local smbport fsname username password IDS_OPTS;
	scr_dir="$USER_FAKE_HOME/.nx/C-$sess_id/scripts"
	[ -r "$scr_dir/smbport" ] && \
		smbport=$(< $scr_dir/smbport)
	try_user=1; try_sudo=0;
	[ "$smbport" = "445" ] && {
		COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS; COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
		try_user=$(usermount_enable)
		try_sudo=$(sudomount_enable)
		[ $try_user -eq 0 -a $try_sudo -eq 0 ] && {
			nxlog "$FUNCNAME ($$): Any methods of (u)mounting are not available. Stop umounting."
			return 1;
		}
	}
	#dimbor: if sessions with same shares found, we try to remount them
	if [ "$ENABLE_SHARE_MULTIMOUNT" = "1" ]; then
		[ -r "$scr_dir/mport" ] && mport=$(< $scr_dir/mport)
		[ -r "$scr_dir/mpoint" ] && \
			mpoints=$(< $scr_dir/mpoint) \
		|| {
			nxlog "$FUNCNAME ($$): No shares controlled by session found. Stop remounting."
			return;
		}
		for ssname in $scr_dir/@s@*; do
			sname=$(cutfn "$ssname" "/" -1); sname=${sname/@s@/}
			desc_fn="$USER_FAKE_HOME/.nx/shares_priv/@s@$sname"
			[ ! -r "$desc_fn" ] && {
				nxlog "$FUNCNAME ($$): description file \"$desc_fn\" for share \"$sname\" NOT ACCESSIBLE, stop remounting it"
				continue;
			}
			descstr=$(< $desc_fn); mpoint=$(cutfn "$descstr" "&" 1)
			stringinstring "$mpoint" "$mpoints" || {
				nxlog "$FUNCNAME ($$): share \"$sname\" at \"$mpoint\" is not controlled by session. Stop remounting."
				continue;
			}
			try_umount_smb "$mpoint"; rc=$? # umount here
			[ $rc -ne 0 ] && {
				nxlog "$FUNCNAME ($$): mountpoint \"$mpoint\" failed to unmount."
				continue;
			}
			new_dir=$(get_sessdir4res "@s@$sname")
			[ -z "$new_dir" ] && {
				nxlog "$FUNCNAME ($$): no running sessions found for share \"$sname\", stop remounting"
				rmdir "$mpoint" >/dev/null 2>/dev/null; continue;
			}
			new_port=$(< $new_dir/scripts/mport)
			fsname=$(cutfn "$descstr" "&" 0)
			username=$(cutfn "$descstr" "&" 2)
			password=$(cutfn "$descstr" "&" 3)
			IDS_OPTS=$(cutfn "$descstr" "&" 4)
			try_mount_smb "$fsname" "$mpoint" "$username" $new_port "$IDS_OPTS" "$password"
			rc=$?
			[ $rc -eq 0 ] && {
				nxlog "$FUNCNAME ($$): share \"$fsname\" remount to \"$mpoint\""
				echo "$mpoint" >> "$new_dir/scripts/mpoint"
			} || {
				nxlog "$FUNCNAME ($$): share \"$fsname\" failed to remount: $error"
				rmdir "$mpoint" >/dev/null 2>/dev/null
			}
		done
		nxlog "$FUNCNAME ($$): end"
		return
	fi

	if [ -e "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint" ]; then
		nxlog "$FUNCNAME ($$): File scripts/mpoint present. Continue umounting..."
	else
		nxlog "$FUNCNAME ($$): File scripts/mpoint not present. Abort umounting..."
		return 1
	fi
	while read mpoint; do
		try_umount_smb "$mpoint"; rc=$? # umount here
		[ $rc -ne 0 ] && {
			nxlog "$FUNCNAME ($$): mountpoint \"$mpoint\" failed to unmount."
			continue;
		}
		nxlog "$FUNCNAME ($$): Remove mountpoint \"$mpoint\""
		rmdir "$mpoint" >/dev/null 2>/dev/null #JJK:Remove mount point if empty
	done < "$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mpoint"
	nxlog "$FUNCNAME ($$): end"
}

node_stop_services() {
	nxlog "$FUNCNAME ($$): starting"
	nxlog "$FUNCNAME ($$): call node_umount_smb"
	node_umount_smb
	nxlog "$FUNCNAME ($$): call node_cupsd_stop"
	node_cupsd_stop
	nxlog "$FUNCNAME ($$): call reconnect_pa"
	reconnect_pa
	nxlog "$FUNCNAME ($$): end"
}

node_emergency_exit() {
	nxlog "$FUNCNAME ($$): starting"
	# umount shares & stop printers
	nxlog "$FUNCNAME ($$): call node_stop_services"
	node_stop_services

	# kill the session
	nxlog "$FUNCNAME ($$): call 'node_terminate_session \"$sess_id\" \"failed\"'"
	node_terminate_session "$sess_id" "failed"

	echo "NX> 1004 Error: Emergency exit due to kill signal."
	nxlog "$FUNCNAME ($$): end"
}

# node_start_monitor <start|restore> <Running|Suspended>
# Monitoring the nxagent: Its also kind of a "state-machine"
#                         as it has to keep track of different
#                         connection states and react differently.
node_start_monitor() {
	nxlog "$FUNCNAME ($$): starting"
	local node_tail_pid="" node_suspend_status="$2";
	local smbmount_port media_port node_watchdog_pid tosend

	while read line; do
		# Catch tail pid
		if stringinstring "Info: tail -f running with pid" "$line"; then
			node_tail_pid=$(cutfn "$line" "'" 1)
			echo "$node_tail_pid" >"$USER_FAKE_HOME/.nx/C-$sess_id/pids/tail"
		elif stringinstring "Info: Listening * SMB connections on port" "$line"; then
			# Catch NXAGENT SMB Port (sometimes the port differs from what we got from nxserver)
			smbmount_port=$(cutfn "$line" "'" 1); smbmount_port=${smbmount_port##*:}
			echo "$smbmount_port" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mport"
		elif stringinstring "Info: Listening * multimedia connections on port" "$line"; then
			# Catch NXAGENT Multimedia Port
			media_port=$(cutfn "$line" "'" 1); media_port=${media_port##*:}
			echo "$media_port" >"$USER_FAKE_HOME/.nx/C-$sess_id/scripts/mmport"
		elif stringinstring "Session: Starting session at" "$line"; then
		# Session messages
			echo "NX> 1009 Session status: starting"
		elif stringinstring "Session: Suspending session at" "$line"; then
			echo "NX> 1009 Session status: suspending"
		elif stringinstring "Session: Terminating session at" "$line"; then
			echo "NX> 1009 Session status: terminating"
		elif stringinstring "Session: Resuming session at" "$line"; then
			echo "NX> 1009 Session status: resuming"
		elif stringinstring "Session: Session suspended at" "$line"; then
			# Session suspend
			echo "NX> 1005 Session status: suspended"
			# umount shares & stop printers
			if [ "$node_suspend_status" = "Running" ]; then
				nxlog "$FUNCNAME ($$): call 'node_suspend_session \"$sess_id\"'"
				node_suspend_session "$sess_id"
				node_suspend_status=""
			else
				nxlog "$FUNCNAME ($$): call node_stop_services"
				node_stop_services
			fi
		elif stringinstring "Info: Watchdog running with pid" "$line"; then
			# Watchdog termination
			node_watchdog_pid=$(cutfn "$line" "'" 1)
		elif stringinstring "Info: Waiting the watchdog process to complete." "$line"; then
			# Kill the watchdog
			kill $node_watchdog_pid 2>/dev/null
		elif stringinstring "Info: Waiting for connection from" "$line"; then
			tosend="NX> 700 Session id: $sess_id\n
NX> 705 Session display: $display\nNX> 703 Session type: $type
NX> 701 Proxy cookie: $proxy_cookie\nNX> 702 Proxy IP: $proxyip
NX> 706 Agent cookie: $cookie\nNX> 704 Session cache: $type
NX> 707 SSL tunneling: $encryption\n"
		# File-sharing port options
			if [ "$samba" = "1" -a -n "$smbport" ]; then
				tosend+="NX> 709 File-sharing port: $smbport\n"
			fi
			echo -e "$tosend""NX> 710 Session status: running\nNX> 1002 Commit\nNX> 1006 Session status: running"
		elif stringinstring "Session: Session resumed at" "$line"; then
			# Reconnection success!
			echo "NX> 718 Session restore succeded"
			if [ "$1" = "restore" ]; then
				kill $node_tail_pid
				break
			fi
		elif stringinstring "Session: Display failure detected at" "$line"; then
			# Reconnection failure
			if [ "$1" = "restore" ]; then
				echo "NX> 596 Error: Session $1 failed. Reason was: $line"
				kill $node_tail_pid
				break
			fi
		fi
	done

	trap "" EXIT

	[ "$1" != "restore" -a "$rootless" != "1" ] && {
		nxlog "$FUNCNAME ($$): call node_stop_services at ending"
		node_stop_services;
	}
	# close all open file descriptors
	exec 0<&-; exec 1>&-; exec 2>&-;
	nxlog "$FUNCNAME ($$): end"
	exit 0
}

#
# -----------------------------------------------------------------------------
# startsession - Start a new session.
# -----------------------------------------------------------------------------
#
startsession() {
	local txt gvars old_umask realtype
	nxlog "$FUNCNAME ($$): starting with args \"$@\""
#	gvars="agent_domain, agent_password, agent_server, agent_user,\
# application, aux, backingstore, cache, client, clientproto,\
# cookie, cups, display, encryption, extra1, extra2, extra3,\
# freenx_export_agents, fullscreen, geometry, host, http,\
# imagecompressionlevel, imagecompressionmethod, images,\
# kbload, kbtype, keybd, keyboard, keymap, link, login_method,\
# media, mediahelper, nodelay, rdpcache, rdpcolors, render,\
# resize, rootless, samba, screeninfo, session, shadowcookie,
# shadowdisplay, shadowhost, shadowusername, status, sync,\
# type, uniqueid, user, userip, virtualdesktop"

#	set_vars_from_params "$gvars" recode

	set_vars_from_cmdstr "$CMDLINE" "recode"
	# 1.5.0 options: rdpcolors,rdpcache,http
	# nxclient > 1.5.0-106 variables: resize,keybd
	# FreeNX specific variables: clientproto,status,host
	# NX 3.0 shadow mode related variables: shadowusername,shadowcookie,
	# shadowdisplay,shadowhost
	# Authentication method needed by guest mode: login_method
	# dimbor: additional extra-channels extra[1-3], patched nxcomp both
	# on server and client are required

	windows_app=$application
	sess_id="$SERVER_NAME-$display-$uniqueid"
	NXSESSION_DIRECTORY="$USER_FAKE_HOME/.nx/C-$sess_id"
	# ok, lets make the session dir first:
	old_umask=$(umask);
	[ -d $USER_FAKE_HOME ] || { umask 0022; mkdir -p $USER_FAKE_HOME; }
	umask 0077; mkdir -p "$NXSESSION_DIRECTORY"; umask $old_umask
	[ "$geometry" = "fullscreen" ] && fullscreen="1"
	[ "$PROXY_TCP_NODELAY" = "0" ] && nodelay=0
	[ "$ENABLE_ROOTLESS_MODE" = "0" ] && rootless=0
	[ "$ENABLE_EXTERNAL_NXDESKTOP_KEYBOARD" = "1" ] && \
		agent_keyboard=$(cutfn "$keyboard" '/' 1) || agent_keyboard=""
	[ -z "$samba" ] && samba=0
	[ -z "$media" ] && media=0
	[ -z "$nodelay" ] && nodelay=1

	# Rootless fix from 2x nxserver 1.5.0
	realtype=$type
	[ "$type" = "unix-application" -o "$type" = "unix-default" ] && \
		realtype="unix-desktop"
	[ "$type" = "unix-gnome" ] && realtype="gnome"
	[ "$type" = "unix-kde" ] && realtype="kde"
	[ -z "$keybd" ] && keybd=$aux # backwards compatibility for keybd parameter

	[ "$EXPORT_USERIP" = "1" ] && export NXUSERIP="$userip"
	[ "$EXPORT_SESSIONID" = "1" ] && export NXSESSIONID="$sess_id"
	export SHADOW_XAUTHORITY="$NXSESSION_DIRECTORY/authority"

	# export the agent_* options for the helper scripts
	if [ "$freenx_export_agents" = "1" ]; then
		export agent_user
		export agent_password
		export agent_server
		export agent_domain
		export windows_app
		export agent_keyboard
		export NXSESSION_DIRECTORY
		export AGENT_EXTRA_OPTIONS_RFB
		export AGENT_EXTRA_OPTIONS_RDP
		export COMMAND_RDESKTOP
		export COMMAND_VNCVIEWER
		export COMMAND_VNCPASSWD
		export COMMAND_X11VNC
		export PATH_BIN
		export shadowdisplay
		export shadowhost
		export shadowuser
		export shadowcookie
		export ENABLE_SESSION_SHADOWING_AUTHORIZATION
		export ENABLE_INTERACTIVE_SESSION_SHADOWING
		# We do not want to suspend such a session
		# as RDP/RFB are both suspendable as well
		ENABLE_PERSISTENT_SESSION=""
	fi

	# NX 2.1.0 file-sharing port options
	smbport=""
	if [ "$samba" = "1" ]; then
		# We know from protocol traces that client=linux,winnt,macosx are valid values.
		# I hope with smbclientproto=smb on default and smbclientproto=cifs on all valid
		# values we get support for all those systems.
		smbproto="$SAMBA_MOUNT_SHARE_PROTOCOL"
		if [ "$smbproto" = "both" ]; then
			smbproto="smbfs"
			[ "$client" = "linux" ] && smbproto="cifs"
			[ "$client" = "winnt" ] && smbproto="cifs"
			[ "$client" = "macosx" ] && smbproto="cifs"
			# FIXME: This is a rather wild guess
			[ "$client" = "win9x" ] && smbproto="smbfs"
		fi
		if [ "$smbproto" = "cifs" ]; then
			smbport=445
			COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS
			COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
		elif [ "$smbproto" = "none" ]; then
			# we set this to true so that the
			# SMB mount does not give an error message.
			COMMAND_SMBMOUNT=/bin/true; COMMAND_SMBUMOUNT=/bin/true
			smbport=139    #JJK: still may want to do printer sharing...
		else # smbfs
			smbport=139
		fi
	fi
	if [ "$encryption" = "1" ]; then
		# we need to use the IP of the "calling" server now
		# FIXME: cut and sed rm
		#userip=$(echo $SSH_CLIENT $SSH2_CLIENT | cut -d" " -f1 | sed 's/::ffff://g')
		#nxlog "$FUNCNAME ($$): userip='$userip'"
		userip=""
		# If host is the same, use 127.0.0.1, else fallback to default
		[ -z "$userip" -a "$host" = "127.0.0.1" ] && userip="127.0.0.1"
		[ -z "$userip" ] && userip="*"
	else encryption=0
	fi
	# We need our own external IP
	proxyip="$EXTERNAL_PROXY_IP"
	if [ -z "$proxyip" -a -n "$host" ]; then
		[ "$host" = "127.0.0.1" ] && host=$SERVER_NAME
		# FIXME: on modern systems ping resolves lo addr also
		proxyip=$(rematchfn "PING .+\(($ip4_pattern)\)" "$(ping -c1 "$host")") #"
	fi
	[ -z "$proxyip" ] && proxyip="127.0.0.1"


	# cache=8M,images=32M,pack=nopack,link=lan,type=unix-kde,cleanup=0,accept=192.168.1.66,cookie=E38A94A77F975443AF04EC911881B120,id=Knoppix-1000-6A8269CC467264EAEF6349D062689755,samba=1,render=1:1000
	PACK=""
	[ -z "$imagecompressionlevel" ] && imagecompressionlevel="9"
	[ "$imagecompressionmethod" = "0" ] && PACK="pack=nopack,"
	[ "$imagecompressionmethod" = "1" ] && PACK="pack=16m-jpeg-$imagecompressionlevel,"
	[ "$imagecompressionmethod" = "2" ] && PACK="pack=16m-png-9,"

	proxy_cookie=$(echo $[$RANDOM*$RANDOM] | $COMMAND_MD5SUM)
	proxy_cookie=${proxy_cookie%% *}
	# all newer clients support fake cookie authentication
	[ "$clientproto" != "1.4.0" ] &&	cookie=$proxy_cookie

	# write options file
	clipboard="$ENABLE_CLIPBOARD"; menu="$ENABLE_PULLDOWN_MENU"
	CACHE="cache=$cache,"; [ -z "$cache" ] && CACHE=""
	IMAGES="images=$images,"; [ -z "$images" ] && IMAGES=""
	ACCEPT="accept=$userip,"; [ "$userip" = "*" ] && ACCEPT=""

	if [ "$1" = "application" ]; then
		# This needs to be set, else nxagent is terminated
		rootless="1"; virtualdesktop="0"
		nxlog "$FUNCNAME ($$): call 'node_start_applications'"
		node_start_applications &
		echo "NX> 596 Application $application started successfully."
		return
	fi

	old_umask=$(umask); umask 0077
	nxlog "$FUNCNAME ($$): generate \"$NXSESSION_DIRECTORY/options\""
	txt="nx/nx,${keyboard:+keyboard=$keyboard,}${kbtype:+kbtype=$kbtype,}\
${kbload:+kbload=$kbload,}${keymap:+keymap=$keymap,}\
${geometry:+geometry=$geometry,}${client:+client=$client,}\
${resize:+resize=$resize,}${CACHE}${IMAGES}${PACK}link=$link,nodelay=$nodelay,\
type=$realtype,${clipboard:+clipboard=$clipboard,}\
${composite:+composite=$composite,}cleanup=10,product=LFE/None/LFEN/None,\
shmem=1,${backingstore:+backingstore=$backingstore,}shpix=1,\
${ACCEPT}cookie=$proxy_cookie,id=$sess_id,samba=$samba,media=$media\
${sync:+,sync=$sync}${cups:+,cups=$cups}${keybd:+,keybd=$keybd}\
${aux:+,aux=$aux}${http:+,http=$http}${extra1:+,extra1=$extra1}\
${extra2:+,extra2=$extra2}${extra3:+,extra3=$extra3}\
${rdpcolors:+,rdpcolors=$rdpcolors}${rdpcache:+,rdpcache=$rdpcache}\
${fullscreen:+,fullscreen=1}${menu:+,menu=$menu}:$display"
	echo "$txt" > "$NXSESSION_DIRECTORY/options"
	umask $old_umask

	# write xauth script file
	nxlog "$FUNCNAME ($$): write xauth script file"
	txt="add localhost:$display MIT-MAGIC-COOKIE-1 $cookie
add :$display MIT-MAGIC-COOKIE-1 $cookie
exit"
	echo "$txt" | $COMMAND_XAUTH >/dev/null 2>&1
	echo "$txt" | $COMMAND_XAUTH -f "$NXSESSION_DIRECTORY/authority" >/dev/null 2>&1

	mkdir -m700 "$NXSESSION_DIRECTORY/scripts/" 2>/dev/null || \
		chmod 700 "$NXSESSION_DIRECTORY/scripts/"
	txt="remove localhost:$display\nremove :$display\nexit"
	echo -e "$txt" >"$NXSESSION_DIRECTORY/scripts/authority"

	# If we have a shadow cookie, we add it to xauth session authority file as well
	if [ -n "$shadowcookie" ]; then
		nxlog "$FUNCNAME ($$): If we have a shadow cookie, we add it to xauth session authority file as well"
		$COMMAND_XAUTH -f "$SHADOW_XAUTHORITY" add "$shadowhost:$shadowdisplay" MIT-MAGIC-COOKIE-1 "$shadowcookie"
	elif [ -n "$shadowdisplay" ]; then
		# we need to merge in the normal .Xauthority file
		nxlog "$FUNCNAME ($$): we need to merge in the normal .Xauthority file"
		$COMMAND_XAUTH -f "$SHADOW_XAUTHORITY" merge "$HOME/.Xauthority"
	fi

	if [ "$1" = "restore" ]; then
		nxlog "$FUNCNAME ($$): restore session"
		echo > "$NXSESSION_DIRECTORY/session"
		sh -c 'echo "Info: tail -f running with pid '\'\$$\''."; exec tail -n1 -f '"$USER_FAKE_HOME"'/.nx/C-'"$sess_id"'/session' | node_start_monitor "$1" "$status" &
		MONITOR_PID=$!; export MONITOR_PID
		mkdir -p "$NXSESSION_DIRECTORY/pids/"
		echo "$MONITOR_PID" > "$NXSESSION_DIRECTORY/pids/monitor"
		nxlog "$FUNCNAME ($$): call 'node_suspend_session \"$sess_id\"'"
		node_suspend_session "$sess_id" || { echo "Info: Reconnection failed: NX Agent process could not be found." >>"$NXSESSION_DIRECTORY/session"; node_fail_restore_session "$sess_id"; }
	else
		nxlog "$FUNCNAME ($$): call 'node_start_agent'"
		node_start_agent &
		nxlog "$FUNCNAME ($$): call 'node_start_applications'"
		node_start_applications &
	fi

	if [ -x "$NODE_AUTOSTART" ]; then
		nxlog "$FUNCNAME ($$): NODE_AUTOSTART: waiting for nxagent"
		local cntr=$((AGENT_STARTUP_TIMEOUT*100)); local cntr0=$cntr
		while [ ! -f /tmp/.X$display-lock ]; do
			sleep 0.01s; ((cntr--)); ((cntr<=0)) && break
		done
		nxlog "$FUNCNAME ($$): NODE_AUTOSTART: Stop waiting $((cntr0-cntr))0 ms"
		# go into background immediately
		NXSESSIONID="$sess_id" DISPLAY=:$display "$NODE_AUTOSTART" "$1" >/dev/null 2>&1 &
		disown $! # dont't wait for this child!
	fi

	# File-sharing port options
	if [ "$samba" = "1" -a -n "$smbport" ]; then
		echo "$smbport" >"$NXSESSION_DIRECTORY/scripts/smbport"
	fi

	if [ -n "$MONITOR_PID" ]; then
		wait "$MONITOR_PID"
		rm -f "$NXSESSION_DIRECTORY/pids/monitor"
		rm -f "$NXSESSION_DIRECTORY/pids/tail"
	fi
	wait # for all children
	nxlog "$FUNCNAME ($$): end"
}

#
# -----------------------------------------------------------------------------
# cmd_node functions - changes lots of small variables
# -----------------------------------------------------------------------------
#
cmd_node_terminate() {
	sessionid=$(getparam_sessionid)
	echo "$delim 716 Terminating session $sessionid on user request."
	sdir=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid)
	display=$(cutfn "$sdir" "-" -2)
	sess_id="$SERVER_NAME-$display-$sessionid"
	node_terminate_session "$sess_id"
}

cmd_node_suspend() {
	sessionid=$(getparam_sessionid)
	echo "$delim 716 Suspending session $sessionid on user request."
	sdir=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid)
	display=$(cutfn "$sdir" "-" -2)
	sess_id="$SERVER_NAME-$display-$sessionid"
	node_suspend_session "$sess_id"
}

cmd_node_smbmount() {
	local try_user try_sudo IDS_OPTS EGROUP SFN rc outstr smbport desc_dir
	# Due to a too quick session start, port does not have time to initialize
	sleep 0.2s
	sessionid=$(getparam_sessionid)
	sdir=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid)
	display=$(cutfn "$sdir" "-" -2)
	sess_id="$SERVER_NAME-$display-$sessionid" # dimbor: for called functions
	sess_dir="$USER_FAKE_HOME/.nx/C-$sess_id"
	nxlog "$FUNCNAME ($$): starting with sessionid = $sessionid"
	port=$(getparam port)
	username=$(getparam username 1)
	password=$(getparam password 1)
	share=$(getparam share 1)
	computername=127.0.0.1 # http://bugs.etersoft.ru/show_bug.cgi?id=8841
	dir=$(getparam dir 1); dir=${dir/'$(SHARES)'/MyShares}
	username=$(norm_param $username)
	password=$(norm_param $password)
	share=$(norm_param $share)
	dir=$(norm_param $dir)
	[ -n "$(rematchfn "(MyShares)" "$dir")" ] && dir="$HOME/$dir" #"
	# dimbor: checking mountpoint
	EGROUP=$(id -gn "$USER"); rc=$?
	outstr="$(create_mountpoint "$dir" "$USER" "$EGROUP")"
	[ -n "$outstr" ] && nxlog "$FUNCNAME ($$): create_mountpoint says: \"$outstr\""
	[ $rc -ne 0 ] && { nxlog "$FUNCNAME ($$): Stop mounting."; return 1; }
	smbport=""; [ -r "$sess_dir/scripts/smbport" ] && \
		smbport=$(< $sess_dir/scripts/smbport)
	IDS_OPTS="uid=$USER,gid=$EGROUP,"; try_user=1; try_sudo=0;
	# this function run dedicated. We must define smbproto and COMMAND_SMBMOUNT here, not in startsession.
	if [ "$smbport" = "445" ]; then
		COMMAND_SMBMOUNT=$COMMAND_SMBMOUNT_CIFS; COMMAND_SMBUMOUNT=$COMMAND_SMBUMOUNT_CIFS
		try_user=$(usermount_enable); try_sudo=$(sudomount_enable)
		[ $try_user -eq 0 -a $try_sudo -eq 0 ] && {
			nxlog "$FUNCNAME ($$): Any methods of (u)mounting are not available. Stop mounting."
			return 1;
		}
	elif [ "x$smbport" = "x" ]; then COMMAND_SMBMOUNT=/bin/true
	else smbport=139 # smbfs
	fi

	#do not mount twice
	local mnts=$(rematchfn "(.+)[[:space:]].+$dir" "$(mount)") #"
	if [ -n "$mnts" ]; then
			nxlog "$FUNCNAME ($$): share $mnts already mounted on $dir"
		if [ "$ENABLE_SHARE_MULTIMOUNT" = "1" ]; then
			if [ -z "$(get_sessdir4res "@s@$share")" ]; then
				nxlog "$FUNCNAME ($$): Try to force umount dead mountpoint \"$dir\""
				try_umount_smb "$dir"; rc=$?
				[ $rc -ne 0 ] && {
					nxlog "$FUNCNAME ($$): Umounting FAILED! Stop mounting."
					return 1;
				}
			else
				touch "$sess_dir/scripts/@s@$share"; return;
			fi
		else
			echo "$dir" >> "$sess_dir/scripts/mpoint"
			return
		fi
	fi
	# wait up to 30 sec until nxagent has opened the listener port
	# for samba connections
	for (( i=300; $i; --i )); do
		[ -f "$sess_dir/scripts/mport" ] && break
		sleep 0.1s
	done
	# sometimes the samba port we get from nxserver is not the right one,
	# so let's get it from nxagent
	[ -r "$sess_dir/scripts/mport" ] && port=$(< $sess_dir/scripts/mport)
	try_mount_smb "//$computername/$share" "$dir" "$username" $port "$IDS_OPTS" "$password"
	rc=$?
	if [ $rc -eq 0 ]; then
		if [ "$ENABLE_SHARE_MULTIMOUNT" = "1" ]; then
			nxlog "$FUNCNAME ($$): share \"//$computername/$share\" mount on \"$dir\""
			SFN="@s@$share"
			touch "$sess_dir/scripts/$SFN"
			desc_dir="$USER_FAKE_HOME/.nx/shares_priv" # directory with connection parameters to use sessions together
			[ -d "$desc_dir" ] || {
				mkdir "$desc_dir" && chmod 700 "$desc_dir";
			}
			[ ! -e "$desc_dir/$SFN" ] && touch "$desc_dir/$SFN" && \
				chmod 600 "$desc_dir/$SFN" # create "top-secret" description file
			echo "//$computername/$share&$dir&$username&$password&$IDS_OPTS" > "$desc_dir/$SFN"
		else # not multimount case
			nxlog "$FUNCNAME ($$): share \"//$computername/$share\" mount on \"$dir\""
			$PATH_BIN/nxdialog -dialog ok -caption "NXServer Message" \
				-message "Info: Share: '//$computername/$share' mounted on: '$dir'" \
				-display :$display &
		fi
		echo "$dir" >> "$USER_FAKE_HOME/.nx/C-$SERVER_NAME-$display-$sessionid/scripts/mpoint"
	else
		nxlog "$FUNCNAME ($$): Share //$computername/$share mount FAILED."
		rmdir "$dir" >/dev/null 2>/dev/null #JJK: Remove mount point if empty
		[ "$ENABLE_SHARE_MULTIMOUNT" = "1" ] || $PATH_BIN/nxdialog -dialog ok \
			-caption "NXServer Message" \
			-message "Info: Share: '//$computername/$share' failed to mount." \
			-display :$display &
	fi
}

cmd_node_addprinter() {
	nxlog "$FUNCNAME ($$): starting"
	# Due to a too quick session start, port does not have time to initialize
	sleep 0.2s
	sessionid=$(getparam_sessionid)
	type=$(getparam type)
	port=$(getparam port)
	username=$(getparam username 1)
	password=$(getparam password 1)
	share=$(getparam share 1)
	printer=$(getparam printer 1)
	computername=$(getparam computername 1)
	public=$(getparam public)
	model=$(getparam model 1)
	defaultPrinter=$(getparam defaultPrinter)
	[ -z "$defaultPrinter" ] && defaultPrinter=$(getparam defaultprinter) # for opennx
	sdir=$(cd $USER_FAKE_HOME/.nx/; echo C-$SERVER_NAME-*-$sessionid)
	display=$(cutfn "$sdir" "-" -2)
	sess_id="$SERVER_NAME-$display-$sessionid"
	# normalize
	username=$(norm_param $username)
	password=$(norm_param $password)
	share=$(norm_param $share)
	computername=$(norm_param $computername)
	# this will also setup the userspace cupsd
	export CUPS_SERVER=$(node_cupsd_get_socket)

	if [ "$type" = "smb" ]; then
		if [ -x "$CUPS_BACKEND/nxsmb" ]; then
			[ -r $USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport ] && \
				smbport=$(< $USER_FAKE_HOME/.nx/C-$sess_id/scripts/smbport)
			[ -z "$smbport" ] && smbport=139 # should not happen
			if [ "$smbport" = "445" ]; then smbproto="cifs"
			else smbproto="smb"
			fi
			device_uri="nxsmb://$username:$password@127.0.0.1:$port/$smbproto/$share"
		else
			device_uri="smb://$username:$password@127.0.0.1:$port/$share"
		fi
		name="$share"; ENABLE_CUPS_SEAMLESS="0"
		nxlog "$FUNCNAME ($$): set name = $name; smbport=$smbport; device_uri=$device_uri"
	else
		printer=$(norm_param $printer)
		device_uri="ipp://$username:$password@127.0.0.1:$port/printers/$printer"
		name="$printer"
		nxlog "$FUNCNAME ($$): set name = $name; device_uri=$device_uri"
	fi

	#JJK: I like to also allow 'guest' so you can do things like print
	#JJK: testpages from the CUPS web interface. Note this is required
	#JJK: even for the original user to print test pages
	#JJK:	public="-u allow:$USER"
	public="-u allow:$USER,guest,root"
	[ "$public" == "1" ] && public=""
	export PATH_BIN
	user_ppd_dir="$USER_FAKE_HOME/.nx/config/ppd"
	mkdir -p "$user_ppd_dir"
	nxlog "$FUNCNAME ($$): run with ENABLE_CUPS_SERVER_MODE=$ENABLE_CUPS_SERVER_MODE"
	# dimbor: We use system cupsd
	if [ "$ENABLE_CUPS_SERVER_MODE" = "1" ]; then
		# dimbor: Name of windows share or ipp-printer may be set to name
		# of driver.ppd from $NX_ETC_DIR/ppd/ (without ".ppd").
		# For ipp if driver not found we try it to download like
		# oriiginal behaviour (need installed curl).
		# In case of ENABLE_FOOMATIC="1" share/printer name may set to
		# [@]<printer id>[#<N>][__<driver_num>][-nocheck]
		# @: if sharename started with char "@", force setup to anyone
		# share name driver "HP-LaserJet_4M-Postscript.ppd"
		# http://www.nixp.ru/articles/win_printing_in_linux (hello to DjSpike)
		# <printer id>: significant part of drver's uri.
		# <N>: number of printer instance
		# "__": char "_" twice
		# <driver_num>: number from drver's uri.
		# Driver-uri is first field of output '/usr/lib/cups/driver/* list'
		# -nocheck: do not check remote smb-share by rpclient (to W7 Home clients)
		pre=""; [ "${name:0:1}" = "@" ] && { pre="1"; name=${name:1}; }
		nocheck=""; stringinstring "-nocheck" "$name" && {
			 nocheck="1"; name=${name/-nocheck/}; }
		drv=""; stringinstring "__" "$name" && {
			drv=${name#*__}; name=${name%__*}; }
		nn=""; stringinstring "#" "$name" && {
			nn=${name#*#}; name=${name%#*}; }
		pname="$USER""_""$name""$nn" # user's printer name
		[ -n "$pre" ] && { id="HP-LaserJet_4M-Postscript"; drv="0"; }
		model="$NX_ETC_DIR/ppd/$id.ppd"
		nxlog "$FUNCNAME ($$): set pname = \"$pname\", try to install \"$model\" - N=$nn, drv=$drv, pname=$pname."
		[ "$type" = "smb" ] || [ -r "$model" ] || {
			# try to download "left-nx" ppd (original scheme), needs to use
			# wrapper for nxprint on client side
			# TODO: Rewrite
			[ "$(check_remote_printer "ipp" "fake_param" $port)" = "0" ] && {
				nxlog "$FUNCNAME ($$): Remote CUPS not found!"
				return 1
			}
			errstr=$(curl --proxy "" --digest -o "$model" \
				"http://$username:$password@127.0.0.1:$port/ppd/${name}_nxdl.ppd" 2>&1)
			cmdstr="curl --proxy \"\" --digest -o $model http://$username:******@127.0.0.1:$port/ppd/${name}_nxdl.ppd"
			[ -r "$model" -a -n "$(head -n1 "$model" 2>/dev/null | grep "*PPD-Adobe")" ] && {
				nxlog "$FUNCNAME ($$): $model download SUCCESSFUL."
			} || {
				nxlog "$FUNCNAME ($$): $model is NOT a PPD-file! Contents: \"$(cat $model 2>/dev/null)\""
				nxlog "$FUNCNAME ($$): cmd: $cmdstr"
				nxlog "$FUNCNAME ($$): $errstr"
				rm -f "$model"
			}
		}
		if [ ! -r "$model" ]; then
			# TODO: Rewrite
			[ "$ENABLE_FOOMATIC" != "0" ] &&  { # search ppd-file in cups
				cups_driver_dir="/usr/lib/cups/driver"; uris=""
				for prog in $cups_driver_dir/*; do
					[ -x $prog ] || continue
					stringinstring "gutenprint" "$prog" && \
						mn="$id"|| mn="$id.ppd"
					strs=$($prog list 2>/dev/null | grep "$mn")
					[ -z "$strs" ] && continue
					strs=$(echo "$strs" | \
						awk -F'"' '{ printf("%s\n",$2)}')
					uris="$uris""$strs"
				done
				[ -n "$HASDRV" ] && uris=$(echo "$uris" | awk -F'/' \
					'{nd=substr($1,index($1,":")+1); if (nd ~ '$drv') {printf("%s\n",$0)}}')
				drv_uri=$(echo "$uris" | head -n1)
				[ -n "$drv_uri" ] && {
					nxlog "$FUNCNAME ($$): Try to get \"$model\" from URI \"$drv_uri\""
					prog="$cups_driver_dir/$(echo "$drv_uri" |  awk -F':' '{ printf("%s",$1)}')" #'
					cmdstr="$prog cat $drv_uri"
					$cmdstr > $model
				} || {
					nxlog "$FUNCNAME ($$): Driver for \"$name\" not found in CUPS. STOP installing."
					return 1
				}
			}
		fi
		pfn="@p@$pname" # filename of flag and description files
		sess_dir="$USER_FAKE_HOME/.nx/C-$sess_id"
		desc_dir="$USER_FAKE_HOME/.nx/shares_priv" # directory with connection parameters to use sessions together
		[ -d "$desc_dir" ] || { mkdir "$desc_dir" && chmod 700 "$desc_dir"; }
		[ "$type" = "smb" ] && {
			for (( i=30; $i; --i )); do
				nxlog "$FUNCNAME ($$): wait for smb-port $((30-i))"
				[ -f "$sess_dir/scripts/mport" ] && break
				sleep 1
			done
		} || share=$printer
		# check existing printers
		pstr=$(LC_ALL=C /usr/bin/lpstat -v "$pname" 2>/dev/null)
		if [ -n "$pstr" ]; then # printer present
			iport=$(rematchfn ':([[:digit:]]+)/' "$pstr") #'
			[ "$iport" -gt 0 2>/dev/null ] && drop=0 || { drop=1; dbs="wrong port"; }
			[ -n "$nocheck" ] && { drop=1; dbs="don't check remote printer"; }
			if [ "$drop" = "0" ]; then
				[ "$(check_remote_printer $type $name $iport $username $password)" = "0" ] && \
					{ drop=1; dbs="not accessible"; }
			fi
			[ "$drop" = "0" ] && [ "$type" = "ipp" -o "$iport" = "$port" ] && \
				{ drop=1; dbs="for reinstall"; }
			if [ "$drop" = "1" ]; then
				nxlog "$FUNCNAME ($$): delete printer \"$pname\" (port:$iport) - $dbs"
				/usr/bin/sudo /usr/sbin/lpadmin -x "$pname"
			else
				nxlog "$FUNCNAME ($$): printer \"$pname\" already exist at port:$iport - stop adding, mark only"
				echo $password > "$sess_dir/scripts/$pfn"; chmod 600 "$sess_dir/scripts/$pfn"
				return 0
			fi
		fi
		[ "$(check_remote_printer $type $name $port $username $password)" = "0" ] && {
			nxlog "$FUNCNAME ($$): \"$name\" (mport:$port) NOT ACCESSIBLE stop adding."
			return 1;
		}
		echo $password > "$sess_dir/scripts/$pfn"; chmod 600 "$sess_dir/scripts/$pfn" # set share present flag
		if [ -r "$model" ] ; then
			[ ! -e "$desc_dir/$pfn" ] && touch "$desc_dir/$pfn" \
				&& chmod 600 "$desc_dir/$pfn" # create "top-secret" description file
			echo "$model&$device_uri&$public&$defaultPrinter" > "$desc_dir/$pfn" # confidential access data
			cmdstr="/usr/bin/sudo /usr/sbin/lpadmin -p $pname -P $model -v $device_uri -E"
		else
			nxlog "$FUNCNAME ($$): $model driver not found! Printer $name not installed."
			return 1
		fi
		nxlog "$FUNCNAME ($$): invoke $cmdstr"
		error="$($cmdstr 2>&1)"
		if [ $? -eq 0 ] ; then
			nxlog "$FUNCNAME ($$): printer \"$pname\" installed"
			[ -n "$public" ] && { /usr/bin/sudo /usr/sbin/lpadmin -p $pname $public;
				[ $? -ne 0 ] && nxlog "$FUNCNAME ($$): FAILED to set options \"$public\" for printer \"$pname\""
			}
			[ "$defaultPrinter" = "1" ] && {
				/usr/bin/sudo /usr/sbin/lpadmin -d "$pname";
				[ $? -ne 0 ] && nxlog "$FUNCNAME ($$): FAILED to set default printer \"$pname\""
			}
		else
			nxlog "$FUNCNAME ($$): FAILED to install printer \"$pname\": $error"
		fi
	else # original behaviour
		mkdir -p "$USER_FAKE_HOME/.nx/config/ppd/"
		if [ "$ENABLE_CUPS_SEAMLESS" != "1" ]; then
			#JJK: Export the following variables for use by nxdialog/nxprint
			#JJK: Note they are also exported in nxdialog but doesn't help there
			export ENABLE_FOOMATIC COMMAND_FOOMATIC PPD_DIR
			model=$($PATH_BIN/nxdialog -printer "$name" -display :$display)
			[ -z "$model" -o "$model" = "cancel: aborted" ] && return
		else
			sleep $CUPS_SEAMLESS_DELAY
			model="download_cached"
		fi

		if [ "$model" = "download_new" -o "$model" = "download_cached" ]; then
			if [ "$model" = "download_new" -o ! -r "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" ]; then
				curl --proxy "" --digest -o "$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd" "http://$username:$password@127.0.0.1:$port/ppd/${printer}_nxdl.ppd" >>"$USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log" 2>&1
				rc=$?
				[ $rc -eq 0 -a "$ENABLE_CUPS_SEAMLESS" != "1" ] && $PATH_BIN/nxdialog --message "Download successful." -display :$display
				[ $rc -ne 0 -a "$ENABLE_CUPS_SEAMLESS" != "1" ] && $PATH_BIN/nxdialog --message "Download failed. Log is: $USER_FAKE_HOME/.nx/C-$sess_id/cups/curl.log" -display :$display
			fi
			model="$USER_FAKE_HOME/.nx/config/ppd/$printer.ppd"
		fi
		if [ ! -r "$model" ]; then
			# Foomatic and co
			/usr/sbin/lpadmin -p "$name" -E -v "$device_uri" -m "$model" $public
		else
			/usr/sbin/lpadmin -p "$name" -E -v "$device_uri" -P "$model" $public
		fi

		[ "$defaultPrinter" = "1" ] && /usr/sbin/lpadmin -d "$name"
	fi # end of original
}

case "$1" in
	--startsession)
		startsession
	;;
	--resumesession)
		startsession "restore"
	;;
	--applicationsession)
		startsession "application"
	;;
	--terminate)
		cmd_node_terminate
	;;
	--suspend)
		cmd_node_suspend
	;;
	--smbmount)
		cmd_node_smbmount
	;;
	--addprinter)
			cmd_node_addprinter
	;;
	--check)
		echo "NX> 716 finished"
	;;
	--agent)
		echo "NX> 716 Starting NX Agent ..."
		shift
		[ "$SET_LD_LIBRARY_PATH" = "1" ] && export LD_LIBRARY_PATH="$AGENT_LIBRARY_PATH:$LD_LIBRARY_PATH"
		PATH="$PATH:$PATH_BIN" $COMMAND_NXAGENT \
			-name "NX Agent Test - Args: $@" $@
		echo "NX> 716 NX Agent exited with status: $?"
	;;
	--setkey)
		mkdir -m 700 -p $HOME/.ssh
		if ! grep -q "$(cat $NX_ETC_DIR/users.id_dsa.pub)" $HOME/.ssh/$SSH_AUTHORIZED_KEYS 2>/dev/null; then
			cat $NX_ETC_DIR/users.id_dsa.pub >> $HOME/.ssh/$SSH_AUTHORIZED_KEYS
			chmod 600 $HOME/.ssh/$SSH_AUTHORIZED_KEYS
			echo "NX> 716 Public key added to: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
		else
			echo "NX> 716 Public key is already present in: $HOME/.ssh/$SSH_AUTHORIZED_KEYS"
		fi
	;;
	*)
		echo "NX> 500 Error: Command not found"
	;;
esac

echo "$delim 1001 Bye."
